/* soapC.cpp
   Generated by gSOAP 2.8.15 from xmlaWSDL.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.15 2013-08-15 23:07:19 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns3__XmlSchemaUse:
		return soap_in_ns3__XmlSchemaUse(soap, NULL, NULL, "ns3:XmlSchemaUse");
	case SOAP_TYPE_ns3__XmlSchemaContentProcessing:
		return soap_in_ns3__XmlSchemaContentProcessing(soap, NULL, NULL, "ns3:XmlSchemaContentProcessing");
	case SOAP_TYPE_ns3__XmlSchemaForm:
		return soap_in_ns3__XmlSchemaForm(soap, NULL, NULL, "ns3:XmlSchemaForm");
	case SOAP_TYPE_ns3__XmlSchemaDerivationMethod:
		return soap_in_ns3__XmlSchemaDerivationMethod(soap, NULL, NULL, "ns3:XmlSchemaDerivationMethod");
	case SOAP_TYPE_ns6__UsernameTokenElement:
		return soap_in_ns6__UsernameTokenElement(soap, NULL, NULL, "ns6:UsernameTokenElement");
	case SOAP_TYPE_ns6__Security:
		return soap_in_ns6__Security(soap, NULL, NULL, "ns6:Security");
	case SOAP_TYPE_ns5__CellInfo:
		return soap_in_ns5__CellInfo(soap, NULL, NULL, "ns5:CellInfo");
	case SOAP_TYPE_ns5__HierarchyInfo:
		return soap_in_ns5__HierarchyInfo(soap, NULL, NULL, "ns5:HierarchyInfo");
	case SOAP_TYPE_ns5__AxisInfo:
		return soap_in_ns5__AxisInfo(soap, NULL, NULL, "ns5:AxisInfo");
	case SOAP_TYPE_ns5__AxesInfo:
		return soap_in_ns5__AxesInfo(soap, NULL, NULL, "ns5:AxesInfo");
	case SOAP_TYPE_ns5__Cube:
		return soap_in_ns5__Cube(soap, NULL, NULL, "ns5:Cube");
	case SOAP_TYPE_ns5__CubeInfo:
		return soap_in_ns5__CubeInfo(soap, NULL, NULL, "ns5:CubeInfo");
	case SOAP_TYPE_ns5__OlapInfo:
		return soap_in_ns5__OlapInfo(soap, NULL, NULL, "ns5:OlapInfo");
	case SOAP_TYPE_ns5__Row:
		return soap_in_ns5__Row(soap, NULL, NULL, "ns5:Row");
	case SOAP_TYPE_ns5__Members:
		return soap_in_ns5__Members(soap, NULL, NULL, "ns5:Members");
	case SOAP_TYPE_ns5__CrossProduct:
		return soap_in_ns5__CrossProduct(soap, NULL, NULL, "ns5:CrossProduct");
	case SOAP_TYPE_ns5__Member:
		return soap_in_ns5__Member(soap, NULL, NULL, "ns5:Member");
	case SOAP_TYPE_ns5__Tuple:
		return soap_in_ns5__Tuple(soap, NULL, NULL, "ns5:Tuple");
	case SOAP_TYPE_ns5__Tuples:
		return soap_in_ns5__Tuples(soap, NULL, NULL, "ns5:Tuples");
	case SOAP_TYPE_ns5__Axis:
		return soap_in_ns5__Axis(soap, NULL, NULL, "ns5:Axis");
	case SOAP_TYPE_ns5__Axes:
		return soap_in_ns5__Axes(soap, NULL, NULL, "ns5:Axes");
	case SOAP_TYPE_ns5__Cell:
		return soap_in_ns5__Cell(soap, NULL, NULL, "ns5:Cell");
	case SOAP_TYPE_ns5__CellData:
		return soap_in_ns5__CellData(soap, NULL, NULL, "ns5:CellData");
	case SOAP_TYPE_ns5__ResultXmlRoot:
		return soap_in_ns5__ResultXmlRoot(soap, NULL, NULL, "ns5:ResultXmlRoot");
	case SOAP_TYPE_ns4__CellInfo:
		return soap_in_ns4__CellInfo(soap, NULL, NULL, "ns4:CellInfo");
	case SOAP_TYPE_ns4__HierarchyInfo:
		return soap_in_ns4__HierarchyInfo(soap, NULL, NULL, "ns4:HierarchyInfo");
	case SOAP_TYPE_ns4__AxisInfo:
		return soap_in_ns4__AxisInfo(soap, NULL, NULL, "ns4:AxisInfo");
	case SOAP_TYPE_ns4__AxesInfo:
		return soap_in_ns4__AxesInfo(soap, NULL, NULL, "ns4:AxesInfo");
	case SOAP_TYPE_ns4__Cube:
		return soap_in_ns4__Cube(soap, NULL, NULL, "ns4:Cube");
	case SOAP_TYPE_ns4__CubeInfo:
		return soap_in_ns4__CubeInfo(soap, NULL, NULL, "ns4:CubeInfo");
	case SOAP_TYPE_ns4__OlapInfo:
		return soap_in_ns4__OlapInfo(soap, NULL, NULL, "ns4:OlapInfo");
	case SOAP_TYPE_ns4__Row:
		return soap_in_ns4__Row(soap, NULL, NULL, "ns4:Row");
	case SOAP_TYPE_ns4__Members:
		return soap_in_ns4__Members(soap, NULL, NULL, "ns4:Members");
	case SOAP_TYPE_ns4__CrossProduct:
		return soap_in_ns4__CrossProduct(soap, NULL, NULL, "ns4:CrossProduct");
	case SOAP_TYPE_ns4__Member:
		return soap_in_ns4__Member(soap, NULL, NULL, "ns4:Member");
	case SOAP_TYPE_ns4__Tuple:
		return soap_in_ns4__Tuple(soap, NULL, NULL, "ns4:Tuple");
	case SOAP_TYPE_ns4__Tuples:
		return soap_in_ns4__Tuples(soap, NULL, NULL, "ns4:Tuples");
	case SOAP_TYPE_ns4__Axis:
		return soap_in_ns4__Axis(soap, NULL, NULL, "ns4:Axis");
	case SOAP_TYPE_ns4__Axes:
		return soap_in_ns4__Axes(soap, NULL, NULL, "ns4:Axes");
	case SOAP_TYPE_ns4__Cell:
		return soap_in_ns4__Cell(soap, NULL, NULL, "ns4:Cell");
	case SOAP_TYPE_ns4__CellData:
		return soap_in_ns4__CellData(soap, NULL, NULL, "ns4:CellData");
	case SOAP_TYPE_ns4__ResultXmlRoot:
		return soap_in_ns4__ResultXmlRoot(soap, NULL, NULL, "ns4:ResultXmlRoot");
	case SOAP_TYPE_ns3__XmlSchemaInclude:
		return soap_in_ns3__XmlSchemaInclude(soap, NULL, NULL, "ns3:XmlSchemaInclude");
	case SOAP_TYPE_ns3__XmlSchemaRedefine:
		return soap_in_ns3__XmlSchemaRedefine(soap, NULL, NULL, "ns3:XmlSchemaRedefine");
	case SOAP_TYPE_ns3__XmlSchemaImport:
		return soap_in_ns3__XmlSchemaImport(soap, NULL, NULL, "ns3:XmlSchemaImport");
	case SOAP_TYPE_ns3__XmlSchemaExternal:
		return soap_in_ns3__XmlSchemaExternal(soap, NULL, NULL, "ns3:XmlSchemaExternal");
	case SOAP_TYPE_ns3__XmlSchemaGroup:
		return soap_in_ns3__XmlSchemaGroup(soap, NULL, NULL, "ns3:XmlSchemaGroup");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeList:
		return soap_in_ns3__XmlSchemaSimpleTypeList(soap, NULL, NULL, "ns3:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction:
		return soap_in_ns3__XmlSchemaSimpleTypeRestriction(soap, NULL, NULL, "ns3:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent:
		return soap_in_ns3__XmlSchemaSimpleTypeContent(soap, NULL, NULL, "ns3:XmlSchemaSimpleTypeContent");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion:
		return soap_in_ns3__XmlSchemaSimpleTypeUnion(soap, NULL, NULL, "ns3:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet:
		return soap_in_ns3__XmlSchemaMaxExclusiveFacet(soap, NULL, NULL, "ns3:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet:
		return soap_in_ns3__XmlSchemaMinInclusiveFacet(soap, NULL, NULL, "ns3:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet:
		return soap_in_ns3__XmlSchemaMaxInclusiveFacet(soap, NULL, NULL, "ns3:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinLengthFacet:
		return soap_in_ns3__XmlSchemaMinLengthFacet(soap, NULL, NULL, "ns3:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet:
		return soap_in_ns3__XmlSchemaMaxLengthFacet(soap, NULL, NULL, "ns3:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaLengthFacet:
		return soap_in_ns3__XmlSchemaLengthFacet(soap, NULL, NULL, "ns3:XmlSchemaLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet:
		return soap_in_ns3__XmlSchemaTotalDigitsFacet(soap, NULL, NULL, "ns3:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet:
		return soap_in_ns3__XmlSchemaFractionDigitsFacet(soap, NULL, NULL, "ns3:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_ns3__XmlSchemaNumericFacet:
		return soap_in_ns3__XmlSchemaNumericFacet(soap, NULL, NULL, "ns3:XmlSchemaNumericFacet");
	case SOAP_TYPE_ns3__XmlSchemaPatternFacet:
		return soap_in_ns3__XmlSchemaPatternFacet(soap, NULL, NULL, "ns3:XmlSchemaPatternFacet");
	case SOAP_TYPE_ns3__XmlSchemaEnumerationFacet:
		return soap_in_ns3__XmlSchemaEnumerationFacet(soap, NULL, NULL, "ns3:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet:
		return soap_in_ns3__XmlSchemaWhiteSpaceFacet(soap, NULL, NULL, "ns3:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_ns3__XmlSchemaFacet:
		return soap_in_ns3__XmlSchemaFacet(soap, NULL, NULL, "ns3:XmlSchemaFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet:
		return soap_in_ns3__XmlSchemaMinExclusiveFacet(soap, NULL, NULL, "ns3:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction:
		return soap_in_ns3__XmlSchemaSimpleContentRestriction(soap, NULL, NULL, "ns3:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension:
		return soap_in_ns3__XmlSchemaSimpleContentExtension(soap, NULL, NULL, "ns3:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_ns3__XmlSchemaAnyAttribute:
		return soap_in_ns3__XmlSchemaAnyAttribute(soap, NULL, NULL, "ns3:XmlSchemaAnyAttribute");
	case SOAP_TYPE_ns3__XmlSchemaAll:
		return soap_in_ns3__XmlSchemaAll(soap, NULL, NULL, "ns3:XmlSchemaAll");
	case SOAP_TYPE_ns3__XmlSchemaSequence:
		return soap_in_ns3__XmlSchemaSequence(soap, NULL, NULL, "ns3:XmlSchemaSequence");
	case SOAP_TYPE_ns3__XmlSchemaChoice:
		return soap_in_ns3__XmlSchemaChoice(soap, NULL, NULL, "ns3:XmlSchemaChoice");
	case SOAP_TYPE_ns3__XmlSchemaGroupBase:
		return soap_in_ns3__XmlSchemaGroupBase(soap, NULL, NULL, "ns3:XmlSchemaGroupBase");
	case SOAP_TYPE_ns3__XmlSchemaAny:
		return soap_in_ns3__XmlSchemaAny(soap, NULL, NULL, "ns3:XmlSchemaAny");
	case SOAP_TYPE_ns3__XmlSchemaKey:
		return soap_in_ns3__XmlSchemaKey(soap, NULL, NULL, "ns3:XmlSchemaKey");
	case SOAP_TYPE_ns3__XmlSchemaKeyref:
		return soap_in_ns3__XmlSchemaKeyref(soap, NULL, NULL, "ns3:XmlSchemaKeyref");
	case SOAP_TYPE_ns3__XmlSchemaXPath:
		return soap_in_ns3__XmlSchemaXPath(soap, NULL, NULL, "ns3:XmlSchemaXPath");
	case SOAP_TYPE_ns3__XmlSchemaIdentityConstraint:
		return soap_in_ns3__XmlSchemaIdentityConstraint(soap, NULL, NULL, "ns3:XmlSchemaIdentityConstraint");
	case SOAP_TYPE_ns3__XmlSchemaUnique:
		return soap_in_ns3__XmlSchemaUnique(soap, NULL, NULL, "ns3:XmlSchemaUnique");
	case SOAP_TYPE_ns3__XmlSchemaElement:
		return soap_in_ns3__XmlSchemaElement(soap, NULL, NULL, "ns3:XmlSchemaElement");
	case SOAP_TYPE_ns3__XmlSchemaParticle:
		return soap_in_ns3__XmlSchemaParticle(soap, NULL, NULL, "ns3:XmlSchemaParticle");
	case SOAP_TYPE_ns3__XmlSchemaGroupRef:
		return soap_in_ns3__XmlSchemaGroupRef(soap, NULL, NULL, "ns3:XmlSchemaGroupRef");
	case SOAP_TYPE_ns3__XmlSchemaComplexContentExtension:
		return soap_in_ns3__XmlSchemaComplexContentExtension(soap, NULL, NULL, "ns3:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_ns3__XmlSchemaContent:
		return soap_in_ns3__XmlSchemaContent(soap, NULL, NULL, "ns3:XmlSchemaContent");
	case SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction:
		return soap_in_ns3__XmlSchemaComplexContentRestriction(soap, NULL, NULL, "ns3:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_ns3__XmlSchemaComplexContent:
		return soap_in_ns3__XmlSchemaComplexContent(soap, NULL, NULL, "ns3:XmlSchemaComplexContent");
	case SOAP_TYPE_ns3__XmlSchemaContentModel:
		return soap_in_ns3__XmlSchemaContentModel(soap, NULL, NULL, "ns3:XmlSchemaContentModel");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContent:
		return soap_in_ns3__XmlSchemaSimpleContent(soap, NULL, NULL, "ns3:XmlSchemaSimpleContent");
	case SOAP_TYPE_ns3__XmlSchemaComplexType:
		return soap_in_ns3__XmlSchemaComplexType(soap, NULL, NULL, "ns3:XmlSchemaComplexType");
	case SOAP_TYPE_ns3__XmlSchemaType:
		return soap_in_ns3__XmlSchemaType(soap, NULL, NULL, "ns3:XmlSchemaType");
	case SOAP_TYPE_ns3__XmlSchemaSimpleType:
		return soap_in_ns3__XmlSchemaSimpleType(soap, NULL, NULL, "ns3:XmlSchemaSimpleType");
	case SOAP_TYPE_ns3__XmlSchemaAttribute:
		return soap_in_ns3__XmlSchemaAttribute(soap, NULL, NULL, "ns3:XmlSchemaAttribute");
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef:
		return soap_in_ns3__XmlSchemaAttributeGroupRef(soap, NULL, NULL, "ns3:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroup:
		return soap_in_ns3__XmlSchemaAttributeGroup(soap, NULL, NULL, "ns3:XmlSchemaAttributeGroup");
	case SOAP_TYPE_ns3__XmlSchemaNotation:
		return soap_in_ns3__XmlSchemaNotation(soap, NULL, NULL, "ns3:XmlSchemaNotation");
	case SOAP_TYPE_ns3__XmlSchemaAppInfo:
		return soap_in_ns3__XmlSchemaAppInfo(soap, NULL, NULL, "ns3:XmlSchemaAppInfo");
	case SOAP_TYPE_ns3__XmlSchemaDocumentation:
		return soap_in_ns3__XmlSchemaDocumentation(soap, NULL, NULL, "ns3:XmlSchemaDocumentation");
	case SOAP_TYPE_ns3__XmlSchemaAnnotation:
		return soap_in_ns3__XmlSchemaAnnotation(soap, NULL, NULL, "ns3:XmlSchemaAnnotation");
	case SOAP_TYPE_ns3__XmlSchemaAnnotated:
		return soap_in_ns3__XmlSchemaAnnotated(soap, NULL, NULL, "ns3:XmlSchemaAnnotated");
	case SOAP_TYPE_ns3__XmlSchemaObject:
		return soap_in_ns3__XmlSchemaObject(soap, NULL, NULL, "ns3:XmlSchemaObject");
	case SOAP_TYPE_ns3__XmlSchema:
		return soap_in_ns3__XmlSchema(soap, NULL, NULL, "ns3:XmlSchema");
	case SOAP_TYPE_ns2__CellInfo:
		return soap_in_ns2__CellInfo(soap, NULL, NULL, "ns2:CellInfo");
	case SOAP_TYPE_ns2__HierarchyInfo:
		return soap_in_ns2__HierarchyInfo(soap, NULL, NULL, "ns2:HierarchyInfo");
	case SOAP_TYPE_ns2__AxisInfo:
		return soap_in_ns2__AxisInfo(soap, NULL, NULL, "ns2:AxisInfo");
	case SOAP_TYPE_ns2__AxesInfo:
		return soap_in_ns2__AxesInfo(soap, NULL, NULL, "ns2:AxesInfo");
	case SOAP_TYPE_ns2__Cube:
		return soap_in_ns2__Cube(soap, NULL, NULL, "ns2:Cube");
	case SOAP_TYPE_ns2__CubeInfo:
		return soap_in_ns2__CubeInfo(soap, NULL, NULL, "ns2:CubeInfo");
	case SOAP_TYPE_ns2__OlapInfo:
		return soap_in_ns2__OlapInfo(soap, NULL, NULL, "ns2:OlapInfo");
	case SOAP_TYPE_ns2__Row:
		return soap_in_ns2__Row(soap, NULL, NULL, "ns2:Row");
	case SOAP_TYPE_ns2__Members:
		return soap_in_ns2__Members(soap, NULL, NULL, "ns2:Members");
	case SOAP_TYPE_ns2__CrossProduct:
		return soap_in_ns2__CrossProduct(soap, NULL, NULL, "ns2:CrossProduct");
	case SOAP_TYPE_ns2__Member:
		return soap_in_ns2__Member(soap, NULL, NULL, "ns2:Member");
	case SOAP_TYPE_ns2__Tuple:
		return soap_in_ns2__Tuple(soap, NULL, NULL, "ns2:Tuple");
	case SOAP_TYPE_ns2__Tuples:
		return soap_in_ns2__Tuples(soap, NULL, NULL, "ns2:Tuples");
	case SOAP_TYPE_ns2__Axis:
		return soap_in_ns2__Axis(soap, NULL, NULL, "ns2:Axis");
	case SOAP_TYPE_ns2__Axes:
		return soap_in_ns2__Axes(soap, NULL, NULL, "ns2:Axes");
	case SOAP_TYPE_ns2__Cell:
		return soap_in_ns2__Cell(soap, NULL, NULL, "ns2:Cell");
	case SOAP_TYPE_ns2__CellData:
		return soap_in_ns2__CellData(soap, NULL, NULL, "ns2:CellData");
	case SOAP_TYPE_ns2__ResultXmlRoot:
		return soap_in_ns2__ResultXmlRoot(soap, NULL, NULL, "ns2:ResultXmlRoot");
	case SOAP_TYPE_ns1__RestrictionList:
		return soap_in_ns1__RestrictionList(soap, NULL, NULL, "ns1:RestrictionList");
	case SOAP_TYPE_ns1__Restrictions:
		return soap_in_ns1__Restrictions(soap, NULL, NULL, "ns1:Restrictions");
	case SOAP_TYPE_ns1__EndSession:
		return soap_in_ns1__EndSession(soap, NULL, NULL, "ns1:EndSession");
	case SOAP_TYPE_ns1__Session:
		return soap_in_ns1__Session(soap, NULL, NULL, "ns1:Session");
	case SOAP_TYPE_ns1__BeginSession:
		return soap_in_ns1__BeginSession(soap, NULL, NULL, "ns1:BeginSession");
	case SOAP_TYPE_ns1__ResultSet:
		return soap_in_ns1__ResultSet(soap, NULL, NULL, "ns1:ResultSet");
	case SOAP_TYPE_ns1__Parameters:
		return soap_in_ns1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_ns1__PropertyList:
		return soap_in_ns1__PropertyList(soap, NULL, NULL, "ns1:PropertyList");
	case SOAP_TYPE_ns1__Properties:
		return soap_in_ns1__Properties(soap, NULL, NULL, "ns1:Properties");
	case SOAP_TYPE_ns1__CommandStatement:
		return soap_in_ns1__CommandStatement(soap, NULL, NULL, "ns1:CommandStatement");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__XmlSchemaXPath:
		return soap_in_xsd__XmlSchemaXPath(soap, NULL, NULL, "xsd:XmlSchemaXPath");
	case SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet:
		return soap_in_xsd__XmlSchemaWhiteSpaceFacet(soap, NULL, NULL, "xsd:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_xsd__XmlSchemaUse:
		return soap_in_xsd__XmlSchemaUse(soap, NULL, NULL, "xsd:XmlSchemaUse");
	case SOAP_TYPE_xsd__XmlSchemaUnique:
		return soap_in_xsd__XmlSchemaUnique(soap, NULL, NULL, "xsd:XmlSchemaUnique");
	case SOAP_TYPE_xsd__XmlSchemaType:
		return soap_in_xsd__XmlSchemaType(soap, NULL, NULL, "xsd:XmlSchemaType");
	case SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet:
		return soap_in_xsd__XmlSchemaTotalDigitsFacet(soap, NULL, NULL, "xsd:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion:
		return soap_in_xsd__XmlSchemaSimpleTypeUnion(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction:
		return soap_in_xsd__XmlSchemaSimpleTypeRestriction(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeList:
		return soap_in_xsd__XmlSchemaSimpleTypeList(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent:
		return soap_in_xsd__XmlSchemaSimpleTypeContent(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeContent");
	case SOAP_TYPE_xsd__XmlSchemaSimpleType:
		return soap_in_xsd__XmlSchemaSimpleType(soap, NULL, NULL, "xsd:XmlSchemaSimpleType");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction:
		return soap_in_xsd__XmlSchemaSimpleContentRestriction(soap, NULL, NULL, "xsd:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension:
		return soap_in_xsd__XmlSchemaSimpleContentExtension(soap, NULL, NULL, "xsd:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContent:
		return soap_in_xsd__XmlSchemaSimpleContent(soap, NULL, NULL, "xsd:XmlSchemaSimpleContent");
	case SOAP_TYPE_xsd__XmlSchemaSequence:
		return soap_in_xsd__XmlSchemaSequence(soap, NULL, NULL, "xsd:XmlSchemaSequence");
	case SOAP_TYPE_xsd__XmlSchemaRedefine:
		return soap_in_xsd__XmlSchemaRedefine(soap, NULL, NULL, "xsd:XmlSchemaRedefine");
	case SOAP_TYPE_xsd__XmlSchemaPatternFacet:
		return soap_in_xsd__XmlSchemaPatternFacet(soap, NULL, NULL, "xsd:XmlSchemaPatternFacet");
	case SOAP_TYPE_xsd__XmlSchemaParticle:
		return soap_in_xsd__XmlSchemaParticle(soap, NULL, NULL, "xsd:XmlSchemaParticle");
	case SOAP_TYPE_xsd__XmlSchemaObject:
		return soap_in_xsd__XmlSchemaObject(soap, NULL, NULL, "xsd:XmlSchemaObject");
	case SOAP_TYPE_xsd__XmlSchemaNumericFacet:
		return soap_in_xsd__XmlSchemaNumericFacet(soap, NULL, NULL, "xsd:XmlSchemaNumericFacet");
	case SOAP_TYPE_xsd__XmlSchemaNotation:
		return soap_in_xsd__XmlSchemaNotation(soap, NULL, NULL, "xsd:XmlSchemaNotation");
	case SOAP_TYPE_xsd__XmlSchemaMinLengthFacet:
		return soap_in_xsd__XmlSchemaMinLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet:
		return soap_in_xsd__XmlSchemaMinInclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet:
		return soap_in_xsd__XmlSchemaMinExclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet:
		return soap_in_xsd__XmlSchemaMaxLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet:
		return soap_in_xsd__XmlSchemaMaxInclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet:
		return soap_in_xsd__XmlSchemaMaxExclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaLengthFacet:
		return soap_in_xsd__XmlSchemaLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaKeyref:
		return soap_in_xsd__XmlSchemaKeyref(soap, NULL, NULL, "xsd:XmlSchemaKeyref");
	case SOAP_TYPE_xsd__XmlSchemaKey:
		return soap_in_xsd__XmlSchemaKey(soap, NULL, NULL, "xsd:XmlSchemaKey");
	case SOAP_TYPE_xsd__XmlSchemaInclude:
		return soap_in_xsd__XmlSchemaInclude(soap, NULL, NULL, "xsd:XmlSchemaInclude");
	case SOAP_TYPE_xsd__XmlSchemaImport:
		return soap_in_xsd__XmlSchemaImport(soap, NULL, NULL, "xsd:XmlSchemaImport");
	case SOAP_TYPE_xsd__XmlSchemaIdentityConstraint:
		return soap_in_xsd__XmlSchemaIdentityConstraint(soap, NULL, NULL, "xsd:XmlSchemaIdentityConstraint");
	case SOAP_TYPE_xsd__XmlSchemaGroupRef:
		return soap_in_xsd__XmlSchemaGroupRef(soap, NULL, NULL, "xsd:XmlSchemaGroupRef");
	case SOAP_TYPE_xsd__XmlSchemaGroupBase:
		return soap_in_xsd__XmlSchemaGroupBase(soap, NULL, NULL, "xsd:XmlSchemaGroupBase");
	case SOAP_TYPE_xsd__XmlSchemaGroup:
		return soap_in_xsd__XmlSchemaGroup(soap, NULL, NULL, "xsd:XmlSchemaGroup");
	case SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet:
		return soap_in_xsd__XmlSchemaFractionDigitsFacet(soap, NULL, NULL, "xsd:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_xsd__XmlSchemaForm:
		return soap_in_xsd__XmlSchemaForm(soap, NULL, NULL, "xsd:XmlSchemaForm");
	case SOAP_TYPE_xsd__XmlSchemaFacet:
		return soap_in_xsd__XmlSchemaFacet(soap, NULL, NULL, "xsd:XmlSchemaFacet");
	case SOAP_TYPE_xsd__XmlSchemaExternal:
		return soap_in_xsd__XmlSchemaExternal(soap, NULL, NULL, "xsd:XmlSchemaExternal");
	case SOAP_TYPE_xsd__XmlSchemaEnumerationFacet:
		return soap_in_xsd__XmlSchemaEnumerationFacet(soap, NULL, NULL, "xsd:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_xsd__XmlSchemaElement:
		return soap_in_xsd__XmlSchemaElement(soap, NULL, NULL, "xsd:XmlSchemaElement");
	case SOAP_TYPE_xsd__XmlSchemaDocumentation:
		return soap_in_xsd__XmlSchemaDocumentation(soap, NULL, NULL, "xsd:XmlSchemaDocumentation");
	case SOAP_TYPE_xsd__XmlSchemaDerivationMethod:
		return soap_in_xsd__XmlSchemaDerivationMethod(soap, NULL, NULL, "xsd:XmlSchemaDerivationMethod");
	case SOAP_TYPE_xsd__XmlSchemaContentProcessing:
		return soap_in_xsd__XmlSchemaContentProcessing(soap, NULL, NULL, "xsd:XmlSchemaContentProcessing");
	case SOAP_TYPE_xsd__XmlSchemaContentModel:
		return soap_in_xsd__XmlSchemaContentModel(soap, NULL, NULL, "xsd:XmlSchemaContentModel");
	case SOAP_TYPE_xsd__XmlSchemaContent:
		return soap_in_xsd__XmlSchemaContent(soap, NULL, NULL, "xsd:XmlSchemaContent");
	case SOAP_TYPE_xsd__XmlSchemaComplexType:
		return soap_in_xsd__XmlSchemaComplexType(soap, NULL, NULL, "xsd:XmlSchemaComplexType");
	case SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction:
		return soap_in_xsd__XmlSchemaComplexContentRestriction(soap, NULL, NULL, "xsd:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_xsd__XmlSchemaComplexContentExtension:
		return soap_in_xsd__XmlSchemaComplexContentExtension(soap, NULL, NULL, "xsd:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_xsd__XmlSchemaComplexContent:
		return soap_in_xsd__XmlSchemaComplexContent(soap, NULL, NULL, "xsd:XmlSchemaComplexContent");
	case SOAP_TYPE_xsd__XmlSchemaChoice:
		return soap_in_xsd__XmlSchemaChoice(soap, NULL, NULL, "xsd:XmlSchemaChoice");
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef:
		return soap_in_xsd__XmlSchemaAttributeGroupRef(soap, NULL, NULL, "xsd:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroup:
		return soap_in_xsd__XmlSchemaAttributeGroup(soap, NULL, NULL, "xsd:XmlSchemaAttributeGroup");
	case SOAP_TYPE_xsd__XmlSchemaAttribute:
		return soap_in_xsd__XmlSchemaAttribute(soap, NULL, NULL, "xsd:XmlSchemaAttribute");
	case SOAP_TYPE_xsd__XmlSchemaAppInfo:
		return soap_in_xsd__XmlSchemaAppInfo(soap, NULL, NULL, "xsd:XmlSchemaAppInfo");
	case SOAP_TYPE_xsd__XmlSchemaAnyAttribute:
		return soap_in_xsd__XmlSchemaAnyAttribute(soap, NULL, NULL, "xsd:XmlSchemaAnyAttribute");
	case SOAP_TYPE_xsd__XmlSchemaAny:
		return soap_in_xsd__XmlSchemaAny(soap, NULL, NULL, "xsd:XmlSchemaAny");
	case SOAP_TYPE_xsd__XmlSchemaAnnotation:
		return soap_in_xsd__XmlSchemaAnnotation(soap, NULL, NULL, "xsd:XmlSchemaAnnotation");
	case SOAP_TYPE_xsd__XmlSchemaAnnotated:
		return soap_in_xsd__XmlSchemaAnnotated(soap, NULL, NULL, "xsd:XmlSchemaAnnotated");
	case SOAP_TYPE_xsd__XmlSchemaAll:
		return soap_in_xsd__XmlSchemaAll(soap, NULL, NULL, "xsd:XmlSchemaAll");
	case SOAP_TYPE_xsd__XmlSchema:
		return soap_in_xsd__XmlSchema(soap, NULL, NULL, "xsd:XmlSchema");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__DiscoverResponse:
		return soap_in_PointerTo_ns1__DiscoverResponse(soap, NULL, NULL, "ns1:DiscoverResponse");
	case SOAP_TYPE_PointerTo_ns1__Discover:
		return soap_in_PointerTo_ns1__Discover(soap, NULL, NULL, "ns1:Discover");
	case SOAP_TYPE_PointerTo_ns1__ExecuteResponse:
		return soap_in_PointerTo_ns1__ExecuteResponse(soap, NULL, NULL, "ns1:ExecuteResponse");
	case SOAP_TYPE_PointerTo_ns1__Execute:
		return soap_in_PointerTo_ns1__Execute(soap, NULL, NULL, "ns1:Execute");
	case SOAP_TYPE_PointerTons6__Security:
		return soap_in_PointerTons6__Security(soap, NULL, NULL, "ns6:Security");
	case SOAP_TYPE_PointerTons1__Session:
		return soap_in_PointerTons1__Session(soap, NULL, NULL, "ns1:Session");
	case SOAP_TYPE_PointerTons1__EndSession:
		return soap_in_PointerTons1__EndSession(soap, NULL, NULL, "ns1:EndSession");
	case SOAP_TYPE_PointerTons1__BeginSession:
		return soap_in_PointerTons1__BeginSession(soap, NULL, NULL, "ns1:BeginSession");
	case SOAP_TYPE_PointerToxsd__XmlSchemaFractionDigitsFacet:
		return soap_in_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, NULL, NULL, "xsd:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaTotalDigitsFacet:
		return soap_in_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, NULL, NULL, "xsd:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaWhiteSpaceFacet:
		return soap_in_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, NULL, NULL, "xsd:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinInclusiveFacet:
		return soap_in_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxExclusiveFacet:
		return soap_in_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaPatternFacet:
		return soap_in_PointerToxsd__XmlSchemaPatternFacet(soap, NULL, NULL, "xsd:XmlSchemaPatternFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxLengthFacet:
		return soap_in_PointerToxsd__XmlSchemaMaxLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinLengthFacet:
		return soap_in_PointerToxsd__XmlSchemaMinLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaLengthFacet:
		return soap_in_PointerToxsd__XmlSchemaLengthFacet(soap, NULL, NULL, "xsd:XmlSchemaLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxInclusiveFacet:
		return soap_in_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaEnumerationFacet:
		return soap_in_PointerToxsd__XmlSchemaEnumerationFacet(soap, NULL, NULL, "xsd:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinExclusiveFacet:
		return soap_in_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, NULL, NULL, "xsd:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAny:
		return soap_in_PointerToxsd__XmlSchemaAny(soap, NULL, NULL, "xsd:XmlSchemaAny");
	case SOAP_TYPE_PointerToxsd__XmlSchemaContentProcessing:
		return soap_in_PointerToxsd__XmlSchemaContentProcessing(soap, NULL, NULL, "xsd:XmlSchemaContentProcessing");
	case SOAP_TYPE_PointerToxsd__XmlSchemaXPath:
		return soap_in_PointerToxsd__XmlSchemaXPath(soap, NULL, NULL, "xsd:XmlSchemaXPath");
	case SOAP_TYPE_PointerToxsd__XmlSchemaKeyref:
		return soap_in_PointerToxsd__XmlSchemaKeyref(soap, NULL, NULL, "xsd:XmlSchemaKeyref");
	case SOAP_TYPE_PointerToxsd__XmlSchemaKey:
		return soap_in_PointerToxsd__XmlSchemaKey(soap, NULL, NULL, "xsd:XmlSchemaKey");
	case SOAP_TYPE_PointerToxsd__XmlSchemaUnique:
		return soap_in_PointerToxsd__XmlSchemaUnique(soap, NULL, NULL, "xsd:XmlSchemaUnique");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentExtension:
		return soap_in_PointerToxsd__XmlSchemaComplexContentExtension(soap, NULL, NULL, "xsd:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentRestriction:
		return soap_in_PointerToxsd__XmlSchemaComplexContentRestriction(soap, NULL, NULL, "xsd:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentExtension:
		return soap_in_PointerToxsd__XmlSchemaSimpleContentExtension(soap, NULL, NULL, "xsd:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentRestriction:
		return soap_in_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, NULL, NULL, "xsd:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAll:
		return soap_in_PointerToxsd__XmlSchemaAll(soap, NULL, NULL, "xsd:XmlSchemaAll");
	case SOAP_TYPE_PointerToxsd__XmlSchemaChoice:
		return soap_in_PointerToxsd__XmlSchemaChoice(soap, NULL, NULL, "xsd:XmlSchemaChoice");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSequence:
		return soap_in_PointerToxsd__XmlSchemaSequence(soap, NULL, NULL, "xsd:XmlSchemaSequence");
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroupRef:
		return soap_in_PointerToxsd__XmlSchemaGroupRef(soap, NULL, NULL, "xsd:XmlSchemaGroupRef");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContent:
		return soap_in_PointerToxsd__XmlSchemaComplexContent(soap, NULL, NULL, "xsd:XmlSchemaComplexContent");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContent:
		return soap_in_PointerToxsd__XmlSchemaSimpleContent(soap, NULL, NULL, "xsd:XmlSchemaSimpleContent");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeRestriction:
		return soap_in_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeList:
		return soap_in_PointerToxsd__XmlSchemaSimpleTypeList(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeUnion:
		return soap_in_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, NULL, NULL, "xsd:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_PointerToxsd__XmlSchemaUse:
		return soap_in_PointerToxsd__XmlSchemaUse(soap, NULL, NULL, "xsd:XmlSchemaUse");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnyAttribute:
		return soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, NULL, NULL, "xsd:XmlSchemaAnyAttribute");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroupRef:
		return soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, NULL, NULL, "xsd:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAppInfo:
		return soap_in_PointerToxsd__XmlSchemaAppInfo(soap, NULL, NULL, "xsd:XmlSchemaAppInfo");
	case SOAP_TYPE_PointerToxsd__XmlSchemaDocumentation:
		return soap_in_PointerToxsd__XmlSchemaDocumentation(soap, NULL, NULL, "xsd:XmlSchemaDocumentation");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_in_PointerToxsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerToxsd__XmlSchemaDerivationMethod:
		return soap_in_PointerToxsd__XmlSchemaDerivationMethod(soap, NULL, NULL, "xsd:XmlSchemaDerivationMethod");
	case SOAP_TYPE_PointerToxsd__XmlSchemaForm:
		return soap_in_PointerToxsd__XmlSchemaForm(soap, NULL, NULL, "xsd:XmlSchemaForm");
	case SOAP_TYPE_PointerToxsd__XmlSchemaElement:
		return soap_in_PointerToxsd__XmlSchemaElement(soap, NULL, NULL, "xsd:XmlSchemaElement");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleType:
		return soap_in_PointerToxsd__XmlSchemaSimpleType(soap, NULL, NULL, "xsd:XmlSchemaSimpleType");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexType:
		return soap_in_PointerToxsd__XmlSchemaComplexType(soap, NULL, NULL, "xsd:XmlSchemaComplexType");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroup:
		return soap_in_PointerToxsd__XmlSchemaAttributeGroup(soap, NULL, NULL, "xsd:XmlSchemaAttributeGroup");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttribute:
		return soap_in_PointerToxsd__XmlSchemaAttribute(soap, NULL, NULL, "xsd:XmlSchemaAttribute");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnnotation:
		return soap_in_PointerToxsd__XmlSchemaAnnotation(soap, NULL, NULL, "xsd:XmlSchemaAnnotation");
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroup:
		return soap_in_PointerToxsd__XmlSchemaGroup(soap, NULL, NULL, "xsd:XmlSchemaGroup");
	case SOAP_TYPE_PointerToxsd__XmlSchemaNotation:
		return soap_in_PointerToxsd__XmlSchemaNotation(soap, NULL, NULL, "xsd:XmlSchemaNotation");
	case SOAP_TYPE_PointerToxsd__XmlSchemaImport:
		return soap_in_PointerToxsd__XmlSchemaImport(soap, NULL, NULL, "xsd:XmlSchemaImport");
	case SOAP_TYPE_PointerToxsd__XmlSchemaRedefine:
		return soap_in_PointerToxsd__XmlSchemaRedefine(soap, NULL, NULL, "xsd:XmlSchemaRedefine");
	case SOAP_TYPE_PointerToxsd__XmlSchemaInclude:
		return soap_in_PointerToxsd__XmlSchemaInclude(soap, NULL, NULL, "xsd:XmlSchemaInclude");
	case SOAP_TYPE_PointerTons6__UsernameTokenElement:
		return soap_in_PointerTons6__UsernameTokenElement(soap, NULL, NULL, "ns6:UsernameTokenElement");
	case SOAP_TYPE_PointerTons5__HierarchyInfo:
		return soap_in_PointerTons5__HierarchyInfo(soap, NULL, NULL, "ns5:HierarchyInfo");
	case SOAP_TYPE_PointerTons5__AxisInfo:
		return soap_in_PointerTons5__AxisInfo(soap, NULL, NULL, "ns5:AxisInfo");
	case SOAP_TYPE_PointerTons5__Cube:
		return soap_in_PointerTons5__Cube(soap, NULL, NULL, "ns5:Cube");
	case SOAP_TYPE_PointerTons5__CellInfo:
		return soap_in_PointerTons5__CellInfo(soap, NULL, NULL, "ns5:CellInfo");
	case SOAP_TYPE_PointerTons5__AxesInfo:
		return soap_in_PointerTons5__AxesInfo(soap, NULL, NULL, "ns5:AxesInfo");
	case SOAP_TYPE_PointerTons5__CubeInfo:
		return soap_in_PointerTons5__CubeInfo(soap, NULL, NULL, "ns5:CubeInfo");
	case SOAP_TYPE_PointerTons5__Members:
		return soap_in_PointerTons5__Members(soap, NULL, NULL, "ns5:Members");
	case SOAP_TYPE_PointerTons5__Member:
		return soap_in_PointerTons5__Member(soap, NULL, NULL, "ns5:Member");
	case SOAP_TYPE_PointerTons5__Tuple:
		return soap_in_PointerTons5__Tuple(soap, NULL, NULL, "ns5:Tuple");
	case SOAP_TYPE_PointerTons5__CrossProduct:
		return soap_in_PointerTons5__CrossProduct(soap, NULL, NULL, "ns5:CrossProduct");
	case SOAP_TYPE_PointerTons5__Tuples:
		return soap_in_PointerTons5__Tuples(soap, NULL, NULL, "ns5:Tuples");
	case SOAP_TYPE_PointerTons5__Axis:
		return soap_in_PointerTons5__Axis(soap, NULL, NULL, "ns5:Axis");
	case SOAP_TYPE_PointerTons5__Cell:
		return soap_in_PointerTons5__Cell(soap, NULL, NULL, "ns5:Cell");
	case SOAP_TYPE_PointerTons5__OlapInfo:
		return soap_in_PointerTons5__OlapInfo(soap, NULL, NULL, "ns5:OlapInfo");
	case SOAP_TYPE_PointerTons5__Row:
		return soap_in_PointerTons5__Row(soap, NULL, NULL, "ns5:Row");
	case SOAP_TYPE_PointerTons5__Axes:
		return soap_in_PointerTons5__Axes(soap, NULL, NULL, "ns5:Axes");
	case SOAP_TYPE_PointerTons5__CellData:
		return soap_in_PointerTons5__CellData(soap, NULL, NULL, "ns5:CellData");
	case SOAP_TYPE_PointerTons4__HierarchyInfo:
		return soap_in_PointerTons4__HierarchyInfo(soap, NULL, NULL, "ns4:HierarchyInfo");
	case SOAP_TYPE_PointerTons4__AxisInfo:
		return soap_in_PointerTons4__AxisInfo(soap, NULL, NULL, "ns4:AxisInfo");
	case SOAP_TYPE_PointerTons4__Cube:
		return soap_in_PointerTons4__Cube(soap, NULL, NULL, "ns4:Cube");
	case SOAP_TYPE_PointerTons4__CellInfo:
		return soap_in_PointerTons4__CellInfo(soap, NULL, NULL, "ns4:CellInfo");
	case SOAP_TYPE_PointerTons4__AxesInfo:
		return soap_in_PointerTons4__AxesInfo(soap, NULL, NULL, "ns4:AxesInfo");
	case SOAP_TYPE_PointerTons4__CubeInfo:
		return soap_in_PointerTons4__CubeInfo(soap, NULL, NULL, "ns4:CubeInfo");
	case SOAP_TYPE_PointerTons4__Members:
		return soap_in_PointerTons4__Members(soap, NULL, NULL, "ns4:Members");
	case SOAP_TYPE_PointerTons4__Member:
		return soap_in_PointerTons4__Member(soap, NULL, NULL, "ns4:Member");
	case SOAP_TYPE_PointerTons4__Tuple:
		return soap_in_PointerTons4__Tuple(soap, NULL, NULL, "ns4:Tuple");
	case SOAP_TYPE_PointerTons4__CrossProduct:
		return soap_in_PointerTons4__CrossProduct(soap, NULL, NULL, "ns4:CrossProduct");
	case SOAP_TYPE_PointerTons4__Tuples:
		return soap_in_PointerTons4__Tuples(soap, NULL, NULL, "ns4:Tuples");
	case SOAP_TYPE_PointerTons4__Axis:
		return soap_in_PointerTons4__Axis(soap, NULL, NULL, "ns4:Axis");
	case SOAP_TYPE_PointerTons4__Cell:
		return soap_in_PointerTons4__Cell(soap, NULL, NULL, "ns4:Cell");
	case SOAP_TYPE_PointerTons4__OlapInfo:
		return soap_in_PointerTons4__OlapInfo(soap, NULL, NULL, "ns4:OlapInfo");
	case SOAP_TYPE_PointerTons4__Row:
		return soap_in_PointerTons4__Row(soap, NULL, NULL, "ns4:Row");
	case SOAP_TYPE_PointerTons4__Axes:
		return soap_in_PointerTons4__Axes(soap, NULL, NULL, "ns4:Axes");
	case SOAP_TYPE_PointerTons4__CellData:
		return soap_in_PointerTons4__CellData(soap, NULL, NULL, "ns4:CellData");
	case SOAP_TYPE_PointerTons2__HierarchyInfo:
		return soap_in_PointerTons2__HierarchyInfo(soap, NULL, NULL, "ns2:HierarchyInfo");
	case SOAP_TYPE_PointerTons2__AxisInfo:
		return soap_in_PointerTons2__AxisInfo(soap, NULL, NULL, "ns2:AxisInfo");
	case SOAP_TYPE_PointerTons2__Cube:
		return soap_in_PointerTons2__Cube(soap, NULL, NULL, "ns2:Cube");
	case SOAP_TYPE_PointerTons2__CellInfo:
		return soap_in_PointerTons2__CellInfo(soap, NULL, NULL, "ns2:CellInfo");
	case SOAP_TYPE_PointerTons2__AxesInfo:
		return soap_in_PointerTons2__AxesInfo(soap, NULL, NULL, "ns2:AxesInfo");
	case SOAP_TYPE_PointerTons2__CubeInfo:
		return soap_in_PointerTons2__CubeInfo(soap, NULL, NULL, "ns2:CubeInfo");
	case SOAP_TYPE_PointerTons2__Members:
		return soap_in_PointerTons2__Members(soap, NULL, NULL, "ns2:Members");
	case SOAP_TYPE_PointerTons2__Member:
		return soap_in_PointerTons2__Member(soap, NULL, NULL, "ns2:Member");
	case SOAP_TYPE_PointerTons2__Tuple:
		return soap_in_PointerTons2__Tuple(soap, NULL, NULL, "ns2:Tuple");
	case SOAP_TYPE_PointerTons2__CrossProduct:
		return soap_in_PointerTons2__CrossProduct(soap, NULL, NULL, "ns2:CrossProduct");
	case SOAP_TYPE_PointerTons2__Tuples:
		return soap_in_PointerTons2__Tuples(soap, NULL, NULL, "ns2:Tuples");
	case SOAP_TYPE_PointerTons2__Axis:
		return soap_in_PointerTons2__Axis(soap, NULL, NULL, "ns2:Axis");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons2__Cell:
		return soap_in_PointerTons2__Cell(soap, NULL, NULL, "ns2:Cell");
	case SOAP_TYPE_PointerTons2__OlapInfo:
		return soap_in_PointerTons2__OlapInfo(soap, NULL, NULL, "ns2:OlapInfo");
	case SOAP_TYPE_PointerTons2__Axes:
		return soap_in_PointerTons2__Axes(soap, NULL, NULL, "ns2:Axes");
	case SOAP_TYPE_PointerTons2__CellData:
		return soap_in_PointerTons2__CellData(soap, NULL, NULL, "ns2:CellData");
	case SOAP_TYPE_PointerTons1__Restrictions:
		return soap_in_PointerTons1__Restrictions(soap, NULL, NULL, "ns1:Restrictions");
	case SOAP_TYPE_PointerTons1__ResultSet:
		return soap_in_PointerTons1__ResultSet(soap, NULL, NULL, "ns1:ResultSet");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_in_PointerTons1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__Properties:
		return soap_in_PointerTons1__Properties(soap, NULL, NULL, "ns1:Properties");
	case SOAP_TYPE_PointerTons1__CommandStatement:
		return soap_in_PointerTons1__CommandStatement(soap, NULL, NULL, "ns1:CommandStatement");
	case SOAP_TYPE_PointerTons1__RestrictionList:
		return soap_in_PointerTons1__RestrictionList(soap, NULL, NULL, "ns1:RestrictionList");
	case SOAP_TYPE_PointerTons5__ResultXmlRoot:
		return soap_in_PointerTons5__ResultXmlRoot(soap, NULL, NULL, "ns5:ResultXmlRoot");
	case SOAP_TYPE_PointerTons4__ResultXmlRoot:
		return soap_in_PointerTons4__ResultXmlRoot(soap, NULL, NULL, "ns4:ResultXmlRoot");
	case SOAP_TYPE_PointerTons2__ResultXmlRoot:
		return soap_in_PointerTons2__ResultXmlRoot(soap, NULL, NULL, "ns2:ResultXmlRoot");
	case SOAP_TYPE_PointerTons1__PropertyList:
		return soap_in_PointerTons1__PropertyList(soap, NULL, NULL, "ns1:PropertyList");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns6:UsernameTokenElement"))
		{	*type = SOAP_TYPE_ns6__UsernameTokenElement;
			return soap_in_ns6__UsernameTokenElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Security"))
		{	*type = SOAP_TYPE_ns6__Security;
			return soap_in_ns6__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CellInfo"))
		{	*type = SOAP_TYPE_ns5__CellInfo;
			return soap_in_ns5__CellInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:HierarchyInfo"))
		{	*type = SOAP_TYPE_ns5__HierarchyInfo;
			return soap_in_ns5__HierarchyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AxisInfo"))
		{	*type = SOAP_TYPE_ns5__AxisInfo;
			return soap_in_ns5__AxisInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AxesInfo"))
		{	*type = SOAP_TYPE_ns5__AxesInfo;
			return soap_in_ns5__AxesInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Cube"))
		{	*type = SOAP_TYPE_ns5__Cube;
			return soap_in_ns5__Cube(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CubeInfo"))
		{	*type = SOAP_TYPE_ns5__CubeInfo;
			return soap_in_ns5__CubeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:OlapInfo"))
		{	*type = SOAP_TYPE_ns5__OlapInfo;
			return soap_in_ns5__OlapInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Row"))
		{	*type = SOAP_TYPE_ns5__Row;
			return soap_in_ns5__Row(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Members"))
		{	*type = SOAP_TYPE_ns5__Members;
			return soap_in_ns5__Members(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CrossProduct"))
		{	*type = SOAP_TYPE_ns5__CrossProduct;
			return soap_in_ns5__CrossProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Member"))
		{	*type = SOAP_TYPE_ns5__Member;
			return soap_in_ns5__Member(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Tuple"))
		{	*type = SOAP_TYPE_ns5__Tuple;
			return soap_in_ns5__Tuple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Tuples"))
		{	*type = SOAP_TYPE_ns5__Tuples;
			return soap_in_ns5__Tuples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Axis"))
		{	*type = SOAP_TYPE_ns5__Axis;
			return soap_in_ns5__Axis(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Axes"))
		{	*type = SOAP_TYPE_ns5__Axes;
			return soap_in_ns5__Axes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Cell"))
		{	*type = SOAP_TYPE_ns5__Cell;
			return soap_in_ns5__Cell(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CellData"))
		{	*type = SOAP_TYPE_ns5__CellData;
			return soap_in_ns5__CellData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ResultXmlRoot"))
		{	*type = SOAP_TYPE_ns5__ResultXmlRoot;
			return soap_in_ns5__ResultXmlRoot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CellInfo"))
		{	*type = SOAP_TYPE_ns4__CellInfo;
			return soap_in_ns4__CellInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:HierarchyInfo"))
		{	*type = SOAP_TYPE_ns4__HierarchyInfo;
			return soap_in_ns4__HierarchyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AxisInfo"))
		{	*type = SOAP_TYPE_ns4__AxisInfo;
			return soap_in_ns4__AxisInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AxesInfo"))
		{	*type = SOAP_TYPE_ns4__AxesInfo;
			return soap_in_ns4__AxesInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Cube"))
		{	*type = SOAP_TYPE_ns4__Cube;
			return soap_in_ns4__Cube(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CubeInfo"))
		{	*type = SOAP_TYPE_ns4__CubeInfo;
			return soap_in_ns4__CubeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OlapInfo"))
		{	*type = SOAP_TYPE_ns4__OlapInfo;
			return soap_in_ns4__OlapInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Row"))
		{	*type = SOAP_TYPE_ns4__Row;
			return soap_in_ns4__Row(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Members"))
		{	*type = SOAP_TYPE_ns4__Members;
			return soap_in_ns4__Members(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CrossProduct"))
		{	*type = SOAP_TYPE_ns4__CrossProduct;
			return soap_in_ns4__CrossProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Member"))
		{	*type = SOAP_TYPE_ns4__Member;
			return soap_in_ns4__Member(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Tuple"))
		{	*type = SOAP_TYPE_ns4__Tuple;
			return soap_in_ns4__Tuple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Tuples"))
		{	*type = SOAP_TYPE_ns4__Tuples;
			return soap_in_ns4__Tuples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Axis"))
		{	*type = SOAP_TYPE_ns4__Axis;
			return soap_in_ns4__Axis(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Axes"))
		{	*type = SOAP_TYPE_ns4__Axes;
			return soap_in_ns4__Axes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Cell"))
		{	*type = SOAP_TYPE_ns4__Cell;
			return soap_in_ns4__Cell(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CellData"))
		{	*type = SOAP_TYPE_ns4__CellData;
			return soap_in_ns4__CellData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResultXmlRoot"))
		{	*type = SOAP_TYPE_ns4__ResultXmlRoot;
			return soap_in_ns4__ResultXmlRoot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaInclude"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaInclude;
			return soap_in_ns3__XmlSchemaInclude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaRedefine"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaRedefine;
			return soap_in_ns3__XmlSchemaRedefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaImport"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaImport;
			return soap_in_ns3__XmlSchemaImport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaExternal"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaExternal;
			return soap_in_ns3__XmlSchemaExternal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaGroup"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaGroup;
			return soap_in_ns3__XmlSchemaGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleTypeList"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleTypeList;
			return soap_in_ns3__XmlSchemaSimpleTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleTypeRestriction"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction;
			return soap_in_ns3__XmlSchemaSimpleTypeRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleTypeContent"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent;
			return soap_in_ns3__XmlSchemaSimpleTypeContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleTypeUnion"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion;
			return soap_in_ns3__XmlSchemaSimpleTypeUnion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMaxExclusiveFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet;
			return soap_in_ns3__XmlSchemaMaxExclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMinInclusiveFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet;
			return soap_in_ns3__XmlSchemaMinInclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMaxInclusiveFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet;
			return soap_in_ns3__XmlSchemaMaxInclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMinLengthFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMinLengthFacet;
			return soap_in_ns3__XmlSchemaMinLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMaxLengthFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet;
			return soap_in_ns3__XmlSchemaMaxLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaLengthFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaLengthFacet;
			return soap_in_ns3__XmlSchemaLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaTotalDigitsFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet;
			return soap_in_ns3__XmlSchemaTotalDigitsFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaFractionDigitsFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet;
			return soap_in_ns3__XmlSchemaFractionDigitsFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaNumericFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaNumericFacet;
			return soap_in_ns3__XmlSchemaNumericFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaPatternFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaPatternFacet;
			return soap_in_ns3__XmlSchemaPatternFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaEnumerationFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaEnumerationFacet;
			return soap_in_ns3__XmlSchemaEnumerationFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaWhiteSpaceFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet;
			return soap_in_ns3__XmlSchemaWhiteSpaceFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaFacet;
			return soap_in_ns3__XmlSchemaFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaMinExclusiveFacet"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet;
			return soap_in_ns3__XmlSchemaMinExclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleContentRestriction"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction;
			return soap_in_ns3__XmlSchemaSimpleContentRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleContentExtension"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension;
			return soap_in_ns3__XmlSchemaSimpleContentExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAnyAttribute"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAnyAttribute;
			return soap_in_ns3__XmlSchemaAnyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAll"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAll;
			return soap_in_ns3__XmlSchemaAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSequence"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSequence;
			return soap_in_ns3__XmlSchemaSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaChoice"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaChoice;
			return soap_in_ns3__XmlSchemaChoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaGroupBase"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaGroupBase;
			return soap_in_ns3__XmlSchemaGroupBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAny"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAny;
			return soap_in_ns3__XmlSchemaAny(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaKey"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaKey;
			return soap_in_ns3__XmlSchemaKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaKeyref"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaKeyref;
			return soap_in_ns3__XmlSchemaKeyref(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaXPath"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaXPath;
			return soap_in_ns3__XmlSchemaXPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaIdentityConstraint"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaIdentityConstraint;
			return soap_in_ns3__XmlSchemaIdentityConstraint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaUnique"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaUnique;
			return soap_in_ns3__XmlSchemaUnique(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaElement"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaElement;
			return soap_in_ns3__XmlSchemaElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaParticle"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaParticle;
			return soap_in_ns3__XmlSchemaParticle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaGroupRef"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaGroupRef;
			return soap_in_ns3__XmlSchemaGroupRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaComplexContentExtension"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaComplexContentExtension;
			return soap_in_ns3__XmlSchemaComplexContentExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaContent"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaContent;
			return soap_in_ns3__XmlSchemaContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaComplexContentRestriction"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction;
			return soap_in_ns3__XmlSchemaComplexContentRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaComplexContent"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaComplexContent;
			return soap_in_ns3__XmlSchemaComplexContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaContentModel"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaContentModel;
			return soap_in_ns3__XmlSchemaContentModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleContent"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleContent;
			return soap_in_ns3__XmlSchemaSimpleContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaComplexType"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaComplexType;
			return soap_in_ns3__XmlSchemaComplexType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaType"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaType;
			return soap_in_ns3__XmlSchemaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaSimpleType"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaSimpleType;
			return soap_in_ns3__XmlSchemaSimpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAttribute"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAttribute;
			return soap_in_ns3__XmlSchemaAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAttributeGroupRef"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef;
			return soap_in_ns3__XmlSchemaAttributeGroupRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAttributeGroup"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAttributeGroup;
			return soap_in_ns3__XmlSchemaAttributeGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaNotation"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaNotation;
			return soap_in_ns3__XmlSchemaNotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAppInfo"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAppInfo;
			return soap_in_ns3__XmlSchemaAppInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaDocumentation"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaDocumentation;
			return soap_in_ns3__XmlSchemaDocumentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAnnotation"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAnnotation;
			return soap_in_ns3__XmlSchemaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaAnnotated"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaAnnotated;
			return soap_in_ns3__XmlSchemaAnnotated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaObject"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaObject;
			return soap_in_ns3__XmlSchemaObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchema"))
		{	*type = SOAP_TYPE_ns3__XmlSchema;
			return soap_in_ns3__XmlSchema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CellInfo"))
		{	*type = SOAP_TYPE_ns2__CellInfo;
			return soap_in_ns2__CellInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HierarchyInfo"))
		{	*type = SOAP_TYPE_ns2__HierarchyInfo;
			return soap_in_ns2__HierarchyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AxisInfo"))
		{	*type = SOAP_TYPE_ns2__AxisInfo;
			return soap_in_ns2__AxisInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AxesInfo"))
		{	*type = SOAP_TYPE_ns2__AxesInfo;
			return soap_in_ns2__AxesInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Cube"))
		{	*type = SOAP_TYPE_ns2__Cube;
			return soap_in_ns2__Cube(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CubeInfo"))
		{	*type = SOAP_TYPE_ns2__CubeInfo;
			return soap_in_ns2__CubeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OlapInfo"))
		{	*type = SOAP_TYPE_ns2__OlapInfo;
			return soap_in_ns2__OlapInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Row"))
		{	*type = SOAP_TYPE_ns2__Row;
			return soap_in_ns2__Row(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Members"))
		{	*type = SOAP_TYPE_ns2__Members;
			return soap_in_ns2__Members(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CrossProduct"))
		{	*type = SOAP_TYPE_ns2__CrossProduct;
			return soap_in_ns2__CrossProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Member"))
		{	*type = SOAP_TYPE_ns2__Member;
			return soap_in_ns2__Member(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Tuple"))
		{	*type = SOAP_TYPE_ns2__Tuple;
			return soap_in_ns2__Tuple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Tuples"))
		{	*type = SOAP_TYPE_ns2__Tuples;
			return soap_in_ns2__Tuples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Axis"))
		{	*type = SOAP_TYPE_ns2__Axis;
			return soap_in_ns2__Axis(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Axes"))
		{	*type = SOAP_TYPE_ns2__Axes;
			return soap_in_ns2__Axes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Cell"))
		{	*type = SOAP_TYPE_ns2__Cell;
			return soap_in_ns2__Cell(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CellData"))
		{	*type = SOAP_TYPE_ns2__CellData;
			return soap_in_ns2__CellData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResultXmlRoot"))
		{	*type = SOAP_TYPE_ns2__ResultXmlRoot;
			return soap_in_ns2__ResultXmlRoot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RestrictionList"))
		{	*type = SOAP_TYPE_ns1__RestrictionList;
			return soap_in_ns1__RestrictionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Restrictions"))
		{	*type = SOAP_TYPE_ns1__Restrictions;
			return soap_in_ns1__Restrictions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndSession"))
		{	*type = SOAP_TYPE_ns1__EndSession;
			return soap_in_ns1__EndSession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Session"))
		{	*type = SOAP_TYPE_ns1__Session;
			return soap_in_ns1__Session(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginSession"))
		{	*type = SOAP_TYPE_ns1__BeginSession;
			return soap_in_ns1__BeginSession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResultSet"))
		{	*type = SOAP_TYPE_ns1__ResultSet;
			return soap_in_ns1__ResultSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameters"))
		{	*type = SOAP_TYPE_ns1__Parameters;
			return soap_in_ns1__Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PropertyList"))
		{	*type = SOAP_TYPE_ns1__PropertyList;
			return soap_in_ns1__PropertyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Properties"))
		{	*type = SOAP_TYPE_ns1__Properties;
			return soap_in_ns1__Properties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommandStatement"))
		{	*type = SOAP_TYPE_ns1__CommandStatement;
			return soap_in_ns1__CommandStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaXPath"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaXPath;
			return soap_in_xsd__XmlSchemaXPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaWhiteSpaceFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet;
			return soap_in_xsd__XmlSchemaWhiteSpaceFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaUse"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaUse;
			return soap_in_xsd__XmlSchemaUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaUnique"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaUnique;
			return soap_in_xsd__XmlSchemaUnique(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaType"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaType;
			return soap_in_xsd__XmlSchemaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaTotalDigitsFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet;
			return soap_in_xsd__XmlSchemaTotalDigitsFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleTypeUnion"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion;
			return soap_in_xsd__XmlSchemaSimpleTypeUnion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleTypeRestriction"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction;
			return soap_in_xsd__XmlSchemaSimpleTypeRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleTypeList"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleTypeList;
			return soap_in_xsd__XmlSchemaSimpleTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleTypeContent"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent;
			return soap_in_xsd__XmlSchemaSimpleTypeContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleType"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleType;
			return soap_in_xsd__XmlSchemaSimpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleContentRestriction"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction;
			return soap_in_xsd__XmlSchemaSimpleContentRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleContentExtension"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension;
			return soap_in_xsd__XmlSchemaSimpleContentExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSimpleContent"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSimpleContent;
			return soap_in_xsd__XmlSchemaSimpleContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaSequence"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaSequence;
			return soap_in_xsd__XmlSchemaSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaRedefine"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaRedefine;
			return soap_in_xsd__XmlSchemaRedefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaPatternFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaPatternFacet;
			return soap_in_xsd__XmlSchemaPatternFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaParticle"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaParticle;
			return soap_in_xsd__XmlSchemaParticle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaObject"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaObject;
			return soap_in_xsd__XmlSchemaObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaNumericFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaNumericFacet;
			return soap_in_xsd__XmlSchemaNumericFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaNotation"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaNotation;
			return soap_in_xsd__XmlSchemaNotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMinLengthFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMinLengthFacet;
			return soap_in_xsd__XmlSchemaMinLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMinInclusiveFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet;
			return soap_in_xsd__XmlSchemaMinInclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMinExclusiveFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet;
			return soap_in_xsd__XmlSchemaMinExclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMaxLengthFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet;
			return soap_in_xsd__XmlSchemaMaxLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMaxInclusiveFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet;
			return soap_in_xsd__XmlSchemaMaxInclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaMaxExclusiveFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet;
			return soap_in_xsd__XmlSchemaMaxExclusiveFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaLengthFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaLengthFacet;
			return soap_in_xsd__XmlSchemaLengthFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaKeyref"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaKeyref;
			return soap_in_xsd__XmlSchemaKeyref(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaKey"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaKey;
			return soap_in_xsd__XmlSchemaKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaInclude"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaInclude;
			return soap_in_xsd__XmlSchemaInclude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaImport"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaImport;
			return soap_in_xsd__XmlSchemaImport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaIdentityConstraint"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaIdentityConstraint;
			return soap_in_xsd__XmlSchemaIdentityConstraint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaGroupRef"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaGroupRef;
			return soap_in_xsd__XmlSchemaGroupRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaGroupBase"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaGroupBase;
			return soap_in_xsd__XmlSchemaGroupBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaGroup"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaGroup;
			return soap_in_xsd__XmlSchemaGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaFractionDigitsFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet;
			return soap_in_xsd__XmlSchemaFractionDigitsFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaForm"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaForm;
			return soap_in_xsd__XmlSchemaForm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaFacet;
			return soap_in_xsd__XmlSchemaFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaExternal"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaExternal;
			return soap_in_xsd__XmlSchemaExternal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaEnumerationFacet"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaEnumerationFacet;
			return soap_in_xsd__XmlSchemaEnumerationFacet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaElement"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaElement;
			return soap_in_xsd__XmlSchemaElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaDocumentation"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaDocumentation;
			return soap_in_xsd__XmlSchemaDocumentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaDerivationMethod"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaDerivationMethod;
			return soap_in_xsd__XmlSchemaDerivationMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaContentProcessing"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaContentProcessing;
			return soap_in_xsd__XmlSchemaContentProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaContentModel"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaContentModel;
			return soap_in_xsd__XmlSchemaContentModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaContent"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaContent;
			return soap_in_xsd__XmlSchemaContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaComplexType"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaComplexType;
			return soap_in_xsd__XmlSchemaComplexType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaComplexContentRestriction"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction;
			return soap_in_xsd__XmlSchemaComplexContentRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaComplexContentExtension"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaComplexContentExtension;
			return soap_in_xsd__XmlSchemaComplexContentExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaComplexContent"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaComplexContent;
			return soap_in_xsd__XmlSchemaComplexContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaChoice"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaChoice;
			return soap_in_xsd__XmlSchemaChoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAttributeGroupRef"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef;
			return soap_in_xsd__XmlSchemaAttributeGroupRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAttributeGroup"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAttributeGroup;
			return soap_in_xsd__XmlSchemaAttributeGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAttribute"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAttribute;
			return soap_in_xsd__XmlSchemaAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAppInfo"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAppInfo;
			return soap_in_xsd__XmlSchemaAppInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAnyAttribute"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAnyAttribute;
			return soap_in_xsd__XmlSchemaAnyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAny"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAny;
			return soap_in_xsd__XmlSchemaAny(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAnnotation"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAnnotation;
			return soap_in_xsd__XmlSchemaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAnnotated"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAnnotated;
			return soap_in_xsd__XmlSchemaAnnotated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchemaAll"))
		{	*type = SOAP_TYPE_xsd__XmlSchemaAll;
			return soap_in_xsd__XmlSchemaAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:XmlSchema"))
		{	*type = SOAP_TYPE_xsd__XmlSchema;
			return soap_in_xsd__XmlSchema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaUse"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaUse;
			return soap_in_ns3__XmlSchemaUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaContentProcessing"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaContentProcessing;
			return soap_in_ns3__XmlSchemaContentProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaForm"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaForm;
			return soap_in_ns3__XmlSchemaForm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:XmlSchemaDerivationMethod"))
		{	*type = SOAP_TYPE_ns3__XmlSchemaDerivationMethod;
			return soap_in_ns3__XmlSchemaDerivationMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:DiscoverResponse"))
		{	*type = SOAP_TYPE__ns1__DiscoverResponse;
			return soap_in__ns1__DiscoverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Discover"))
		{	*type = SOAP_TYPE__ns1__Discover;
			return soap_in__ns1__Discover(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteResponse;
			return soap_in__ns1__ExecuteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Execute"))
		{	*type = SOAP_TYPE__ns1__Execute;
			return soap_in__ns1__Execute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:schema"))
		{	char **s;
			*type = SOAP_TYPE__xsd__schema;
			s = soap_in__xsd__schema(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns3__XmlSchemaUse:
		return soap_out_ns3__XmlSchemaUse(soap, tag, id, (const enum ns3__XmlSchemaUse *)ptr, "ns3:XmlSchemaUse");
	case SOAP_TYPE_ns3__XmlSchemaContentProcessing:
		return soap_out_ns3__XmlSchemaContentProcessing(soap, tag, id, (const enum ns3__XmlSchemaContentProcessing *)ptr, "ns3:XmlSchemaContentProcessing");
	case SOAP_TYPE_ns3__XmlSchemaForm:
		return soap_out_ns3__XmlSchemaForm(soap, tag, id, (const enum ns3__XmlSchemaForm *)ptr, "ns3:XmlSchemaForm");
	case SOAP_TYPE_ns3__XmlSchemaDerivationMethod:
		return soap_out_ns3__XmlSchemaDerivationMethod(soap, tag, id, (const enum ns3__XmlSchemaDerivationMethod *)ptr, "ns3:XmlSchemaDerivationMethod");
	case SOAP_TYPE_ns6__UsernameTokenElement:
		return ((ns6__UsernameTokenElement *)ptr)->soap_out(soap, tag, id, "ns6:UsernameTokenElement");
	case SOAP_TYPE_ns6__Security:
		return ((ns6__Security *)ptr)->soap_out(soap, tag, id, "ns6:Security");
	case SOAP_TYPE_ns5__CellInfo:
		return ((ns5__CellInfo *)ptr)->soap_out(soap, tag, id, "ns5:CellInfo");
	case SOAP_TYPE_ns5__HierarchyInfo:
		return ((ns5__HierarchyInfo *)ptr)->soap_out(soap, tag, id, "ns5:HierarchyInfo");
	case SOAP_TYPE_ns5__AxisInfo:
		return ((ns5__AxisInfo *)ptr)->soap_out(soap, tag, id, "ns5:AxisInfo");
	case SOAP_TYPE_ns5__AxesInfo:
		return ((ns5__AxesInfo *)ptr)->soap_out(soap, tag, id, "ns5:AxesInfo");
	case SOAP_TYPE_ns5__Cube:
		return ((ns5__Cube *)ptr)->soap_out(soap, tag, id, "ns5:Cube");
	case SOAP_TYPE_ns5__CubeInfo:
		return ((ns5__CubeInfo *)ptr)->soap_out(soap, tag, id, "ns5:CubeInfo");
	case SOAP_TYPE_ns5__OlapInfo:
		return ((ns5__OlapInfo *)ptr)->soap_out(soap, tag, id, "ns5:OlapInfo");
	case SOAP_TYPE_ns5__Row:
		return ((ns5__Row *)ptr)->soap_out(soap, tag, id, "ns5:Row");
	case SOAP_TYPE_ns5__Members:
		return ((ns5__Members *)ptr)->soap_out(soap, tag, id, "ns5:Members");
	case SOAP_TYPE_ns5__CrossProduct:
		return ((ns5__CrossProduct *)ptr)->soap_out(soap, tag, id, "ns5:CrossProduct");
	case SOAP_TYPE_ns5__Member:
		return ((ns5__Member *)ptr)->soap_out(soap, tag, id, "ns5:Member");
	case SOAP_TYPE_ns5__Tuple:
		return ((ns5__Tuple *)ptr)->soap_out(soap, tag, id, "ns5:Tuple");
	case SOAP_TYPE_ns5__Tuples:
		return ((ns5__Tuples *)ptr)->soap_out(soap, tag, id, "ns5:Tuples");
	case SOAP_TYPE_ns5__Axis:
		return ((ns5__Axis *)ptr)->soap_out(soap, tag, id, "ns5:Axis");
	case SOAP_TYPE_ns5__Axes:
		return ((ns5__Axes *)ptr)->soap_out(soap, tag, id, "ns5:Axes");
	case SOAP_TYPE_ns5__Cell:
		return ((ns5__Cell *)ptr)->soap_out(soap, tag, id, "ns5:Cell");
	case SOAP_TYPE_ns5__CellData:
		return ((ns5__CellData *)ptr)->soap_out(soap, tag, id, "ns5:CellData");
	case SOAP_TYPE_ns5__ResultXmlRoot:
		return ((ns5__ResultXmlRoot *)ptr)->soap_out(soap, tag, id, "ns5:ResultXmlRoot");
	case SOAP_TYPE_ns4__CellInfo:
		return ((ns4__CellInfo *)ptr)->soap_out(soap, tag, id, "ns4:CellInfo");
	case SOAP_TYPE_ns4__HierarchyInfo:
		return ((ns4__HierarchyInfo *)ptr)->soap_out(soap, tag, id, "ns4:HierarchyInfo");
	case SOAP_TYPE_ns4__AxisInfo:
		return ((ns4__AxisInfo *)ptr)->soap_out(soap, tag, id, "ns4:AxisInfo");
	case SOAP_TYPE_ns4__AxesInfo:
		return ((ns4__AxesInfo *)ptr)->soap_out(soap, tag, id, "ns4:AxesInfo");
	case SOAP_TYPE_ns4__Cube:
		return ((ns4__Cube *)ptr)->soap_out(soap, tag, id, "ns4:Cube");
	case SOAP_TYPE_ns4__CubeInfo:
		return ((ns4__CubeInfo *)ptr)->soap_out(soap, tag, id, "ns4:CubeInfo");
	case SOAP_TYPE_ns4__OlapInfo:
		return ((ns4__OlapInfo *)ptr)->soap_out(soap, tag, id, "ns4:OlapInfo");
	case SOAP_TYPE_ns4__Row:
		return ((ns4__Row *)ptr)->soap_out(soap, tag, id, "ns4:Row");
	case SOAP_TYPE_ns4__Members:
		return ((ns4__Members *)ptr)->soap_out(soap, tag, id, "ns4:Members");
	case SOAP_TYPE_ns4__CrossProduct:
		return ((ns4__CrossProduct *)ptr)->soap_out(soap, tag, id, "ns4:CrossProduct");
	case SOAP_TYPE_ns4__Member:
		return ((ns4__Member *)ptr)->soap_out(soap, tag, id, "ns4:Member");
	case SOAP_TYPE_ns4__Tuple:
		return ((ns4__Tuple *)ptr)->soap_out(soap, tag, id, "ns4:Tuple");
	case SOAP_TYPE_ns4__Tuples:
		return ((ns4__Tuples *)ptr)->soap_out(soap, tag, id, "ns4:Tuples");
	case SOAP_TYPE_ns4__Axis:
		return ((ns4__Axis *)ptr)->soap_out(soap, tag, id, "ns4:Axis");
	case SOAP_TYPE_ns4__Axes:
		return ((ns4__Axes *)ptr)->soap_out(soap, tag, id, "ns4:Axes");
	case SOAP_TYPE_ns4__Cell:
		return ((ns4__Cell *)ptr)->soap_out(soap, tag, id, "ns4:Cell");
	case SOAP_TYPE_ns4__CellData:
		return ((ns4__CellData *)ptr)->soap_out(soap, tag, id, "ns4:CellData");
	case SOAP_TYPE_ns4__ResultXmlRoot:
		return ((ns4__ResultXmlRoot *)ptr)->soap_out(soap, tag, id, "ns4:ResultXmlRoot");
	case SOAP_TYPE_ns3__XmlSchemaInclude:
		return ((ns3__XmlSchemaInclude *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaInclude");
	case SOAP_TYPE_ns3__XmlSchemaRedefine:
		return ((ns3__XmlSchemaRedefine *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaRedefine");
	case SOAP_TYPE_ns3__XmlSchemaImport:
		return ((ns3__XmlSchemaImport *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaImport");
	case SOAP_TYPE_ns3__XmlSchemaExternal:
		return ((ns3__XmlSchemaExternal *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaExternal");
	case SOAP_TYPE_ns3__XmlSchemaGroup:
		return ((ns3__XmlSchemaGroup *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaGroup");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeList:
		return ((ns3__XmlSchemaSimpleTypeList *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction:
		return ((ns3__XmlSchemaSimpleTypeRestriction *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent:
		return ((ns3__XmlSchemaSimpleTypeContent *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleTypeContent");
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion:
		return ((ns3__XmlSchemaSimpleTypeUnion *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet:
		return ((ns3__XmlSchemaMaxExclusiveFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet:
		return ((ns3__XmlSchemaMinInclusiveFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet:
		return ((ns3__XmlSchemaMaxInclusiveFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinLengthFacet:
		return ((ns3__XmlSchemaMinLengthFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet:
		return ((ns3__XmlSchemaMaxLengthFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaLengthFacet:
		return ((ns3__XmlSchemaLengthFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaLengthFacet");
	case SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet:
		return ((ns3__XmlSchemaTotalDigitsFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet:
		return ((ns3__XmlSchemaFractionDigitsFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_ns3__XmlSchemaNumericFacet:
		return ((ns3__XmlSchemaNumericFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaNumericFacet");
	case SOAP_TYPE_ns3__XmlSchemaPatternFacet:
		return ((ns3__XmlSchemaPatternFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaPatternFacet");
	case SOAP_TYPE_ns3__XmlSchemaEnumerationFacet:
		return ((ns3__XmlSchemaEnumerationFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet:
		return ((ns3__XmlSchemaWhiteSpaceFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_ns3__XmlSchemaFacet:
		return ((ns3__XmlSchemaFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaFacet");
	case SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet:
		return ((ns3__XmlSchemaMinExclusiveFacet *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction:
		return ((ns3__XmlSchemaSimpleContentRestriction *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension:
		return ((ns3__XmlSchemaSimpleContentExtension *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_ns3__XmlSchemaAnyAttribute:
		return ((ns3__XmlSchemaAnyAttribute *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAnyAttribute");
	case SOAP_TYPE_ns3__XmlSchemaAll:
		return ((ns3__XmlSchemaAll *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAll");
	case SOAP_TYPE_ns3__XmlSchemaSequence:
		return ((ns3__XmlSchemaSequence *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSequence");
	case SOAP_TYPE_ns3__XmlSchemaChoice:
		return ((ns3__XmlSchemaChoice *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaChoice");
	case SOAP_TYPE_ns3__XmlSchemaGroupBase:
		return ((ns3__XmlSchemaGroupBase *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaGroupBase");
	case SOAP_TYPE_ns3__XmlSchemaAny:
		return ((ns3__XmlSchemaAny *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAny");
	case SOAP_TYPE_ns3__XmlSchemaKey:
		return ((ns3__XmlSchemaKey *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaKey");
	case SOAP_TYPE_ns3__XmlSchemaKeyref:
		return ((ns3__XmlSchemaKeyref *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaKeyref");
	case SOAP_TYPE_ns3__XmlSchemaXPath:
		return ((ns3__XmlSchemaXPath *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaXPath");
	case SOAP_TYPE_ns3__XmlSchemaIdentityConstraint:
		return ((ns3__XmlSchemaIdentityConstraint *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaIdentityConstraint");
	case SOAP_TYPE_ns3__XmlSchemaUnique:
		return ((ns3__XmlSchemaUnique *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaUnique");
	case SOAP_TYPE_ns3__XmlSchemaElement:
		return ((ns3__XmlSchemaElement *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaElement");
	case SOAP_TYPE_ns3__XmlSchemaParticle:
		return ((ns3__XmlSchemaParticle *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaParticle");
	case SOAP_TYPE_ns3__XmlSchemaGroupRef:
		return ((ns3__XmlSchemaGroupRef *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaGroupRef");
	case SOAP_TYPE_ns3__XmlSchemaComplexContentExtension:
		return ((ns3__XmlSchemaComplexContentExtension *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_ns3__XmlSchemaContent:
		return ((ns3__XmlSchemaContent *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaContent");
	case SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction:
		return ((ns3__XmlSchemaComplexContentRestriction *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_ns3__XmlSchemaComplexContent:
		return ((ns3__XmlSchemaComplexContent *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaComplexContent");
	case SOAP_TYPE_ns3__XmlSchemaContentModel:
		return ((ns3__XmlSchemaContentModel *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaContentModel");
	case SOAP_TYPE_ns3__XmlSchemaSimpleContent:
		return ((ns3__XmlSchemaSimpleContent *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleContent");
	case SOAP_TYPE_ns3__XmlSchemaComplexType:
		return ((ns3__XmlSchemaComplexType *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaComplexType");
	case SOAP_TYPE_ns3__XmlSchemaType:
		return ((ns3__XmlSchemaType *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaType");
	case SOAP_TYPE_ns3__XmlSchemaSimpleType:
		return ((ns3__XmlSchemaSimpleType *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaSimpleType");
	case SOAP_TYPE_ns3__XmlSchemaAttribute:
		return ((ns3__XmlSchemaAttribute *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAttribute");
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef:
		return ((ns3__XmlSchemaAttributeGroupRef *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroup:
		return ((ns3__XmlSchemaAttributeGroup *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAttributeGroup");
	case SOAP_TYPE_ns3__XmlSchemaNotation:
		return ((ns3__XmlSchemaNotation *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaNotation");
	case SOAP_TYPE_ns3__XmlSchemaAppInfo:
		return ((ns3__XmlSchemaAppInfo *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAppInfo");
	case SOAP_TYPE_ns3__XmlSchemaDocumentation:
		return ((ns3__XmlSchemaDocumentation *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaDocumentation");
	case SOAP_TYPE_ns3__XmlSchemaAnnotation:
		return ((ns3__XmlSchemaAnnotation *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAnnotation");
	case SOAP_TYPE_ns3__XmlSchemaAnnotated:
		return ((ns3__XmlSchemaAnnotated *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaAnnotated");
	case SOAP_TYPE_ns3__XmlSchemaObject:
		return ((ns3__XmlSchemaObject *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchemaObject");
	case SOAP_TYPE_ns3__XmlSchema:
		return ((ns3__XmlSchema *)ptr)->soap_out(soap, tag, id, "ns3:XmlSchema");
	case SOAP_TYPE_ns2__CellInfo:
		return ((ns2__CellInfo *)ptr)->soap_out(soap, tag, id, "ns2:CellInfo");
	case SOAP_TYPE_ns2__HierarchyInfo:
		return ((ns2__HierarchyInfo *)ptr)->soap_out(soap, tag, id, "ns2:HierarchyInfo");
	case SOAP_TYPE_ns2__AxisInfo:
		return ((ns2__AxisInfo *)ptr)->soap_out(soap, tag, id, "ns2:AxisInfo");
	case SOAP_TYPE_ns2__AxesInfo:
		return ((ns2__AxesInfo *)ptr)->soap_out(soap, tag, id, "ns2:AxesInfo");
	case SOAP_TYPE_ns2__Cube:
		return ((ns2__Cube *)ptr)->soap_out(soap, tag, id, "ns2:Cube");
	case SOAP_TYPE_ns2__CubeInfo:
		return ((ns2__CubeInfo *)ptr)->soap_out(soap, tag, id, "ns2:CubeInfo");
	case SOAP_TYPE_ns2__OlapInfo:
		return ((ns2__OlapInfo *)ptr)->soap_out(soap, tag, id, "ns2:OlapInfo");
	case SOAP_TYPE_ns2__Row:
		return ((ns2__Row *)ptr)->soap_out(soap, tag, id, "ns2:Row");
	case SOAP_TYPE_ns2__Members:
		return ((ns2__Members *)ptr)->soap_out(soap, tag, id, "ns2:Members");
	case SOAP_TYPE_ns2__CrossProduct:
		return ((ns2__CrossProduct *)ptr)->soap_out(soap, tag, id, "ns2:CrossProduct");
	case SOAP_TYPE_ns2__Member:
		return ((ns2__Member *)ptr)->soap_out(soap, tag, id, "ns2:Member");
	case SOAP_TYPE_ns2__Tuple:
		return ((ns2__Tuple *)ptr)->soap_out(soap, tag, id, "ns2:Tuple");
	case SOAP_TYPE_ns2__Tuples:
		return ((ns2__Tuples *)ptr)->soap_out(soap, tag, id, "ns2:Tuples");
	case SOAP_TYPE_ns2__Axis:
		return ((ns2__Axis *)ptr)->soap_out(soap, tag, id, "ns2:Axis");
	case SOAP_TYPE_ns2__Axes:
		return ((ns2__Axes *)ptr)->soap_out(soap, tag, id, "ns2:Axes");
	case SOAP_TYPE_ns2__Cell:
		return ((ns2__Cell *)ptr)->soap_out(soap, tag, id, "ns2:Cell");
	case SOAP_TYPE_ns2__CellData:
		return ((ns2__CellData *)ptr)->soap_out(soap, tag, id, "ns2:CellData");
	case SOAP_TYPE_ns2__ResultXmlRoot:
		return ((ns2__ResultXmlRoot *)ptr)->soap_out(soap, tag, id, "ns2:ResultXmlRoot");
	case SOAP_TYPE__ns1__DiscoverResponse:
		return ((_ns1__DiscoverResponse *)ptr)->soap_out(soap, "ns1:DiscoverResponse", id, NULL);
	case SOAP_TYPE__ns1__Discover:
		return ((_ns1__Discover *)ptr)->soap_out(soap, "ns1:Discover", id, NULL);
	case SOAP_TYPE__ns1__ExecuteResponse:
		return ((_ns1__ExecuteResponse *)ptr)->soap_out(soap, "ns1:ExecuteResponse", id, NULL);
	case SOAP_TYPE__ns1__Execute:
		return ((_ns1__Execute *)ptr)->soap_out(soap, "ns1:Execute", id, NULL);
	case SOAP_TYPE_ns1__RestrictionList:
		return ((ns1__RestrictionList *)ptr)->soap_out(soap, tag, id, "ns1:RestrictionList");
	case SOAP_TYPE_ns1__Restrictions:
		return ((ns1__Restrictions *)ptr)->soap_out(soap, tag, id, "ns1:Restrictions");
	case SOAP_TYPE_ns1__EndSession:
		return ((ns1__EndSession *)ptr)->soap_out(soap, tag, id, "ns1:EndSession");
	case SOAP_TYPE_ns1__Session:
		return ((ns1__Session *)ptr)->soap_out(soap, tag, id, "ns1:Session");
	case SOAP_TYPE_ns1__BeginSession:
		return ((ns1__BeginSession *)ptr)->soap_out(soap, tag, id, "ns1:BeginSession");
	case SOAP_TYPE_ns1__ResultSet:
		return ((ns1__ResultSet *)ptr)->soap_out(soap, tag, id, "ns1:ResultSet");
	case SOAP_TYPE_ns1__Parameters:
		return ((ns1__Parameters *)ptr)->soap_out(soap, tag, id, "ns1:Parameters");
	case SOAP_TYPE_ns1__PropertyList:
		return ((ns1__PropertyList *)ptr)->soap_out(soap, tag, id, "ns1:PropertyList");
	case SOAP_TYPE_ns1__Properties:
		return ((ns1__Properties *)ptr)->soap_out(soap, tag, id, "ns1:Properties");
	case SOAP_TYPE_ns1__CommandStatement:
		return ((ns1__CommandStatement *)ptr)->soap_out(soap, tag, id, "ns1:CommandStatement");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__XmlSchemaXPath:
		return soap_out_xsd__XmlSchemaXPath(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaXPath");
	case SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet:
		return soap_out_xsd__XmlSchemaWhiteSpaceFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_xsd__XmlSchemaUse:
		return soap_out_xsd__XmlSchemaUse(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaUse");
	case SOAP_TYPE_xsd__XmlSchemaUnique:
		return soap_out_xsd__XmlSchemaUnique(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaUnique");
	case SOAP_TYPE_xsd__XmlSchemaType:
		return soap_out_xsd__XmlSchemaType(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaType");
	case SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet:
		return soap_out_xsd__XmlSchemaTotalDigitsFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion:
		return soap_out_xsd__XmlSchemaSimpleTypeUnion(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction:
		return soap_out_xsd__XmlSchemaSimpleTypeRestriction(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeList:
		return soap_out_xsd__XmlSchemaSimpleTypeList(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent:
		return soap_out_xsd__XmlSchemaSimpleTypeContent(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleTypeContent");
	case SOAP_TYPE_xsd__XmlSchemaSimpleType:
		return soap_out_xsd__XmlSchemaSimpleType(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleType");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction:
		return soap_out_xsd__XmlSchemaSimpleContentRestriction(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension:
		return soap_out_xsd__XmlSchemaSimpleContentExtension(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_xsd__XmlSchemaSimpleContent:
		return soap_out_xsd__XmlSchemaSimpleContent(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSimpleContent");
	case SOAP_TYPE_xsd__XmlSchemaSequence:
		return soap_out_xsd__XmlSchemaSequence(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaSequence");
	case SOAP_TYPE_xsd__XmlSchemaRedefine:
		return soap_out_xsd__XmlSchemaRedefine(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaRedefine");
	case SOAP_TYPE_xsd__XmlSchemaPatternFacet:
		return soap_out_xsd__XmlSchemaPatternFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaPatternFacet");
	case SOAP_TYPE_xsd__XmlSchemaParticle:
		return soap_out_xsd__XmlSchemaParticle(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaParticle");
	case SOAP_TYPE_xsd__XmlSchemaObject:
		return soap_out_xsd__XmlSchemaObject(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaObject");
	case SOAP_TYPE_xsd__XmlSchemaNumericFacet:
		return soap_out_xsd__XmlSchemaNumericFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaNumericFacet");
	case SOAP_TYPE_xsd__XmlSchemaNotation:
		return soap_out_xsd__XmlSchemaNotation(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaNotation");
	case SOAP_TYPE_xsd__XmlSchemaMinLengthFacet:
		return soap_out_xsd__XmlSchemaMinLengthFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet:
		return soap_out_xsd__XmlSchemaMinInclusiveFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet:
		return soap_out_xsd__XmlSchemaMinExclusiveFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet:
		return soap_out_xsd__XmlSchemaMaxLengthFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet:
		return soap_out_xsd__XmlSchemaMaxInclusiveFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet:
		return soap_out_xsd__XmlSchemaMaxExclusiveFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_xsd__XmlSchemaLengthFacet:
		return soap_out_xsd__XmlSchemaLengthFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaLengthFacet");
	case SOAP_TYPE_xsd__XmlSchemaKeyref:
		return soap_out_xsd__XmlSchemaKeyref(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaKeyref");
	case SOAP_TYPE_xsd__XmlSchemaKey:
		return soap_out_xsd__XmlSchemaKey(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaKey");
	case SOAP_TYPE_xsd__XmlSchemaInclude:
		return soap_out_xsd__XmlSchemaInclude(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaInclude");
	case SOAP_TYPE_xsd__XmlSchemaImport:
		return soap_out_xsd__XmlSchemaImport(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaImport");
	case SOAP_TYPE_xsd__XmlSchemaIdentityConstraint:
		return soap_out_xsd__XmlSchemaIdentityConstraint(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaIdentityConstraint");
	case SOAP_TYPE_xsd__XmlSchemaGroupRef:
		return soap_out_xsd__XmlSchemaGroupRef(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaGroupRef");
	case SOAP_TYPE_xsd__XmlSchemaGroupBase:
		return soap_out_xsd__XmlSchemaGroupBase(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaGroupBase");
	case SOAP_TYPE_xsd__XmlSchemaGroup:
		return soap_out_xsd__XmlSchemaGroup(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaGroup");
	case SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet:
		return soap_out_xsd__XmlSchemaFractionDigitsFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_xsd__XmlSchemaForm:
		return soap_out_xsd__XmlSchemaForm(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaForm");
	case SOAP_TYPE_xsd__XmlSchemaFacet:
		return soap_out_xsd__XmlSchemaFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaFacet");
	case SOAP_TYPE_xsd__XmlSchemaExternal:
		return soap_out_xsd__XmlSchemaExternal(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaExternal");
	case SOAP_TYPE_xsd__XmlSchemaEnumerationFacet:
		return soap_out_xsd__XmlSchemaEnumerationFacet(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_xsd__XmlSchemaElement:
		return soap_out_xsd__XmlSchemaElement(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaElement");
	case SOAP_TYPE_xsd__XmlSchemaDocumentation:
		return soap_out_xsd__XmlSchemaDocumentation(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaDocumentation");
	case SOAP_TYPE_xsd__XmlSchemaDerivationMethod:
		return soap_out_xsd__XmlSchemaDerivationMethod(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaDerivationMethod");
	case SOAP_TYPE_xsd__XmlSchemaContentProcessing:
		return soap_out_xsd__XmlSchemaContentProcessing(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaContentProcessing");
	case SOAP_TYPE_xsd__XmlSchemaContentModel:
		return soap_out_xsd__XmlSchemaContentModel(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaContentModel");
	case SOAP_TYPE_xsd__XmlSchemaContent:
		return soap_out_xsd__XmlSchemaContent(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaContent");
	case SOAP_TYPE_xsd__XmlSchemaComplexType:
		return soap_out_xsd__XmlSchemaComplexType(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaComplexType");
	case SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction:
		return soap_out_xsd__XmlSchemaComplexContentRestriction(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_xsd__XmlSchemaComplexContentExtension:
		return soap_out_xsd__XmlSchemaComplexContentExtension(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_xsd__XmlSchemaComplexContent:
		return soap_out_xsd__XmlSchemaComplexContent(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaComplexContent");
	case SOAP_TYPE_xsd__XmlSchemaChoice:
		return soap_out_xsd__XmlSchemaChoice(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaChoice");
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef:
		return soap_out_xsd__XmlSchemaAttributeGroupRef(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroup:
		return soap_out_xsd__XmlSchemaAttributeGroup(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAttributeGroup");
	case SOAP_TYPE_xsd__XmlSchemaAttribute:
		return soap_out_xsd__XmlSchemaAttribute(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAttribute");
	case SOAP_TYPE_xsd__XmlSchemaAppInfo:
		return soap_out_xsd__XmlSchemaAppInfo(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAppInfo");
	case SOAP_TYPE_xsd__XmlSchemaAnyAttribute:
		return soap_out_xsd__XmlSchemaAnyAttribute(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAnyAttribute");
	case SOAP_TYPE_xsd__XmlSchemaAny:
		return soap_out_xsd__XmlSchemaAny(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAny");
	case SOAP_TYPE_xsd__XmlSchemaAnnotation:
		return soap_out_xsd__XmlSchemaAnnotation(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAnnotation");
	case SOAP_TYPE_xsd__XmlSchemaAnnotated:
		return soap_out_xsd__XmlSchemaAnnotated(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAnnotated");
	case SOAP_TYPE_xsd__XmlSchemaAll:
		return soap_out_xsd__XmlSchemaAll(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchemaAll");
	case SOAP_TYPE_xsd__XmlSchema:
		return soap_out_xsd__XmlSchema(soap, tag, id, (const std::string *)ptr, "xsd:XmlSchema");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__DiscoverResponse:
		return soap_out_PointerTo_ns1__DiscoverResponse(soap, tag, id, (_ns1__DiscoverResponse *const*)ptr, "ns1:DiscoverResponse");
	case SOAP_TYPE_PointerTo_ns1__Discover:
		return soap_out_PointerTo_ns1__Discover(soap, tag, id, (_ns1__Discover *const*)ptr, "ns1:Discover");
	case SOAP_TYPE_PointerTo_ns1__ExecuteResponse:
		return soap_out_PointerTo_ns1__ExecuteResponse(soap, tag, id, (_ns1__ExecuteResponse *const*)ptr, "ns1:ExecuteResponse");
	case SOAP_TYPE_PointerTo_ns1__Execute:
		return soap_out_PointerTo_ns1__Execute(soap, tag, id, (_ns1__Execute *const*)ptr, "ns1:Execute");
	case SOAP_TYPE_PointerTons6__Security:
		return soap_out_PointerTons6__Security(soap, tag, id, (ns6__Security *const*)ptr, "ns6:Security");
	case SOAP_TYPE_PointerTons1__Session:
		return soap_out_PointerTons1__Session(soap, tag, id, (ns1__Session *const*)ptr, "ns1:Session");
	case SOAP_TYPE_PointerTons1__EndSession:
		return soap_out_PointerTons1__EndSession(soap, tag, id, (ns1__EndSession *const*)ptr, "ns1:EndSession");
	case SOAP_TYPE_PointerTons1__BeginSession:
		return soap_out_PointerTons1__BeginSession(soap, tag, id, (ns1__BeginSession *const*)ptr, "ns1:BeginSession");
	case SOAP_TYPE_PointerToxsd__XmlSchemaFractionDigitsFacet:
		return soap_out_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaFractionDigitsFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaTotalDigitsFacet:
		return soap_out_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaTotalDigitsFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaWhiteSpaceFacet:
		return soap_out_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaWhiteSpaceFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinInclusiveFacet:
		return soap_out_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMinInclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxExclusiveFacet:
		return soap_out_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMaxExclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaPatternFacet:
		return soap_out_PointerToxsd__XmlSchemaPatternFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaPatternFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxLengthFacet:
		return soap_out_PointerToxsd__XmlSchemaMaxLengthFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMaxLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinLengthFacet:
		return soap_out_PointerToxsd__XmlSchemaMinLengthFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMinLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaLengthFacet:
		return soap_out_PointerToxsd__XmlSchemaLengthFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaLengthFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxInclusiveFacet:
		return soap_out_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMaxInclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaEnumerationFacet:
		return soap_out_PointerToxsd__XmlSchemaEnumerationFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaEnumerationFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinExclusiveFacet:
		return soap_out_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaMinExclusiveFacet");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAny:
		return soap_out_PointerToxsd__XmlSchemaAny(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAny");
	case SOAP_TYPE_PointerToxsd__XmlSchemaContentProcessing:
		return soap_out_PointerToxsd__XmlSchemaContentProcessing(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaContentProcessing");
	case SOAP_TYPE_PointerToxsd__XmlSchemaXPath:
		return soap_out_PointerToxsd__XmlSchemaXPath(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaXPath");
	case SOAP_TYPE_PointerToxsd__XmlSchemaKeyref:
		return soap_out_PointerToxsd__XmlSchemaKeyref(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaKeyref");
	case SOAP_TYPE_PointerToxsd__XmlSchemaKey:
		return soap_out_PointerToxsd__XmlSchemaKey(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaKey");
	case SOAP_TYPE_PointerToxsd__XmlSchemaUnique:
		return soap_out_PointerToxsd__XmlSchemaUnique(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaUnique");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentExtension:
		return soap_out_PointerToxsd__XmlSchemaComplexContentExtension(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaComplexContentExtension");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentRestriction:
		return soap_out_PointerToxsd__XmlSchemaComplexContentRestriction(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaComplexContentRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentExtension:
		return soap_out_PointerToxsd__XmlSchemaSimpleContentExtension(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleContentExtension");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentRestriction:
		return soap_out_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleContentRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAll:
		return soap_out_PointerToxsd__XmlSchemaAll(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAll");
	case SOAP_TYPE_PointerToxsd__XmlSchemaChoice:
		return soap_out_PointerToxsd__XmlSchemaChoice(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaChoice");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSequence:
		return soap_out_PointerToxsd__XmlSchemaSequence(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSequence");
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroupRef:
		return soap_out_PointerToxsd__XmlSchemaGroupRef(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaGroupRef");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContent:
		return soap_out_PointerToxsd__XmlSchemaComplexContent(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaComplexContent");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContent:
		return soap_out_PointerToxsd__XmlSchemaSimpleContent(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleContent");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeRestriction:
		return soap_out_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleTypeRestriction");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeList:
		return soap_out_PointerToxsd__XmlSchemaSimpleTypeList(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleTypeList");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeUnion:
		return soap_out_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleTypeUnion");
	case SOAP_TYPE_PointerToxsd__XmlSchemaUse:
		return soap_out_PointerToxsd__XmlSchemaUse(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaUse");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnyAttribute:
		return soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAnyAttribute");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroupRef:
		return soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAttributeGroupRef");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::string *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAppInfo:
		return soap_out_PointerToxsd__XmlSchemaAppInfo(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAppInfo");
	case SOAP_TYPE_PointerToxsd__XmlSchemaDocumentation:
		return soap_out_PointerToxsd__XmlSchemaDocumentation(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaDocumentation");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_out_PointerToxsd__token(soap, tag, id, (std::string *const*)ptr, "xsd:token");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerToxsd__XmlSchemaDerivationMethod:
		return soap_out_PointerToxsd__XmlSchemaDerivationMethod(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaDerivationMethod");
	case SOAP_TYPE_PointerToxsd__XmlSchemaForm:
		return soap_out_PointerToxsd__XmlSchemaForm(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaForm");
	case SOAP_TYPE_PointerToxsd__XmlSchemaElement:
		return soap_out_PointerToxsd__XmlSchemaElement(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaElement");
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleType:
		return soap_out_PointerToxsd__XmlSchemaSimpleType(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaSimpleType");
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexType:
		return soap_out_PointerToxsd__XmlSchemaComplexType(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaComplexType");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroup:
		return soap_out_PointerToxsd__XmlSchemaAttributeGroup(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAttributeGroup");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttribute:
		return soap_out_PointerToxsd__XmlSchemaAttribute(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAttribute");
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnnotation:
		return soap_out_PointerToxsd__XmlSchemaAnnotation(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaAnnotation");
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroup:
		return soap_out_PointerToxsd__XmlSchemaGroup(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaGroup");
	case SOAP_TYPE_PointerToxsd__XmlSchemaNotation:
		return soap_out_PointerToxsd__XmlSchemaNotation(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaNotation");
	case SOAP_TYPE_PointerToxsd__XmlSchemaImport:
		return soap_out_PointerToxsd__XmlSchemaImport(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaImport");
	case SOAP_TYPE_PointerToxsd__XmlSchemaRedefine:
		return soap_out_PointerToxsd__XmlSchemaRedefine(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaRedefine");
	case SOAP_TYPE_PointerToxsd__XmlSchemaInclude:
		return soap_out_PointerToxsd__XmlSchemaInclude(soap, tag, id, (std::string *const*)ptr, "xsd:XmlSchemaInclude");
	case SOAP_TYPE_PointerTons6__UsernameTokenElement:
		return soap_out_PointerTons6__UsernameTokenElement(soap, tag, id, (ns6__UsernameTokenElement *const*)ptr, "ns6:UsernameTokenElement");
	case SOAP_TYPE_PointerTons5__HierarchyInfo:
		return soap_out_PointerTons5__HierarchyInfo(soap, tag, id, (ns5__HierarchyInfo *const*)ptr, "ns5:HierarchyInfo");
	case SOAP_TYPE_PointerTons5__AxisInfo:
		return soap_out_PointerTons5__AxisInfo(soap, tag, id, (ns5__AxisInfo *const*)ptr, "ns5:AxisInfo");
	case SOAP_TYPE_PointerTons5__Cube:
		return soap_out_PointerTons5__Cube(soap, tag, id, (ns5__Cube *const*)ptr, "ns5:Cube");
	case SOAP_TYPE_PointerTons5__CellInfo:
		return soap_out_PointerTons5__CellInfo(soap, tag, id, (ns5__CellInfo *const*)ptr, "ns5:CellInfo");
	case SOAP_TYPE_PointerTons5__AxesInfo:
		return soap_out_PointerTons5__AxesInfo(soap, tag, id, (ns5__AxesInfo *const*)ptr, "ns5:AxesInfo");
	case SOAP_TYPE_PointerTons5__CubeInfo:
		return soap_out_PointerTons5__CubeInfo(soap, tag, id, (ns5__CubeInfo *const*)ptr, "ns5:CubeInfo");
	case SOAP_TYPE_PointerTons5__Members:
		return soap_out_PointerTons5__Members(soap, tag, id, (ns5__Members *const*)ptr, "ns5:Members");
	case SOAP_TYPE_PointerTons5__Member:
		return soap_out_PointerTons5__Member(soap, tag, id, (ns5__Member *const*)ptr, "ns5:Member");
	case SOAP_TYPE_PointerTons5__Tuple:
		return soap_out_PointerTons5__Tuple(soap, tag, id, (ns5__Tuple *const*)ptr, "ns5:Tuple");
	case SOAP_TYPE_PointerTons5__CrossProduct:
		return soap_out_PointerTons5__CrossProduct(soap, tag, id, (ns5__CrossProduct *const*)ptr, "ns5:CrossProduct");
	case SOAP_TYPE_PointerTons5__Tuples:
		return soap_out_PointerTons5__Tuples(soap, tag, id, (ns5__Tuples *const*)ptr, "ns5:Tuples");
	case SOAP_TYPE_PointerTons5__Axis:
		return soap_out_PointerTons5__Axis(soap, tag, id, (ns5__Axis *const*)ptr, "ns5:Axis");
	case SOAP_TYPE_PointerTons5__Cell:
		return soap_out_PointerTons5__Cell(soap, tag, id, (ns5__Cell *const*)ptr, "ns5:Cell");
	case SOAP_TYPE_PointerTons5__OlapInfo:
		return soap_out_PointerTons5__OlapInfo(soap, tag, id, (ns5__OlapInfo *const*)ptr, "ns5:OlapInfo");
	case SOAP_TYPE_PointerTons5__Row:
		return soap_out_PointerTons5__Row(soap, tag, id, (ns5__Row *const*)ptr, "ns5:Row");
	case SOAP_TYPE_PointerTons5__Axes:
		return soap_out_PointerTons5__Axes(soap, tag, id, (ns5__Axes *const*)ptr, "ns5:Axes");
	case SOAP_TYPE_PointerTons5__CellData:
		return soap_out_PointerTons5__CellData(soap, tag, id, (ns5__CellData *const*)ptr, "ns5:CellData");
	case SOAP_TYPE_PointerTons4__HierarchyInfo:
		return soap_out_PointerTons4__HierarchyInfo(soap, tag, id, (ns4__HierarchyInfo *const*)ptr, "ns4:HierarchyInfo");
	case SOAP_TYPE_PointerTons4__AxisInfo:
		return soap_out_PointerTons4__AxisInfo(soap, tag, id, (ns4__AxisInfo *const*)ptr, "ns4:AxisInfo");
	case SOAP_TYPE_PointerTons4__Cube:
		return soap_out_PointerTons4__Cube(soap, tag, id, (ns4__Cube *const*)ptr, "ns4:Cube");
	case SOAP_TYPE_PointerTons4__CellInfo:
		return soap_out_PointerTons4__CellInfo(soap, tag, id, (ns4__CellInfo *const*)ptr, "ns4:CellInfo");
	case SOAP_TYPE_PointerTons4__AxesInfo:
		return soap_out_PointerTons4__AxesInfo(soap, tag, id, (ns4__AxesInfo *const*)ptr, "ns4:AxesInfo");
	case SOAP_TYPE_PointerTons4__CubeInfo:
		return soap_out_PointerTons4__CubeInfo(soap, tag, id, (ns4__CubeInfo *const*)ptr, "ns4:CubeInfo");
	case SOAP_TYPE_PointerTons4__Members:
		return soap_out_PointerTons4__Members(soap, tag, id, (ns4__Members *const*)ptr, "ns4:Members");
	case SOAP_TYPE_PointerTons4__Member:
		return soap_out_PointerTons4__Member(soap, tag, id, (ns4__Member *const*)ptr, "ns4:Member");
	case SOAP_TYPE_PointerTons4__Tuple:
		return soap_out_PointerTons4__Tuple(soap, tag, id, (ns4__Tuple *const*)ptr, "ns4:Tuple");
	case SOAP_TYPE_PointerTons4__CrossProduct:
		return soap_out_PointerTons4__CrossProduct(soap, tag, id, (ns4__CrossProduct *const*)ptr, "ns4:CrossProduct");
	case SOAP_TYPE_PointerTons4__Tuples:
		return soap_out_PointerTons4__Tuples(soap, tag, id, (ns4__Tuples *const*)ptr, "ns4:Tuples");
	case SOAP_TYPE_PointerTons4__Axis:
		return soap_out_PointerTons4__Axis(soap, tag, id, (ns4__Axis *const*)ptr, "ns4:Axis");
	case SOAP_TYPE_PointerTons4__Cell:
		return soap_out_PointerTons4__Cell(soap, tag, id, (ns4__Cell *const*)ptr, "ns4:Cell");
	case SOAP_TYPE_PointerTons4__OlapInfo:
		return soap_out_PointerTons4__OlapInfo(soap, tag, id, (ns4__OlapInfo *const*)ptr, "ns4:OlapInfo");
	case SOAP_TYPE_PointerTons4__Row:
		return soap_out_PointerTons4__Row(soap, tag, id, (ns4__Row *const*)ptr, "ns4:Row");
	case SOAP_TYPE_PointerTons4__Axes:
		return soap_out_PointerTons4__Axes(soap, tag, id, (ns4__Axes *const*)ptr, "ns4:Axes");
	case SOAP_TYPE_PointerTons4__CellData:
		return soap_out_PointerTons4__CellData(soap, tag, id, (ns4__CellData *const*)ptr, "ns4:CellData");
	case SOAP_TYPE_PointerTons2__HierarchyInfo:
		return soap_out_PointerTons2__HierarchyInfo(soap, tag, id, (ns2__HierarchyInfo *const*)ptr, "ns2:HierarchyInfo");
	case SOAP_TYPE_PointerTons2__AxisInfo:
		return soap_out_PointerTons2__AxisInfo(soap, tag, id, (ns2__AxisInfo *const*)ptr, "ns2:AxisInfo");
	case SOAP_TYPE_PointerTons2__Cube:
		return soap_out_PointerTons2__Cube(soap, tag, id, (ns2__Cube *const*)ptr, "ns2:Cube");
	case SOAP_TYPE_PointerTons2__CellInfo:
		return soap_out_PointerTons2__CellInfo(soap, tag, id, (ns2__CellInfo *const*)ptr, "ns2:CellInfo");
	case SOAP_TYPE_PointerTons2__AxesInfo:
		return soap_out_PointerTons2__AxesInfo(soap, tag, id, (ns2__AxesInfo *const*)ptr, "ns2:AxesInfo");
	case SOAP_TYPE_PointerTons2__CubeInfo:
		return soap_out_PointerTons2__CubeInfo(soap, tag, id, (ns2__CubeInfo *const*)ptr, "ns2:CubeInfo");
	case SOAP_TYPE_PointerTons2__Members:
		return soap_out_PointerTons2__Members(soap, tag, id, (ns2__Members *const*)ptr, "ns2:Members");
	case SOAP_TYPE_PointerTons2__Member:
		return soap_out_PointerTons2__Member(soap, tag, id, (ns2__Member *const*)ptr, "ns2:Member");
	case SOAP_TYPE_PointerTons2__Tuple:
		return soap_out_PointerTons2__Tuple(soap, tag, id, (ns2__Tuple *const*)ptr, "ns2:Tuple");
	case SOAP_TYPE_PointerTons2__CrossProduct:
		return soap_out_PointerTons2__CrossProduct(soap, tag, id, (ns2__CrossProduct *const*)ptr, "ns2:CrossProduct");
	case SOAP_TYPE_PointerTons2__Tuples:
		return soap_out_PointerTons2__Tuples(soap, tag, id, (ns2__Tuples *const*)ptr, "ns2:Tuples");
	case SOAP_TYPE_PointerTons2__Axis:
		return soap_out_PointerTons2__Axis(soap, tag, id, (ns2__Axis *const*)ptr, "ns2:Axis");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons2__Cell:
		return soap_out_PointerTons2__Cell(soap, tag, id, (ns2__Cell *const*)ptr, "ns2:Cell");
	case SOAP_TYPE_PointerTons2__OlapInfo:
		return soap_out_PointerTons2__OlapInfo(soap, tag, id, (ns2__OlapInfo *const*)ptr, "ns2:OlapInfo");
	case SOAP_TYPE_PointerTons2__Axes:
		return soap_out_PointerTons2__Axes(soap, tag, id, (ns2__Axes *const*)ptr, "ns2:Axes");
	case SOAP_TYPE_PointerTons2__CellData:
		return soap_out_PointerTons2__CellData(soap, tag, id, (ns2__CellData *const*)ptr, "ns2:CellData");
	case SOAP_TYPE_PointerTons1__Restrictions:
		return soap_out_PointerTons1__Restrictions(soap, tag, id, (ns1__Restrictions *const*)ptr, "ns1:Restrictions");
	case SOAP_TYPE_PointerTons1__ResultSet:
		return soap_out_PointerTons1__ResultSet(soap, tag, id, (ns1__ResultSet *const*)ptr, "ns1:ResultSet");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_out_PointerTons1__Parameters(soap, tag, id, (ns1__Parameters *const*)ptr, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__Properties:
		return soap_out_PointerTons1__Properties(soap, tag, id, (ns1__Properties *const*)ptr, "ns1:Properties");
	case SOAP_TYPE_PointerTons1__CommandStatement:
		return soap_out_PointerTons1__CommandStatement(soap, tag, id, (ns1__CommandStatement *const*)ptr, "ns1:CommandStatement");
	case SOAP_TYPE_PointerTons1__RestrictionList:
		return soap_out_PointerTons1__RestrictionList(soap, tag, id, (ns1__RestrictionList *const*)ptr, "ns1:RestrictionList");
	case SOAP_TYPE_PointerTons5__ResultXmlRoot:
		return soap_out_PointerTons5__ResultXmlRoot(soap, tag, id, (ns5__ResultXmlRoot *const*)ptr, "ns5:ResultXmlRoot");
	case SOAP_TYPE_PointerTons4__ResultXmlRoot:
		return soap_out_PointerTons4__ResultXmlRoot(soap, tag, id, (ns4__ResultXmlRoot *const*)ptr, "ns4:ResultXmlRoot");
	case SOAP_TYPE_PointerTons2__ResultXmlRoot:
		return soap_out_PointerTons2__ResultXmlRoot(soap, tag, id, (ns2__ResultXmlRoot *const*)ptr, "ns2:ResultXmlRoot");
	case SOAP_TYPE_PointerTons1__PropertyList:
		return soap_out_PointerTons1__PropertyList(soap, tag, id, (ns1__PropertyList *const*)ptr, "ns1:PropertyList");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__xsd__schema:
		return soap_out_string(soap, "xsd:schema", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns3__union_XmlSchemaRedefine:
		((__ns3__union_XmlSchemaRedefine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction:
		((__ns3__union_XmlSchemaSimpleTypeRestriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_:
		((__ns3__union_XmlSchemaSimpleContentRestriction_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction:
		((__ns3__union_XmlSchemaSimpleContentRestriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension:
		((__ns3__union_XmlSchemaSimpleContentExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSequence:
		((__ns3__union_XmlSchemaSequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaChoice:
		((__ns3__union_XmlSchemaChoice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaElement_:
		((__ns3__union_XmlSchemaElement_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_:
		((__ns3__union_XmlSchemaComplexContentExtension_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_:
		((__ns3__union_XmlSchemaComplexContentRestriction_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexType__:
		((__ns3__union_XmlSchemaComplexType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup:
		((__ns3__union_XmlSchemaAttributeGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaAnnotation:
		((__ns3__union_XmlSchemaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchema_:
		((__ns3__union_XmlSchema_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__union_XmlSchema:
		((__ns3__union_XmlSchema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns5__union_Axis:
		((__ns5__union_Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns5__union_ResultXmlRoot:
		((__ns5__union_ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns4__union_Axis:
		((__ns4__union_Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns4__union_ResultXmlRoot:
		((__ns4__union_ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__union_Axis:
		((__ns2__union_Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__union_ResultXmlRoot:
		((__ns2__union_ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UsernameTokenElement:
		((ns6__UsernameTokenElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Security:
		((ns6__Security *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__CellInfo:
		((ns5__CellInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__HierarchyInfo:
		((ns5__HierarchyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__AxisInfo:
		((ns5__AxisInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__AxesInfo:
		((ns5__AxesInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Cube:
		((ns5__Cube *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__CubeInfo:
		((ns5__CubeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__OlapInfo:
		((ns5__OlapInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Row:
		((ns5__Row *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Members:
		((ns5__Members *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__CrossProduct:
		((ns5__CrossProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Member:
		((ns5__Member *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Tuple:
		((ns5__Tuple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Tuples:
		((ns5__Tuples *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Axis:
		((ns5__Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Axes:
		((ns5__Axes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Cell:
		((ns5__Cell *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__CellData:
		((ns5__CellData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ResultXmlRoot:
		((ns5__ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CellInfo:
		((ns4__CellInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__HierarchyInfo:
		((ns4__HierarchyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__AxisInfo:
		((ns4__AxisInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__AxesInfo:
		((ns4__AxesInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Cube:
		((ns4__Cube *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CubeInfo:
		((ns4__CubeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__OlapInfo:
		((ns4__OlapInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Row:
		((ns4__Row *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Members:
		((ns4__Members *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CrossProduct:
		((ns4__CrossProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Member:
		((ns4__Member *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Tuple:
		((ns4__Tuple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Tuples:
		((ns4__Tuples *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Axis:
		((ns4__Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Axes:
		((ns4__Axes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Cell:
		((ns4__Cell *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CellData:
		((ns4__CellData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ResultXmlRoot:
		((ns4__ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaInclude:
		((ns3__XmlSchemaInclude *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaRedefine:
		((ns3__XmlSchemaRedefine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaImport:
		((ns3__XmlSchemaImport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaExternal:
		((ns3__XmlSchemaExternal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroup:
		((ns3__XmlSchemaGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeList:
		((ns3__XmlSchemaSimpleTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction:
		((ns3__XmlSchemaSimpleTypeRestriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent:
		((ns3__XmlSchemaSimpleTypeContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion:
		((ns3__XmlSchemaSimpleTypeUnion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet:
		((ns3__XmlSchemaMaxExclusiveFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet:
		((ns3__XmlSchemaMinInclusiveFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet:
		((ns3__XmlSchemaMaxInclusiveFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinLengthFacet:
		((ns3__XmlSchemaMinLengthFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet:
		((ns3__XmlSchemaMaxLengthFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaLengthFacet:
		((ns3__XmlSchemaLengthFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet:
		((ns3__XmlSchemaTotalDigitsFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet:
		((ns3__XmlSchemaFractionDigitsFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaNumericFacet:
		((ns3__XmlSchemaNumericFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaPatternFacet:
		((ns3__XmlSchemaPatternFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaEnumerationFacet:
		((ns3__XmlSchemaEnumerationFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet:
		((ns3__XmlSchemaWhiteSpaceFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaFacet:
		((ns3__XmlSchemaFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet:
		((ns3__XmlSchemaMinExclusiveFacet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction:
		((ns3__XmlSchemaSimpleContentRestriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension:
		((ns3__XmlSchemaSimpleContentExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnyAttribute:
		((ns3__XmlSchemaAnyAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAll:
		((ns3__XmlSchemaAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSequence:
		((ns3__XmlSchemaSequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaChoice:
		((ns3__XmlSchemaChoice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroupBase:
		((ns3__XmlSchemaGroupBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAny:
		((ns3__XmlSchemaAny *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaKey:
		((ns3__XmlSchemaKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaKeyref:
		((ns3__XmlSchemaKeyref *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaXPath:
		((ns3__XmlSchemaXPath *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaIdentityConstraint:
		((ns3__XmlSchemaIdentityConstraint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaUnique:
		((ns3__XmlSchemaUnique *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaElement:
		((ns3__XmlSchemaElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaParticle:
		((ns3__XmlSchemaParticle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroupRef:
		((ns3__XmlSchemaGroupRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContentExtension:
		((ns3__XmlSchemaComplexContentExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaContent:
		((ns3__XmlSchemaContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction:
		((ns3__XmlSchemaComplexContentRestriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContent:
		((ns3__XmlSchemaComplexContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaContentModel:
		((ns3__XmlSchemaContentModel *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContent:
		((ns3__XmlSchemaSimpleContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexType:
		((ns3__XmlSchemaComplexType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaType:
		((ns3__XmlSchemaType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleType:
		((ns3__XmlSchemaSimpleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttribute:
		((ns3__XmlSchemaAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef:
		((ns3__XmlSchemaAttributeGroupRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroup:
		((ns3__XmlSchemaAttributeGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaNotation:
		((ns3__XmlSchemaNotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAppInfo:
		((ns3__XmlSchemaAppInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaDocumentation:
		((ns3__XmlSchemaDocumentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnnotation:
		((ns3__XmlSchemaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnnotated:
		((ns3__XmlSchemaAnnotated *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchemaObject:
		((ns3__XmlSchemaObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__XmlSchema:
		((ns3__XmlSchema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CellInfo:
		((ns2__CellInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HierarchyInfo:
		((ns2__HierarchyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AxisInfo:
		((ns2__AxisInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AxesInfo:
		((ns2__AxesInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Cube:
		((ns2__Cube *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CubeInfo:
		((ns2__CubeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OlapInfo:
		((ns2__OlapInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Row:
		((ns2__Row *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Members:
		((ns2__Members *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CrossProduct:
		((ns2__CrossProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Member:
		((ns2__Member *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Tuple:
		((ns2__Tuple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Tuples:
		((ns2__Tuples *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Axis:
		((ns2__Axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Axes:
		((ns2__Axes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Cell:
		((ns2__Cell *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CellData:
		((ns2__CellData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResultXmlRoot:
		((ns2__ResultXmlRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DiscoverResponse:
		((_ns1__DiscoverResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Discover:
		((_ns1__Discover *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteResponse:
		((_ns1__ExecuteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Execute:
		((_ns1__Execute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RestrictionList:
		((ns1__RestrictionList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Restrictions:
		((ns1__Restrictions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EndSession:
		((ns1__EndSession *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Session:
		((ns1__Session *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BeginSession:
		((ns1__BeginSession *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResultSet:
		((ns1__ResultSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameters:
		((ns1__Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PropertyList:
		((ns1__PropertyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Properties:
		((ns1__Properties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CommandStatement:
		((ns1__CommandStatement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaXPath:
		soap_serialize_xsd__XmlSchemaXPath(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet:
		soap_serialize_xsd__XmlSchemaWhiteSpaceFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaUse:
		soap_serialize_xsd__XmlSchemaUse(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaUnique:
		soap_serialize_xsd__XmlSchemaUnique(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaType:
		soap_serialize_xsd__XmlSchemaType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet:
		soap_serialize_xsd__XmlSchemaTotalDigitsFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion:
		soap_serialize_xsd__XmlSchemaSimpleTypeUnion(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction:
		soap_serialize_xsd__XmlSchemaSimpleTypeRestriction(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeList:
		soap_serialize_xsd__XmlSchemaSimpleTypeList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent:
		soap_serialize_xsd__XmlSchemaSimpleTypeContent(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleType:
		soap_serialize_xsd__XmlSchemaSimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction:
		soap_serialize_xsd__XmlSchemaSimpleContentRestriction(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension:
		soap_serialize_xsd__XmlSchemaSimpleContentExtension(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContent:
		soap_serialize_xsd__XmlSchemaSimpleContent(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSequence:
		soap_serialize_xsd__XmlSchemaSequence(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaRedefine:
		soap_serialize_xsd__XmlSchemaRedefine(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaPatternFacet:
		soap_serialize_xsd__XmlSchemaPatternFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaParticle:
		soap_serialize_xsd__XmlSchemaParticle(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaObject:
		soap_serialize_xsd__XmlSchemaObject(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaNumericFacet:
		soap_serialize_xsd__XmlSchemaNumericFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaNotation:
		soap_serialize_xsd__XmlSchemaNotation(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinLengthFacet:
		soap_serialize_xsd__XmlSchemaMinLengthFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet:
		soap_serialize_xsd__XmlSchemaMinInclusiveFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet:
		soap_serialize_xsd__XmlSchemaMinExclusiveFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet:
		soap_serialize_xsd__XmlSchemaMaxLengthFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet:
		soap_serialize_xsd__XmlSchemaMaxInclusiveFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet:
		soap_serialize_xsd__XmlSchemaMaxExclusiveFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaLengthFacet:
		soap_serialize_xsd__XmlSchemaLengthFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaKeyref:
		soap_serialize_xsd__XmlSchemaKeyref(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaKey:
		soap_serialize_xsd__XmlSchemaKey(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaInclude:
		soap_serialize_xsd__XmlSchemaInclude(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaImport:
		soap_serialize_xsd__XmlSchemaImport(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaIdentityConstraint:
		soap_serialize_xsd__XmlSchemaIdentityConstraint(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroupRef:
		soap_serialize_xsd__XmlSchemaGroupRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroupBase:
		soap_serialize_xsd__XmlSchemaGroupBase(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroup:
		soap_serialize_xsd__XmlSchemaGroup(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet:
		soap_serialize_xsd__XmlSchemaFractionDigitsFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaForm:
		soap_serialize_xsd__XmlSchemaForm(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaFacet:
		soap_serialize_xsd__XmlSchemaFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaExternal:
		soap_serialize_xsd__XmlSchemaExternal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaEnumerationFacet:
		soap_serialize_xsd__XmlSchemaEnumerationFacet(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaElement:
		soap_serialize_xsd__XmlSchemaElement(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaDocumentation:
		soap_serialize_xsd__XmlSchemaDocumentation(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaDerivationMethod:
		soap_serialize_xsd__XmlSchemaDerivationMethod(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContentProcessing:
		soap_serialize_xsd__XmlSchemaContentProcessing(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContentModel:
		soap_serialize_xsd__XmlSchemaContentModel(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContent:
		soap_serialize_xsd__XmlSchemaContent(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexType:
		soap_serialize_xsd__XmlSchemaComplexType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction:
		soap_serialize_xsd__XmlSchemaComplexContentRestriction(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContentExtension:
		soap_serialize_xsd__XmlSchemaComplexContentExtension(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContent:
		soap_serialize_xsd__XmlSchemaComplexContent(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaChoice:
		soap_serialize_xsd__XmlSchemaChoice(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef:
		soap_serialize_xsd__XmlSchemaAttributeGroupRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroup:
		soap_serialize_xsd__XmlSchemaAttributeGroup(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttribute:
		soap_serialize_xsd__XmlSchemaAttribute(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAppInfo:
		soap_serialize_xsd__XmlSchemaAppInfo(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnyAttribute:
		soap_serialize_xsd__XmlSchemaAnyAttribute(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAny:
		soap_serialize_xsd__XmlSchemaAny(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnnotation:
		soap_serialize_xsd__XmlSchemaAnnotation(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnnotated:
		soap_serialize_xsd__XmlSchemaAnnotated(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAll:
		soap_serialize_xsd__XmlSchemaAll(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchema:
		soap_serialize_xsd__XmlSchema(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__Discover_:
		soap_serialize___ns1__Discover_(soap, (const struct __ns1__Discover_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Execute_:
		soap_serialize___ns1__Execute_(soap, (const struct __ns1__Execute_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Discover:
		soap_serialize___ns1__Discover(soap, (const struct __ns1__Discover *)ptr);
		break;
	case SOAP_TYPE___ns1__Execute:
		soap_serialize___ns1__Execute(soap, (const struct __ns1__Execute *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DiscoverResponse:
		soap_serialize_PointerTo_ns1__DiscoverResponse(soap, (_ns1__DiscoverResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Discover:
		soap_serialize_PointerTo_ns1__Discover(soap, (_ns1__Discover *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteResponse:
		soap_serialize_PointerTo_ns1__ExecuteResponse(soap, (_ns1__ExecuteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Execute:
		soap_serialize_PointerTo_ns1__Execute(soap, (_ns1__Execute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Security:
		soap_serialize_PointerTons6__Security(soap, (ns6__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Session:
		soap_serialize_PointerTons1__Session(soap, (ns1__Session *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EndSession:
		soap_serialize_PointerTons1__EndSession(soap, (ns1__EndSession *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BeginSession:
		soap_serialize_PointerTons1__BeginSession(soap, (ns1__BeginSession *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaRedefine:
		soap_serialize_PointerTo__ns3__union_XmlSchemaRedefine(soap, (__ns3__union_XmlSchemaRedefine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction:
		soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(soap, (__ns3__union_XmlSchemaSimpleTypeRestriction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_:
		soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(soap, (__ns3__union_XmlSchemaSimpleContentRestriction_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction:
		soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(soap, (__ns3__union_XmlSchemaSimpleContentRestriction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaFractionDigitsFacet:
		soap_serialize_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaTotalDigitsFacet:
		soap_serialize_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaWhiteSpaceFacet:
		soap_serialize_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinInclusiveFacet:
		soap_serialize_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxExclusiveFacet:
		soap_serialize_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaPatternFacet:
		soap_serialize_PointerToxsd__XmlSchemaPatternFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxLengthFacet:
		soap_serialize_PointerToxsd__XmlSchemaMaxLengthFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinLengthFacet:
		soap_serialize_PointerToxsd__XmlSchemaMinLengthFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaLengthFacet:
		soap_serialize_PointerToxsd__XmlSchemaLengthFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMaxInclusiveFacet:
		soap_serialize_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaEnumerationFacet:
		soap_serialize_PointerToxsd__XmlSchemaEnumerationFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaMinExclusiveFacet:
		soap_serialize_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentExtension:
		soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(soap, (__ns3__union_XmlSchemaSimpleContentExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSequence:
		soap_serialize_PointerTo__ns3__union_XmlSchemaSequence(soap, (__ns3__union_XmlSchemaSequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaChoice:
		soap_serialize_PointerTo__ns3__union_XmlSchemaChoice(soap, (__ns3__union_XmlSchemaChoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAny:
		soap_serialize_PointerToxsd__XmlSchemaAny(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaContentProcessing:
		soap_serialize_PointerToxsd__XmlSchemaContentProcessing(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaXPath:
		soap_serialize_PointerToxsd__XmlSchemaXPath(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaElement_:
		soap_serialize_PointerTo__ns3__union_XmlSchemaElement_(soap, (__ns3__union_XmlSchemaElement_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaKeyref:
		soap_serialize_PointerToxsd__XmlSchemaKeyref(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaKey:
		soap_serialize_PointerToxsd__XmlSchemaKey(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaUnique:
		soap_serialize_PointerToxsd__XmlSchemaUnique(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexContentExtension_:
		soap_serialize_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(soap, (__ns3__union_XmlSchemaComplexContentExtension_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_:
		soap_serialize_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(soap, (__ns3__union_XmlSchemaComplexContentRestriction_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentExtension:
		soap_serialize_PointerToxsd__XmlSchemaComplexContentExtension(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentRestriction:
		soap_serialize_PointerToxsd__XmlSchemaComplexContentRestriction(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentExtension:
		soap_serialize_PointerToxsd__XmlSchemaSimpleContentExtension(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentRestriction:
		soap_serialize_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexType__:
		soap_serialize_PointerTo__ns3__union_XmlSchemaComplexType__(soap, (__ns3__union_XmlSchemaComplexType__ *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAll:
		soap_serialize_PointerToxsd__XmlSchemaAll(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaChoice:
		soap_serialize_PointerToxsd__XmlSchemaChoice(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSequence:
		soap_serialize_PointerToxsd__XmlSchemaSequence(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroupRef:
		soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexContent:
		soap_serialize_PointerToxsd__XmlSchemaComplexContent(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContent:
		soap_serialize_PointerToxsd__XmlSchemaSimpleContent(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeRestriction:
		soap_serialize_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeList:
		soap_serialize_PointerToxsd__XmlSchemaSimpleTypeList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeUnion:
		soap_serialize_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaUse:
		soap_serialize_PointerToxsd__XmlSchemaUse(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnyAttribute:
		soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaAttributeGroup:
		soap_serialize_PointerTo__ns3__union_XmlSchemaAttributeGroup(soap, (__ns3__union_XmlSchemaAttributeGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroupRef:
		soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchemaAnnotation:
		soap_serialize_PointerTo__ns3__union_XmlSchemaAnnotation(soap, (__ns3__union_XmlSchemaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAppInfo:
		soap_serialize_PointerToxsd__XmlSchemaAppInfo(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaDocumentation:
		soap_serialize_PointerToxsd__XmlSchemaDocumentation(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__token:
		soap_serialize_PointerToxsd__token(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaDerivationMethod:
		soap_serialize_PointerToxsd__XmlSchemaDerivationMethod(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaForm:
		soap_serialize_PointerToxsd__XmlSchemaForm(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchema_:
		soap_serialize_PointerTo__ns3__union_XmlSchema_(soap, (__ns3__union_XmlSchema_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaElement:
		soap_serialize_PointerToxsd__XmlSchemaElement(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaSimpleType:
		soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaComplexType:
		soap_serialize_PointerToxsd__XmlSchemaComplexType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroup:
		soap_serialize_PointerToxsd__XmlSchemaAttributeGroup(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAttribute:
		soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaAnnotation:
		soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaGroup:
		soap_serialize_PointerToxsd__XmlSchemaGroup(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaNotation:
		soap_serialize_PointerToxsd__XmlSchemaNotation(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns3__union_XmlSchema:
		soap_serialize_PointerTo__ns3__union_XmlSchema(soap, (__ns3__union_XmlSchema *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaImport:
		soap_serialize_PointerToxsd__XmlSchemaImport(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaRedefine:
		soap_serialize_PointerToxsd__XmlSchemaRedefine(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__XmlSchemaInclude:
		soap_serialize_PointerToxsd__XmlSchemaInclude(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UsernameTokenElement:
		soap_serialize_PointerTons6__UsernameTokenElement(soap, (ns6__UsernameTokenElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__HierarchyInfo:
		soap_serialize_PointerTons5__HierarchyInfo(soap, (ns5__HierarchyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__AxisInfo:
		soap_serialize_PointerTons5__AxisInfo(soap, (ns5__AxisInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Cube:
		soap_serialize_PointerTons5__Cube(soap, (ns5__Cube *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__CellInfo:
		soap_serialize_PointerTons5__CellInfo(soap, (ns5__CellInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__AxesInfo:
		soap_serialize_PointerTons5__AxesInfo(soap, (ns5__AxesInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__CubeInfo:
		soap_serialize_PointerTons5__CubeInfo(soap, (ns5__CubeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Members:
		soap_serialize_PointerTons5__Members(soap, (ns5__Members *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Member:
		soap_serialize_PointerTons5__Member(soap, (ns5__Member *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Tuple:
		soap_serialize_PointerTons5__Tuple(soap, (ns5__Tuple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns5__union_Axis:
		soap_serialize_PointerTo__ns5__union_Axis(soap, (__ns5__union_Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__CrossProduct:
		soap_serialize_PointerTons5__CrossProduct(soap, (ns5__CrossProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Tuples:
		soap_serialize_PointerTons5__Tuples(soap, (ns5__Tuples *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Axis:
		soap_serialize_PointerTons5__Axis(soap, (ns5__Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Cell:
		soap_serialize_PointerTons5__Cell(soap, (ns5__Cell *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns5__union_ResultXmlRoot:
		soap_serialize_PointerTo__ns5__union_ResultXmlRoot(soap, (__ns5__union_ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__OlapInfo:
		soap_serialize_PointerTons5__OlapInfo(soap, (ns5__OlapInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Row:
		soap_serialize_PointerTons5__Row(soap, (ns5__Row *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Axes:
		soap_serialize_PointerTons5__Axes(soap, (ns5__Axes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__CellData:
		soap_serialize_PointerTons5__CellData(soap, (ns5__CellData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__HierarchyInfo:
		soap_serialize_PointerTons4__HierarchyInfo(soap, (ns4__HierarchyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__AxisInfo:
		soap_serialize_PointerTons4__AxisInfo(soap, (ns4__AxisInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Cube:
		soap_serialize_PointerTons4__Cube(soap, (ns4__Cube *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CellInfo:
		soap_serialize_PointerTons4__CellInfo(soap, (ns4__CellInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__AxesInfo:
		soap_serialize_PointerTons4__AxesInfo(soap, (ns4__AxesInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CubeInfo:
		soap_serialize_PointerTons4__CubeInfo(soap, (ns4__CubeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Members:
		soap_serialize_PointerTons4__Members(soap, (ns4__Members *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Member:
		soap_serialize_PointerTons4__Member(soap, (ns4__Member *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Tuple:
		soap_serialize_PointerTons4__Tuple(soap, (ns4__Tuple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns4__union_Axis:
		soap_serialize_PointerTo__ns4__union_Axis(soap, (__ns4__union_Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CrossProduct:
		soap_serialize_PointerTons4__CrossProduct(soap, (ns4__CrossProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Tuples:
		soap_serialize_PointerTons4__Tuples(soap, (ns4__Tuples *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Axis:
		soap_serialize_PointerTons4__Axis(soap, (ns4__Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Cell:
		soap_serialize_PointerTons4__Cell(soap, (ns4__Cell *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns4__union_ResultXmlRoot:
		soap_serialize_PointerTo__ns4__union_ResultXmlRoot(soap, (__ns4__union_ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OlapInfo:
		soap_serialize_PointerTons4__OlapInfo(soap, (ns4__OlapInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Row:
		soap_serialize_PointerTons4__Row(soap, (ns4__Row *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Axes:
		soap_serialize_PointerTons4__Axes(soap, (ns4__Axes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CellData:
		soap_serialize_PointerTons4__CellData(soap, (ns4__CellData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HierarchyInfo:
		soap_serialize_PointerTons2__HierarchyInfo(soap, (ns2__HierarchyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AxisInfo:
		soap_serialize_PointerTons2__AxisInfo(soap, (ns2__AxisInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Cube:
		soap_serialize_PointerTons2__Cube(soap, (ns2__Cube *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CellInfo:
		soap_serialize_PointerTons2__CellInfo(soap, (ns2__CellInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AxesInfo:
		soap_serialize_PointerTons2__AxesInfo(soap, (ns2__AxesInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CubeInfo:
		soap_serialize_PointerTons2__CubeInfo(soap, (ns2__CubeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Members:
		soap_serialize_PointerTons2__Members(soap, (ns2__Members *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Member:
		soap_serialize_PointerTons2__Member(soap, (ns2__Member *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Tuple:
		soap_serialize_PointerTons2__Tuple(soap, (ns2__Tuple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_Axis:
		soap_serialize_PointerTo__ns2__union_Axis(soap, (__ns2__union_Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CrossProduct:
		soap_serialize_PointerTons2__CrossProduct(soap, (ns2__CrossProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Tuples:
		soap_serialize_PointerTons2__Tuples(soap, (ns2__Tuples *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Axis:
		soap_serialize_PointerTons2__Axis(soap, (ns2__Axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Cell:
		soap_serialize_PointerTons2__Cell(soap, (ns2__Cell *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_ResultXmlRoot:
		soap_serialize_PointerTo__ns2__union_ResultXmlRoot(soap, (__ns2__union_ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OlapInfo:
		soap_serialize_PointerTons2__OlapInfo(soap, (ns2__OlapInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Axes:
		soap_serialize_PointerTons2__Axes(soap, (ns2__Axes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CellData:
		soap_serialize_PointerTons2__CellData(soap, (ns2__CellData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Restrictions:
		soap_serialize_PointerTons1__Restrictions(soap, (ns1__Restrictions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ResultSet:
		soap_serialize_PointerTons1__ResultSet(soap, (ns1__ResultSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameters:
		soap_serialize_PointerTons1__Parameters(soap, (ns1__Parameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Properties:
		soap_serialize_PointerTons1__Properties(soap, (ns1__Properties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CommandStatement:
		soap_serialize_PointerTons1__CommandStatement(soap, (ns1__CommandStatement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RestrictionList:
		soap_serialize_PointerTons1__RestrictionList(soap, (ns1__RestrictionList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ResultXmlRoot:
		soap_serialize_PointerTons5__ResultXmlRoot(soap, (ns5__ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ResultXmlRoot:
		soap_serialize_PointerTons4__ResultXmlRoot(soap, (ns4__ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResultXmlRoot:
		soap_serialize_PointerTons2__ResultXmlRoot(soap, (ns2__ResultXmlRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PropertyList:
		soap_serialize_PointerTons1__PropertyList(soap, (ns1__PropertyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__xsd__schema:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CommandStatement:
		return (void*)soap_instantiate_ns1__CommandStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Properties:
		return (void*)soap_instantiate_ns1__Properties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PropertyList:
		return (void*)soap_instantiate_ns1__PropertyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameters:
		return (void*)soap_instantiate_ns1__Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResultSet:
		return (void*)soap_instantiate_ns1__ResultSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BeginSession:
		return (void*)soap_instantiate_ns1__BeginSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Session:
		return (void*)soap_instantiate_ns1__Session(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EndSession:
		return (void*)soap_instantiate_ns1__EndSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Restrictions:
		return (void*)soap_instantiate_ns1__Restrictions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RestrictionList:
		return (void*)soap_instantiate_ns1__RestrictionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Execute:
		return (void*)soap_instantiate__ns1__Execute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteResponse:
		return (void*)soap_instantiate__ns1__ExecuteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Discover:
		return (void*)soap_instantiate__ns1__Discover(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DiscoverResponse:
		return (void*)soap_instantiate__ns1__DiscoverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_ResultXmlRoot:
		return (void*)soap_instantiate___ns2__union_ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResultXmlRoot:
		return (void*)soap_instantiate_ns2__ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CellData:
		return (void*)soap_instantiate_ns2__CellData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Cell:
		return (void*)soap_instantiate_ns2__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Axes:
		return (void*)soap_instantiate_ns2__Axes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_Axis:
		return (void*)soap_instantiate___ns2__union_Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Axis:
		return (void*)soap_instantiate_ns2__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Tuples:
		return (void*)soap_instantiate_ns2__Tuples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Tuple:
		return (void*)soap_instantiate_ns2__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Member:
		return (void*)soap_instantiate_ns2__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CrossProduct:
		return (void*)soap_instantiate_ns2__CrossProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Members:
		return (void*)soap_instantiate_ns2__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Row:
		return (void*)soap_instantiate_ns2__Row(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OlapInfo:
		return (void*)soap_instantiate_ns2__OlapInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CubeInfo:
		return (void*)soap_instantiate_ns2__CubeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Cube:
		return (void*)soap_instantiate_ns2__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AxesInfo:
		return (void*)soap_instantiate_ns2__AxesInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AxisInfo:
		return (void*)soap_instantiate_ns2__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HierarchyInfo:
		return (void*)soap_instantiate_ns2__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CellInfo:
		return (void*)soap_instantiate_ns2__CellInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaObject:
		return (void*)soap_instantiate_ns3__XmlSchemaObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__union_ResultXmlRoot:
		return (void*)soap_instantiate___ns4__union_ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResultXmlRoot:
		return (void*)soap_instantiate_ns4__ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CellData:
		return (void*)soap_instantiate_ns4__CellData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Cell:
		return (void*)soap_instantiate_ns4__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Axes:
		return (void*)soap_instantiate_ns4__Axes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__union_Axis:
		return (void*)soap_instantiate___ns4__union_Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Axis:
		return (void*)soap_instantiate_ns4__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Tuples:
		return (void*)soap_instantiate_ns4__Tuples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Tuple:
		return (void*)soap_instantiate_ns4__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Member:
		return (void*)soap_instantiate_ns4__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CrossProduct:
		return (void*)soap_instantiate_ns4__CrossProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Members:
		return (void*)soap_instantiate_ns4__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Row:
		return (void*)soap_instantiate_ns4__Row(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__OlapInfo:
		return (void*)soap_instantiate_ns4__OlapInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CubeInfo:
		return (void*)soap_instantiate_ns4__CubeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Cube:
		return (void*)soap_instantiate_ns4__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__AxesInfo:
		return (void*)soap_instantiate_ns4__AxesInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__AxisInfo:
		return (void*)soap_instantiate_ns4__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__HierarchyInfo:
		return (void*)soap_instantiate_ns4__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CellInfo:
		return (void*)soap_instantiate_ns4__CellInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__union_ResultXmlRoot:
		return (void*)soap_instantiate___ns5__union_ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ResultXmlRoot:
		return (void*)soap_instantiate_ns5__ResultXmlRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CellData:
		return (void*)soap_instantiate_ns5__CellData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Cell:
		return (void*)soap_instantiate_ns5__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Axes:
		return (void*)soap_instantiate_ns5__Axes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__union_Axis:
		return (void*)soap_instantiate___ns5__union_Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Axis:
		return (void*)soap_instantiate_ns5__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Tuples:
		return (void*)soap_instantiate_ns5__Tuples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Tuple:
		return (void*)soap_instantiate_ns5__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Member:
		return (void*)soap_instantiate_ns5__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CrossProduct:
		return (void*)soap_instantiate_ns5__CrossProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Members:
		return (void*)soap_instantiate_ns5__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Row:
		return (void*)soap_instantiate_ns5__Row(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__OlapInfo:
		return (void*)soap_instantiate_ns5__OlapInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CubeInfo:
		return (void*)soap_instantiate_ns5__CubeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Cube:
		return (void*)soap_instantiate_ns5__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__AxesInfo:
		return (void*)soap_instantiate_ns5__AxesInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__AxisInfo:
		return (void*)soap_instantiate_ns5__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__HierarchyInfo:
		return (void*)soap_instantiate_ns5__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CellInfo:
		return (void*)soap_instantiate_ns5__CellInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Security:
		return (void*)soap_instantiate_ns6__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UsernameTokenElement:
		return (void*)soap_instantiate_ns6__UsernameTokenElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchema:
		return (void*)soap_instantiate___ns3__union_XmlSchema(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchema_:
		return (void*)soap_instantiate___ns3__union_XmlSchema_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchema:
		return (void*)soap_instantiate_ns3__XmlSchema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAnnotated:
		return (void*)soap_instantiate_ns3__XmlSchemaAnnotated(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaAnnotation:
		return (void*)soap_instantiate___ns3__union_XmlSchemaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAnnotation:
		return (void*)soap_instantiate_ns3__XmlSchemaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaDocumentation:
		return (void*)soap_instantiate_ns3__XmlSchemaDocumentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAppInfo:
		return (void*)soap_instantiate_ns3__XmlSchemaAppInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaNotation:
		return (void*)soap_instantiate_ns3__XmlSchemaNotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup:
		return (void*)soap_instantiate___ns3__union_XmlSchemaAttributeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroup:
		return (void*)soap_instantiate_ns3__XmlSchemaAttributeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef:
		return (void*)soap_instantiate_ns3__XmlSchemaAttributeGroupRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAttribute:
		return (void*)soap_instantiate_ns3__XmlSchemaAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleType:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaType:
		return (void*)soap_instantiate_ns3__XmlSchemaType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaComplexType__:
		return (void*)soap_instantiate___ns3__union_XmlSchemaComplexType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaComplexType:
		return (void*)soap_instantiate_ns3__XmlSchemaComplexType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleContent:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaContentModel:
		return (void*)soap_instantiate_ns3__XmlSchemaContentModel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaComplexContent:
		return (void*)soap_instantiate_ns3__XmlSchemaComplexContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_:
		return (void*)soap_instantiate___ns3__union_XmlSchemaComplexContentRestriction_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction:
		return (void*)soap_instantiate_ns3__XmlSchemaComplexContentRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaContent:
		return (void*)soap_instantiate_ns3__XmlSchemaContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_:
		return (void*)soap_instantiate___ns3__union_XmlSchemaComplexContentExtension_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaComplexContentExtension:
		return (void*)soap_instantiate_ns3__XmlSchemaComplexContentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaGroupRef:
		return (void*)soap_instantiate_ns3__XmlSchemaGroupRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaParticle:
		return (void*)soap_instantiate_ns3__XmlSchemaParticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaElement_:
		return (void*)soap_instantiate___ns3__union_XmlSchemaElement_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaElement:
		return (void*)soap_instantiate_ns3__XmlSchemaElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaUnique:
		return (void*)soap_instantiate_ns3__XmlSchemaUnique(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaIdentityConstraint:
		return (void*)soap_instantiate_ns3__XmlSchemaIdentityConstraint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaXPath:
		return (void*)soap_instantiate_ns3__XmlSchemaXPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaKeyref:
		return (void*)soap_instantiate_ns3__XmlSchemaKeyref(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaKey:
		return (void*)soap_instantiate_ns3__XmlSchemaKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAny:
		return (void*)soap_instantiate_ns3__XmlSchemaAny(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaGroupBase:
		return (void*)soap_instantiate_ns3__XmlSchemaGroupBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaChoice:
		return (void*)soap_instantiate___ns3__union_XmlSchemaChoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaChoice:
		return (void*)soap_instantiate_ns3__XmlSchemaChoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaSequence:
		return (void*)soap_instantiate___ns3__union_XmlSchemaSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSequence:
		return (void*)soap_instantiate_ns3__XmlSchemaSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAll:
		return (void*)soap_instantiate_ns3__XmlSchemaAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaAnyAttribute:
		return (void*)soap_instantiate_ns3__XmlSchemaAnyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension:
		return (void*)soap_instantiate___ns3__union_XmlSchemaSimpleContentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleContentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction:
		return (void*)soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_:
		return (void*)soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleContentRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMinExclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaWhiteSpaceFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaEnumerationFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaEnumerationFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaPatternFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaPatternFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaNumericFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaNumericFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaFractionDigitsFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaTotalDigitsFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaLengthFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMaxLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMinLengthFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMinLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMaxInclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMinInclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet:
		return (void*)soap_instantiate_ns3__XmlSchemaMaxExclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleTypeUnion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleTypeContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction:
		return (void*)soap_instantiate___ns3__union_XmlSchemaSimpleTypeRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleTypeRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeList:
		return (void*)soap_instantiate_ns3__XmlSchemaSimpleTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaGroup:
		return (void*)soap_instantiate_ns3__XmlSchemaGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaExternal:
		return (void*)soap_instantiate_ns3__XmlSchemaExternal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaImport:
		return (void*)soap_instantiate_ns3__XmlSchemaImport(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__union_XmlSchemaRedefine:
		return (void*)soap_instantiate___ns3__union_XmlSchemaRedefine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaRedefine:
		return (void*)soap_instantiate_ns3__XmlSchemaRedefine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__XmlSchemaInclude:
		return (void*)soap_instantiate_ns3__XmlSchemaInclude(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__Execute:
		return (void*)soap_instantiate___ns1__Execute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Discover:
		return (void*)soap_instantiate___ns1__Discover(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Execute_:
		return (void*)soap_instantiate___ns1__Execute_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Discover_:
		return (void*)soap_instantiate___ns1__Discover_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchema:
		return (void*)soap_instantiate_xsd__XmlSchema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAll:
		return (void*)soap_instantiate_xsd__XmlSchemaAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAnnotated:
		return (void*)soap_instantiate_xsd__XmlSchemaAnnotated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAnnotation:
		return (void*)soap_instantiate_xsd__XmlSchemaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAny:
		return (void*)soap_instantiate_xsd__XmlSchemaAny(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAnyAttribute:
		return (void*)soap_instantiate_xsd__XmlSchemaAnyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAppInfo:
		return (void*)soap_instantiate_xsd__XmlSchemaAppInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAttribute:
		return (void*)soap_instantiate_xsd__XmlSchemaAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroup:
		return (void*)soap_instantiate_xsd__XmlSchemaAttributeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef:
		return (void*)soap_instantiate_xsd__XmlSchemaAttributeGroupRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaChoice:
		return (void*)soap_instantiate_xsd__XmlSchemaChoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaComplexContent:
		return (void*)soap_instantiate_xsd__XmlSchemaComplexContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaComplexContentExtension:
		return (void*)soap_instantiate_xsd__XmlSchemaComplexContentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction:
		return (void*)soap_instantiate_xsd__XmlSchemaComplexContentRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaComplexType:
		return (void*)soap_instantiate_xsd__XmlSchemaComplexType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaContent:
		return (void*)soap_instantiate_xsd__XmlSchemaContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaContentModel:
		return (void*)soap_instantiate_xsd__XmlSchemaContentModel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaContentProcessing:
		return (void*)soap_instantiate_xsd__XmlSchemaContentProcessing(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaDerivationMethod:
		return (void*)soap_instantiate_xsd__XmlSchemaDerivationMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaDocumentation:
		return (void*)soap_instantiate_xsd__XmlSchemaDocumentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaElement:
		return (void*)soap_instantiate_xsd__XmlSchemaElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaEnumerationFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaEnumerationFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaExternal:
		return (void*)soap_instantiate_xsd__XmlSchemaExternal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaForm:
		return (void*)soap_instantiate_xsd__XmlSchemaForm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaFractionDigitsFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaGroup:
		return (void*)soap_instantiate_xsd__XmlSchemaGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaGroupBase:
		return (void*)soap_instantiate_xsd__XmlSchemaGroupBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaGroupRef:
		return (void*)soap_instantiate_xsd__XmlSchemaGroupRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaIdentityConstraint:
		return (void*)soap_instantiate_xsd__XmlSchemaIdentityConstraint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaImport:
		return (void*)soap_instantiate_xsd__XmlSchemaImport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaInclude:
		return (void*)soap_instantiate_xsd__XmlSchemaInclude(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaKey:
		return (void*)soap_instantiate_xsd__XmlSchemaKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaKeyref:
		return (void*)soap_instantiate_xsd__XmlSchemaKeyref(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaLengthFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMaxExclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMaxInclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMaxLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMinExclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMinInclusiveFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaMinLengthFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaMinLengthFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaNotation:
		return (void*)soap_instantiate_xsd__XmlSchemaNotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaNumericFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaNumericFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaObject:
		return (void*)soap_instantiate_xsd__XmlSchemaObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaParticle:
		return (void*)soap_instantiate_xsd__XmlSchemaParticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaPatternFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaPatternFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaRedefine:
		return (void*)soap_instantiate_xsd__XmlSchemaRedefine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSequence:
		return (void*)soap_instantiate_xsd__XmlSchemaSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleContent:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleContentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleContentRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleType:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleTypeContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeList:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleTypeRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion:
		return (void*)soap_instantiate_xsd__XmlSchemaSimpleTypeUnion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaTotalDigitsFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaType:
		return (void*)soap_instantiate_xsd__XmlSchemaType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaUnique:
		return (void*)soap_instantiate_xsd__XmlSchemaUnique(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaUse:
		return (void*)soap_instantiate_xsd__XmlSchemaUse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet:
		return (void*)soap_instantiate_xsd__XmlSchemaWhiteSpaceFacet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__XmlSchemaXPath:
		return (void*)soap_instantiate_xsd__XmlSchemaXPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaSimpleType:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaElement:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaXPath:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HierarchyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__AxisInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cube:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Members:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Member:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Tuple:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Axis:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cell:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__HierarchyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AxisInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cube:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Members:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Member:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Tuple:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Axis:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cell:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__HierarchyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AxisInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__AxisInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cube:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Cube(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Members:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Members(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Member:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Member(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Tuple:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Tuple(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Axis:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cell:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Cell(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CommandStatement:
		if (p->size < 0)
			SOAP_DELETE((ns1__CommandStatement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CommandStatement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Properties:
		if (p->size < 0)
			SOAP_DELETE((ns1__Properties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Properties*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PropertyList:
		if (p->size < 0)
			SOAP_DELETE((ns1__PropertyList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PropertyList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Parameters:
		if (p->size < 0)
			SOAP_DELETE((ns1__Parameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Parameters*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ResultSet:
		if (p->size < 0)
			SOAP_DELETE((ns1__ResultSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ResultSet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__BeginSession:
		if (p->size < 0)
			SOAP_DELETE((ns1__BeginSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__BeginSession*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Session:
		if (p->size < 0)
			SOAP_DELETE((ns1__Session*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Session*)p->ptr);
		break;
	case SOAP_TYPE_ns1__EndSession:
		if (p->size < 0)
			SOAP_DELETE((ns1__EndSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__EndSession*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Restrictions:
		if (p->size < 0)
			SOAP_DELETE((ns1__Restrictions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Restrictions*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RestrictionList:
		if (p->size < 0)
			SOAP_DELETE((ns1__RestrictionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__RestrictionList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__Execute:
		if (p->size < 0)
			SOAP_DELETE((_ns1__Execute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__Execute*)p->ptr);
		break;
	case SOAP_TYPE__ns1__ExecuteResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__ExecuteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__ExecuteResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__Discover:
		if (p->size < 0)
			SOAP_DELETE((_ns1__Discover*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__Discover*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DiscoverResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DiscoverResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DiscoverResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((ns2__ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CellData:
		if (p->size < 0)
			SOAP_DELETE((ns2__CellData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CellData*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Cell:
		if (p->size < 0)
			SOAP_DELETE((ns2__Cell*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Cell*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Axes:
		if (p->size < 0)
			SOAP_DELETE((ns2__Axes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Axes*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_Axis:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Axis:
		if (p->size < 0)
			SOAP_DELETE((ns2__Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Tuples:
		if (p->size < 0)
			SOAP_DELETE((ns2__Tuples*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Tuples*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Tuple:
		if (p->size < 0)
			SOAP_DELETE((ns2__Tuple*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Tuple*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Member:
		if (p->size < 0)
			SOAP_DELETE((ns2__Member*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Member*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CrossProduct:
		if (p->size < 0)
			SOAP_DELETE((ns2__CrossProduct*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CrossProduct*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Members:
		if (p->size < 0)
			SOAP_DELETE((ns2__Members*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Members*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Row:
		if (p->size < 0)
			SOAP_DELETE((ns2__Row*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Row*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OlapInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__OlapInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OlapInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CubeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__CubeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CubeInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Cube:
		if (p->size < 0)
			SOAP_DELETE((ns2__Cube*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Cube*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AxesInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__AxesInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AxesInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__AxisInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AxisInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__HierarchyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HierarchyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CellInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__CellInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CellInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaObject:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaObject*)p->ptr);
		break;
	case SOAP_TYPE___ns4__union_ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((__ns4__union_ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns4__union_ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((ns4__ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns4__CellData:
		if (p->size < 0)
			SOAP_DELETE((ns4__CellData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__CellData*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Cell:
		if (p->size < 0)
			SOAP_DELETE((ns4__Cell*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Cell*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Axes:
		if (p->size < 0)
			SOAP_DELETE((ns4__Axes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Axes*)p->ptr);
		break;
	case SOAP_TYPE___ns4__union_Axis:
		if (p->size < 0)
			SOAP_DELETE((__ns4__union_Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns4__union_Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Axis:
		if (p->size < 0)
			SOAP_DELETE((ns4__Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Tuples:
		if (p->size < 0)
			SOAP_DELETE((ns4__Tuples*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Tuples*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Tuple:
		if (p->size < 0)
			SOAP_DELETE((ns4__Tuple*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Tuple*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Member:
		if (p->size < 0)
			SOAP_DELETE((ns4__Member*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Member*)p->ptr);
		break;
	case SOAP_TYPE_ns4__CrossProduct:
		if (p->size < 0)
			SOAP_DELETE((ns4__CrossProduct*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__CrossProduct*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Members:
		if (p->size < 0)
			SOAP_DELETE((ns4__Members*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Members*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Row:
		if (p->size < 0)
			SOAP_DELETE((ns4__Row*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Row*)p->ptr);
		break;
	case SOAP_TYPE_ns4__OlapInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__OlapInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__OlapInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__CubeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__CubeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__CubeInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Cube:
		if (p->size < 0)
			SOAP_DELETE((ns4__Cube*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__Cube*)p->ptr);
		break;
	case SOAP_TYPE_ns4__AxesInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__AxesInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__AxesInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__AxisInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__AxisInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__HierarchyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__HierarchyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__CellInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__CellInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__CellInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns5__union_ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((__ns5__union_ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns5__union_ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ResultXmlRoot:
		if (p->size < 0)
			SOAP_DELETE((ns5__ResultXmlRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ResultXmlRoot*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CellData:
		if (p->size < 0)
			SOAP_DELETE((ns5__CellData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__CellData*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Cell:
		if (p->size < 0)
			SOAP_DELETE((ns5__Cell*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Cell*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Axes:
		if (p->size < 0)
			SOAP_DELETE((ns5__Axes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Axes*)p->ptr);
		break;
	case SOAP_TYPE___ns5__union_Axis:
		if (p->size < 0)
			SOAP_DELETE((__ns5__union_Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns5__union_Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Axis:
		if (p->size < 0)
			SOAP_DELETE((ns5__Axis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Axis*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Tuples:
		if (p->size < 0)
			SOAP_DELETE((ns5__Tuples*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Tuples*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Tuple:
		if (p->size < 0)
			SOAP_DELETE((ns5__Tuple*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Tuple*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Member:
		if (p->size < 0)
			SOAP_DELETE((ns5__Member*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Member*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CrossProduct:
		if (p->size < 0)
			SOAP_DELETE((ns5__CrossProduct*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__CrossProduct*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Members:
		if (p->size < 0)
			SOAP_DELETE((ns5__Members*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Members*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Row:
		if (p->size < 0)
			SOAP_DELETE((ns5__Row*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Row*)p->ptr);
		break;
	case SOAP_TYPE_ns5__OlapInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__OlapInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__OlapInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CubeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__CubeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__CubeInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Cube:
		if (p->size < 0)
			SOAP_DELETE((ns5__Cube*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Cube*)p->ptr);
		break;
	case SOAP_TYPE_ns5__AxesInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__AxesInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__AxesInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns5__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__AxisInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__AxisInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns5__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__HierarchyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__HierarchyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CellInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__CellInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__CellInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Security:
		if (p->size < 0)
			SOAP_DELETE((ns6__Security*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__Security*)p->ptr);
		break;
	case SOAP_TYPE_ns6__UsernameTokenElement:
		if (p->size < 0)
			SOAP_DELETE((ns6__UsernameTokenElement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__UsernameTokenElement*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchema:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchema*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchema*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchema_:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchema_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchema_*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchema:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchema*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchema*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnnotated:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAnnotated*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAnnotated*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaDocumentation:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaDocumentation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaDocumentation*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAppInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAppInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAppInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaNotation:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaNotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaNotation*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaAttributeGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaAttributeGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroup:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAttributeGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAttributeGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAttributeGroupRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAttributeGroupRef*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAttribute:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAttribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAttribute*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleType:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaType:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaType*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexType__:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaComplexType__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaComplexType__*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexType:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaComplexType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaComplexType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContent:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleContent*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaContentModel:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaContentModel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaContentModel*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContent:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaComplexContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaComplexContent*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaComplexContentRestriction_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaComplexContentRestriction_*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaComplexContentRestriction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaComplexContentRestriction*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaContent:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaContent*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaComplexContentExtension_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaComplexContentExtension_*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaComplexContentExtension:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaComplexContentExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaComplexContentExtension*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroupRef:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaGroupRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaGroupRef*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaParticle:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaParticle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaParticle*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaElement_:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaElement_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaElement_*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaElement:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaElement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaElement*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaUnique:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaUnique*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaUnique*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaIdentityConstraint:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaIdentityConstraint*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaIdentityConstraint*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaXPath:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaXPath*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaXPath*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaKeyref:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaKeyref*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaKeyref*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaKey:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaKey*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaKey*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAny:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAny*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAny*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroupBase:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaGroupBase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaGroupBase*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaChoice:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaChoice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaChoice*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaChoice:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaChoice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaChoice*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSequence:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaSequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaSequence*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSequence:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSequence*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAll:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAll*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAll*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaAnyAttribute:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaAnyAttribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaAnyAttribute*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaSimpleContentExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaSimpleContentExtension*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleContentExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleContentExtension*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaSimpleContentRestriction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaSimpleContentRestriction*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaSimpleContentRestriction_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaSimpleContentRestriction_*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleContentRestriction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleContentRestriction*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMinExclusiveFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMinExclusiveFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaWhiteSpaceFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaWhiteSpaceFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaEnumerationFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaEnumerationFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaEnumerationFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaPatternFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaPatternFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaPatternFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaNumericFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaNumericFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaNumericFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaFractionDigitsFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaFractionDigitsFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaTotalDigitsFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaTotalDigitsFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaLengthFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaLengthFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMaxLengthFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMaxLengthFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMinLengthFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMinLengthFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMaxInclusiveFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMaxInclusiveFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMinInclusiveFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMinInclusiveFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaMaxExclusiveFacet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaMaxExclusiveFacet*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleTypeUnion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleTypeUnion*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleTypeContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleTypeContent*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaSimpleTypeRestriction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaSimpleTypeRestriction*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleTypeRestriction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleTypeRestriction*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaSimpleTypeList:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaSimpleTypeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaSimpleTypeList*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaGroup:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaExternal:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaExternal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaExternal*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaImport:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaImport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaImport*)p->ptr);
		break;
	case SOAP_TYPE___ns3__union_XmlSchemaRedefine:
		if (p->size < 0)
			SOAP_DELETE((__ns3__union_XmlSchemaRedefine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns3__union_XmlSchemaRedefine*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaRedefine:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaRedefine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaRedefine*)p->ptr);
		break;
	case SOAP_TYPE_ns3__XmlSchemaInclude:
		if (p->size < 0)
			SOAP_DELETE((ns3__XmlSchemaInclude*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__XmlSchemaInclude*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__Execute:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Execute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Execute*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Discover:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Discover*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Discover*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Execute_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Execute_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Execute_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Discover_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Discover_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Discover_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchema:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAll:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnnotated:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAny:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAnyAttribute:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAppInfo:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttribute:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroup:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaChoice:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContent:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContentExtension:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaComplexType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContent:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContentModel:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaContentProcessing:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaDerivationMethod:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaDocumentation:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaElement:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaEnumerationFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaExternal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaForm:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroup:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroupBase:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaGroupRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaIdentityConstraint:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaImport:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaInclude:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaKey:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaKeyref:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaMinLengthFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaNotation:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaNumericFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaObject:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaParticle:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaPatternFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaRedefine:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSequence:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContent:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeList:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaUnique:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaUse:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__XmlSchemaXPath:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaSimpleType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaElement:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaXPath:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__HierarchyInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__HierarchyInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__AxisInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__AxisInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cube:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Cube * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Cube * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Members:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Members * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Members * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Member:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Member * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Member * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Tuple:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Tuple * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Tuple * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Axis:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Axis * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Axis * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cell:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__Cell * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__Cell * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__HierarchyInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__HierarchyInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__AxisInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__AxisInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cube:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Cube * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Cube * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Members:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Members * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Members * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Member:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Member * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Member * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Tuple:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Tuple * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Tuple * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Axis:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Axis * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Axis * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cell:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__Cell * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__Cell * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__HierarchyInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__HierarchyInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__HierarchyInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AxisInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__AxisInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__AxisInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cube:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Cube * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Cube * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Members:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Members * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Members * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Member:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Member * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Member * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Tuple:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Tuple * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Tuple * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Axis:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Axis * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Axis * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cell:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Cell * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Cell * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaSimpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaXPath:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HierarchyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__HierarchyInfo * >*)p)[len] = *(ns5__HierarchyInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__AxisInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__AxisInfo * >*)p)[len] = *(ns5__AxisInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cube:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Cube * >*)p)[len] = *(ns5__Cube **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Members:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Members * >*)p)[len] = *(ns5__Members **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Member:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Member * >*)p)[len] = *(ns5__Member **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Tuple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Tuple * >*)p)[len] = *(ns5__Tuple **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Axis:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Axis * >*)p)[len] = *(ns5__Axis **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cell:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__Cell * >*)p)[len] = *(ns5__Cell **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__HierarchyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__HierarchyInfo * >*)p)[len] = *(ns4__HierarchyInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AxisInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__AxisInfo * >*)p)[len] = *(ns4__AxisInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cube:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Cube * >*)p)[len] = *(ns4__Cube **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Members:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Members * >*)p)[len] = *(ns4__Members **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Member:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Member * >*)p)[len] = *(ns4__Member **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Tuple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Tuple * >*)p)[len] = *(ns4__Tuple **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Axis:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Axis * >*)p)[len] = *(ns4__Axis **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cell:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__Cell * >*)p)[len] = *(ns4__Cell **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__HierarchyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__HierarchyInfo * >*)p)[len] = *(ns2__HierarchyInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AxisInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__AxisInfo * >*)p)[len] = *(ns2__AxisInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cube:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Cube * >*)p)[len] = *(ns2__Cube **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Members:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Members * >*)p)[len] = *(ns2__Members **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Member:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Member * >*)p)[len] = *(ns2__Member **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Tuple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Tuple * >*)p)[len] = *(ns2__Tuple **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Axis:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Axis * >*)p)[len] = *(ns2__Axis **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cell:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Cell * >*)p)[len] = *(ns2__Cell **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__XmlSchemaUse(struct soap *soap, enum ns3__XmlSchemaUse *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__XmlSchemaUse
	*a = SOAP_DEFAULT_ns3__XmlSchemaUse;
#else
	*a = (enum ns3__XmlSchemaUse)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__XmlSchemaUse[] =
{	{ (long)ns3__XmlSchemaUse__optional, "optional" },
	{ (long)ns3__XmlSchemaUse__prohibited, "prohibited" },
	{ (long)ns3__XmlSchemaUse__required, "required" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__XmlSchemaUse2s(struct soap *soap, enum ns3__XmlSchemaUse n)
{	const char *s = soap_code_str(soap_codes_ns3__XmlSchemaUse, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaUse(struct soap *soap, const char *tag, int id, const enum ns3__XmlSchemaUse *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaUse), type) || soap_send(soap, soap_ns3__XmlSchemaUse2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__XmlSchemaUse(struct soap *soap, const char *s, enum ns3__XmlSchemaUse *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__XmlSchemaUse, s);
	if (map)
		*a = (enum ns3__XmlSchemaUse)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__XmlSchemaUse)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__XmlSchemaUse * SOAP_FMAC4 soap_in_ns3__XmlSchemaUse(struct soap *soap, const char *tag, enum ns3__XmlSchemaUse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__XmlSchemaUse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaUse, sizeof(enum ns3__XmlSchemaUse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__XmlSchemaUse(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__XmlSchemaUse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaUse, 0, sizeof(enum ns3__XmlSchemaUse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__XmlSchemaUse(struct soap *soap, const enum ns3__XmlSchemaUse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaUse);
	if (soap_out_ns3__XmlSchemaUse(soap, tag?tag:"ns3:XmlSchemaUse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__XmlSchemaUse * SOAP_FMAC4 soap_get_ns3__XmlSchemaUse(struct soap *soap, enum ns3__XmlSchemaUse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaUse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__XmlSchemaContentProcessing(struct soap *soap, enum ns3__XmlSchemaContentProcessing *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__XmlSchemaContentProcessing
	*a = SOAP_DEFAULT_ns3__XmlSchemaContentProcessing;
#else
	*a = (enum ns3__XmlSchemaContentProcessing)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__XmlSchemaContentProcessing[] =
{	{ (long)ns3__XmlSchemaContentProcessing__skip, "skip" },
	{ (long)ns3__XmlSchemaContentProcessing__lax, "lax" },
	{ (long)ns3__XmlSchemaContentProcessing__strict, "strict" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__XmlSchemaContentProcessing2s(struct soap *soap, enum ns3__XmlSchemaContentProcessing n)
{	const char *s = soap_code_str(soap_codes_ns3__XmlSchemaContentProcessing, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaContentProcessing(struct soap *soap, const char *tag, int id, const enum ns3__XmlSchemaContentProcessing *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaContentProcessing), type) || soap_send(soap, soap_ns3__XmlSchemaContentProcessing2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__XmlSchemaContentProcessing(struct soap *soap, const char *s, enum ns3__XmlSchemaContentProcessing *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__XmlSchemaContentProcessing, s);
	if (map)
		*a = (enum ns3__XmlSchemaContentProcessing)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__XmlSchemaContentProcessing)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__XmlSchemaContentProcessing * SOAP_FMAC4 soap_in_ns3__XmlSchemaContentProcessing(struct soap *soap, const char *tag, enum ns3__XmlSchemaContentProcessing *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__XmlSchemaContentProcessing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaContentProcessing, sizeof(enum ns3__XmlSchemaContentProcessing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__XmlSchemaContentProcessing(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__XmlSchemaContentProcessing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaContentProcessing, 0, sizeof(enum ns3__XmlSchemaContentProcessing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__XmlSchemaContentProcessing(struct soap *soap, const enum ns3__XmlSchemaContentProcessing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaContentProcessing);
	if (soap_out_ns3__XmlSchemaContentProcessing(soap, tag?tag:"ns3:XmlSchemaContentProcessing", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__XmlSchemaContentProcessing * SOAP_FMAC4 soap_get_ns3__XmlSchemaContentProcessing(struct soap *soap, enum ns3__XmlSchemaContentProcessing *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaContentProcessing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__XmlSchemaForm(struct soap *soap, enum ns3__XmlSchemaForm *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__XmlSchemaForm
	*a = SOAP_DEFAULT_ns3__XmlSchemaForm;
#else
	*a = (enum ns3__XmlSchemaForm)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__XmlSchemaForm[] =
{	{ (long)ns3__XmlSchemaForm__qualified, "qualified" },
	{ (long)ns3__XmlSchemaForm__unqualified, "unqualified" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__XmlSchemaForm2s(struct soap *soap, enum ns3__XmlSchemaForm n)
{	const char *s = soap_code_str(soap_codes_ns3__XmlSchemaForm, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaForm(struct soap *soap, const char *tag, int id, const enum ns3__XmlSchemaForm *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaForm), type) || soap_send(soap, soap_ns3__XmlSchemaForm2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__XmlSchemaForm(struct soap *soap, const char *s, enum ns3__XmlSchemaForm *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__XmlSchemaForm, s);
	if (map)
		*a = (enum ns3__XmlSchemaForm)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__XmlSchemaForm)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__XmlSchemaForm * SOAP_FMAC4 soap_in_ns3__XmlSchemaForm(struct soap *soap, const char *tag, enum ns3__XmlSchemaForm *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__XmlSchemaForm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaForm, sizeof(enum ns3__XmlSchemaForm), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__XmlSchemaForm(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__XmlSchemaForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaForm, 0, sizeof(enum ns3__XmlSchemaForm), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__XmlSchemaForm(struct soap *soap, const enum ns3__XmlSchemaForm *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaForm);
	if (soap_out_ns3__XmlSchemaForm(soap, tag?tag:"ns3:XmlSchemaForm", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__XmlSchemaForm * SOAP_FMAC4 soap_get_ns3__XmlSchemaForm(struct soap *soap, enum ns3__XmlSchemaForm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaForm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__XmlSchemaDerivationMethod(struct soap *soap, enum ns3__XmlSchemaDerivationMethod *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__XmlSchemaDerivationMethod
	*a = SOAP_DEFAULT_ns3__XmlSchemaDerivationMethod;
#else
	*a = (enum ns3__XmlSchemaDerivationMethod)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__XmlSchemaDerivationMethod[] =
{	{ (long)ns3__XmlSchemaDerivationMethod___x0000, "" },
	{ (long)ns3__XmlSchemaDerivationMethod__substitution, "substitution" },
	{ (long)ns3__XmlSchemaDerivationMethod__extension, "extension" },
	{ (long)ns3__XmlSchemaDerivationMethod__restriction, "restriction" },
	{ (long)ns3__XmlSchemaDerivationMethod__list, "list" },
	{ (long)ns3__XmlSchemaDerivationMethod__union_, "union" },
	{ (long)ns3__XmlSchemaDerivationMethod___x0023all, "#all" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__XmlSchemaDerivationMethod2s(struct soap *soap, enum ns3__XmlSchemaDerivationMethod n)
{
	return soap_code_list(soap, soap_codes_ns3__XmlSchemaDerivationMethod, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, int id, const enum ns3__XmlSchemaDerivationMethod *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaDerivationMethod), type) || soap_send(soap, soap_ns3__XmlSchemaDerivationMethod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__XmlSchemaDerivationMethod(struct soap *soap, const char *s, enum ns3__XmlSchemaDerivationMethod *a)
{
	*a = (enum ns3__XmlSchemaDerivationMethod)soap_code_bits(soap_codes_ns3__XmlSchemaDerivationMethod, s);
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__XmlSchemaDerivationMethod * SOAP_FMAC4 soap_in_ns3__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, enum ns3__XmlSchemaDerivationMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__XmlSchemaDerivationMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaDerivationMethod, sizeof(enum ns3__XmlSchemaDerivationMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__XmlSchemaDerivationMethod(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__XmlSchemaDerivationMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaDerivationMethod, 0, sizeof(enum ns3__XmlSchemaDerivationMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__XmlSchemaDerivationMethod(struct soap *soap, const enum ns3__XmlSchemaDerivationMethod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaDerivationMethod);
	if (soap_out_ns3__XmlSchemaDerivationMethod(soap, tag?tag:"ns3:XmlSchemaDerivationMethod", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__XmlSchemaDerivationMethod * SOAP_FMAC4 soap_get_ns3__XmlSchemaDerivationMethod(struct soap *soap, enum ns3__XmlSchemaDerivationMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaDerivationMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __ns3__union_XmlSchemaRedefine::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaRedefine::group = NULL;
	this->__ns3__union_XmlSchemaRedefine::annotation = NULL;
	this->__ns3__union_XmlSchemaRedefine::complexType = NULL;
	this->__ns3__union_XmlSchemaRedefine::simpleType = NULL;
	this->__ns3__union_XmlSchemaRedefine::attributeGroup = NULL;
}

void __ns3__union_XmlSchemaRedefine::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaGroup(soap, &this->__ns3__union_XmlSchemaRedefine::group);
	soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, &this->__ns3__union_XmlSchemaRedefine::annotation);
	soap_serialize_PointerToxsd__XmlSchemaComplexType(soap, &this->__ns3__union_XmlSchemaRedefine::complexType);
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->__ns3__union_XmlSchemaRedefine::simpleType);
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroup(soap, &this->__ns3__union_XmlSchemaRedefine::attributeGroup);
#endif
}

int __ns3__union_XmlSchemaRedefine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaRedefine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaRedefine(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaRedefine *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaGroup(soap, "ns3:group", -1, &(a->__ns3__union_XmlSchemaRedefine::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", -1, &(a->__ns3__union_XmlSchemaRedefine::annotation), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", -1, &(a->__ns3__union_XmlSchemaRedefine::complexType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->__ns3__union_XmlSchemaRedefine::simpleType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroup(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaRedefine::attributeGroup), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaRedefine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaRedefine(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaRedefine * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaRedefine(struct soap *soap, const char *tag, __ns3__union_XmlSchemaRedefine *a, const char *type)
{
	a = (__ns3__union_XmlSchemaRedefine *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaRedefine, sizeof(__ns3__union_XmlSchemaRedefine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_group1 = 1;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_complexType1 = 1;
	size_t soap_flag_simpleType1 = 1;
	size_t soap_flag_attributeGroup1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroup(soap, "ns3:group", &(a->__ns3__union_XmlSchemaRedefine::group), "xsd:XmlSchemaGroup"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_annotation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", &(a->__ns3__union_XmlSchemaRedefine::annotation), "xsd:XmlSchemaAnnotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			if (soap_flag_complexType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", &(a->__ns3__union_XmlSchemaRedefine::complexType), "xsd:XmlSchemaComplexType"))
				{	soap_flag_complexType1--;
					continue;
				}
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->__ns3__union_XmlSchemaRedefine::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroup(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaRedefine::attributeGroup), "xsd:XmlSchemaAttributeGroup"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaRedefine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaRedefine", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaRedefine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaRedefine(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaRedefine * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaRedefine(struct soap *soap, __ns3__union_XmlSchemaRedefine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaRedefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaRedefine * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaRedefine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaRedefine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaRedefine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaRedefine);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaRedefine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaRedefine, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaRedefine);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaRedefine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaRedefine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaRedefine %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaRedefine*)p = *(__ns3__union_XmlSchemaRedefine*)q;
}

void __ns3__union_XmlSchemaSimpleTypeRestriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxExclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::minInclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxInclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::minExclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::minLength = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxLength = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::pattern = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::enumeration = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::length = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::whiteSpace = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::totalDigits = NULL;
	this->__ns3__union_XmlSchemaSimpleTypeRestriction::fractionDigits = NULL;
}

void __ns3__union_XmlSchemaSimpleTypeRestriction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxExclusive);
	soap_serialize_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::minInclusive);
	soap_serialize_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxInclusive);
	soap_serialize_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::minExclusive);
	soap_serialize_PointerToxsd__XmlSchemaMinLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::minLength);
	soap_serialize_PointerToxsd__XmlSchemaMaxLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::maxLength);
	soap_serialize_PointerToxsd__XmlSchemaPatternFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::pattern);
	soap_serialize_PointerToxsd__XmlSchemaEnumerationFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::enumeration);
	soap_serialize_PointerToxsd__XmlSchemaLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::length);
	soap_serialize_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::whiteSpace);
	soap_serialize_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::totalDigits);
	soap_serialize_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, &this->__ns3__union_XmlSchemaSimpleTypeRestriction::fractionDigits);
#endif
}

int __ns3__union_XmlSchemaSimpleTypeRestriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaSimpleTypeRestriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaSimpleTypeRestriction *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, "ns3:maxExclusive", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxExclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, "ns3:minInclusive", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minInclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, "ns3:maxInclusive", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxInclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, "ns3:minExclusive", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minExclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMinLengthFacet(soap, "ns3:minLength", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minLength), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMaxLengthFacet(soap, "ns3:maxLength", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxLength), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaPatternFacet(soap, "ns3:pattern", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::pattern), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaEnumerationFacet(soap, "ns3:enumeration", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::enumeration), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaLengthFacet(soap, "ns3:length", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::length), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, "ns3:whiteSpace", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::whiteSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, "ns3:totalDigits", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::totalDigits), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, "ns3:fractionDigits", -1, &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::fractionDigits), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleTypeRestriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaSimpleTypeRestriction(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleTypeRestriction * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleTypeRestriction *a, const char *type)
{
	a = (__ns3__union_XmlSchemaSimpleTypeRestriction *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction, sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_maxExclusive1 = 1;
	size_t soap_flag_minInclusive1 = 1;
	size_t soap_flag_maxInclusive1 = 1;
	size_t soap_flag_minExclusive1 = 1;
	size_t soap_flag_minLength1 = 1;
	size_t soap_flag_maxLength1 = 1;
	size_t soap_flag_pattern1 = 1;
	size_t soap_flag_enumeration1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_whiteSpace1 = 1;
	size_t soap_flag_totalDigits1 = 1;
	size_t soap_flag_fractionDigits1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_maxExclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, "ns3:maxExclusive", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxExclusive), "xsd:XmlSchemaMaxExclusiveFacet"))
				{	soap_flag_maxExclusive1--;
					continue;
				}
			if (soap_flag_minInclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, "ns3:minInclusive", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minInclusive), "xsd:XmlSchemaMinInclusiveFacet"))
				{	soap_flag_minInclusive1--;
					continue;
				}
			if (soap_flag_maxInclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, "ns3:maxInclusive", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxInclusive), "xsd:XmlSchemaMaxInclusiveFacet"))
				{	soap_flag_maxInclusive1--;
					continue;
				}
			if (soap_flag_minExclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, "ns3:minExclusive", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minExclusive), "xsd:XmlSchemaMinExclusiveFacet"))
				{	soap_flag_minExclusive1--;
					continue;
				}
			if (soap_flag_minLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinLengthFacet(soap, "ns3:minLength", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::minLength), "xsd:XmlSchemaMinLengthFacet"))
				{	soap_flag_minLength1--;
					continue;
				}
			if (soap_flag_maxLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxLengthFacet(soap, "ns3:maxLength", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::maxLength), "xsd:XmlSchemaMaxLengthFacet"))
				{	soap_flag_maxLength1--;
					continue;
				}
			if (soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaPatternFacet(soap, "ns3:pattern", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::pattern), "xsd:XmlSchemaPatternFacet"))
				{	soap_flag_pattern1--;
					continue;
				}
			if (soap_flag_enumeration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaEnumerationFacet(soap, "ns3:enumeration", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::enumeration), "xsd:XmlSchemaEnumerationFacet"))
				{	soap_flag_enumeration1--;
					continue;
				}
			if (soap_flag_length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaLengthFacet(soap, "ns3:length", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::length), "xsd:XmlSchemaLengthFacet"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_whiteSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, "ns3:whiteSpace", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::whiteSpace), "xsd:XmlSchemaWhiteSpaceFacet"))
				{	soap_flag_whiteSpace1--;
					continue;
				}
			if (soap_flag_totalDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, "ns3:totalDigits", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::totalDigits), "xsd:XmlSchemaTotalDigitsFacet"))
				{	soap_flag_totalDigits1--;
					continue;
				}
			if (soap_flag_fractionDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, "ns3:fractionDigits", &(a->__ns3__union_XmlSchemaSimpleTypeRestriction::fractionDigits), "xsd:XmlSchemaFractionDigitsFacet"))
				{	soap_flag_fractionDigits1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaSimpleTypeRestriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaSimpleTypeRestriction", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleTypeRestriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaSimpleTypeRestriction(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleTypeRestriction * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleTypeRestriction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaSimpleTypeRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaSimpleTypeRestriction * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaSimpleTypeRestriction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaSimpleTypeRestriction);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaSimpleTypeRestriction, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaSimpleTypeRestriction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaSimpleTypeRestriction %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaSimpleTypeRestriction*)p = *(__ns3__union_XmlSchemaSimpleTypeRestriction*)q;
}

void __ns3__union_XmlSchemaSimpleContentRestriction_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaSimpleContentRestriction_::attributeGroup = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction_::attribute = NULL;
}

void __ns3__union_XmlSchemaSimpleContentRestriction_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction_::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction_::attribute);
#endif
}

int __ns3__union_XmlSchemaSimpleContentRestriction_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaSimpleContentRestriction_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaSimpleContentRestriction_ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction_::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction_::attribute), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentRestriction_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaSimpleContentRestriction_(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction_ * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentRestriction_ *a, const char *type)
{
	a = (__ns3__union_XmlSchemaSimpleContentRestriction_ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_attribute1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaSimpleContentRestriction_::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaSimpleContentRestriction_::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaSimpleContentRestriction_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentRestriction", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentRestriction_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaSimpleContentRestriction_(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction_ * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaSimpleContentRestriction_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaSimpleContentRestriction_ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaSimpleContentRestriction_);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaSimpleContentRestriction_, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaSimpleContentRestriction_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaSimpleContentRestriction_ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaSimpleContentRestriction_*)p = *(__ns3__union_XmlSchemaSimpleContentRestriction_*)q;
}

void __ns3__union_XmlSchemaSimpleContentRestriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaSimpleContentRestriction::minExclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::enumeration = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::maxInclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::length = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::minLength = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::maxLength = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::pattern = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::maxExclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::minInclusive = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::whiteSpace = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::totalDigits = NULL;
	this->__ns3__union_XmlSchemaSimpleContentRestriction::fractionDigits = NULL;
}

void __ns3__union_XmlSchemaSimpleContentRestriction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::minExclusive);
	soap_serialize_PointerToxsd__XmlSchemaEnumerationFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::enumeration);
	soap_serialize_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::maxInclusive);
	soap_serialize_PointerToxsd__XmlSchemaLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::length);
	soap_serialize_PointerToxsd__XmlSchemaMinLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::minLength);
	soap_serialize_PointerToxsd__XmlSchemaMaxLengthFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::maxLength);
	soap_serialize_PointerToxsd__XmlSchemaPatternFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::pattern);
	soap_serialize_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::maxExclusive);
	soap_serialize_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::minInclusive);
	soap_serialize_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::whiteSpace);
	soap_serialize_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::totalDigits);
	soap_serialize_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, &this->__ns3__union_XmlSchemaSimpleContentRestriction::fractionDigits);
#endif
}

int __ns3__union_XmlSchemaSimpleContentRestriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaSimpleContentRestriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaSimpleContentRestriction *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, "ns3:minExclusive", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minExclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaEnumerationFacet(soap, "ns3:enumeration", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::enumeration), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, "ns3:maxInclusive", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxInclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaLengthFacet(soap, "ns3:length", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::length), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMinLengthFacet(soap, "ns3:minLength", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minLength), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMaxLengthFacet(soap, "ns3:maxLength", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxLength), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaPatternFacet(soap, "ns3:pattern", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::pattern), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, "ns3:maxExclusive", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxExclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, "ns3:minInclusive", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minInclusive), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, "ns3:whiteSpace", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::whiteSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, "ns3:totalDigits", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::totalDigits), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, "ns3:fractionDigits", -1, &(a->__ns3__union_XmlSchemaSimpleContentRestriction::fractionDigits), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentRestriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaSimpleContentRestriction(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentRestriction *a, const char *type)
{
	a = (__ns3__union_XmlSchemaSimpleContentRestriction *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_minExclusive1 = 1;
	size_t soap_flag_enumeration1 = 1;
	size_t soap_flag_maxInclusive1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_minLength1 = 1;
	size_t soap_flag_maxLength1 = 1;
	size_t soap_flag_pattern1 = 1;
	size_t soap_flag_maxExclusive1 = 1;
	size_t soap_flag_minInclusive1 = 1;
	size_t soap_flag_whiteSpace1 = 1;
	size_t soap_flag_totalDigits1 = 1;
	size_t soap_flag_fractionDigits1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_minExclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, "ns3:minExclusive", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minExclusive), "xsd:XmlSchemaMinExclusiveFacet"))
				{	soap_flag_minExclusive1--;
					continue;
				}
			if (soap_flag_enumeration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaEnumerationFacet(soap, "ns3:enumeration", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::enumeration), "xsd:XmlSchemaEnumerationFacet"))
				{	soap_flag_enumeration1--;
					continue;
				}
			if (soap_flag_maxInclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, "ns3:maxInclusive", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxInclusive), "xsd:XmlSchemaMaxInclusiveFacet"))
				{	soap_flag_maxInclusive1--;
					continue;
				}
			if (soap_flag_length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaLengthFacet(soap, "ns3:length", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::length), "xsd:XmlSchemaLengthFacet"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_minLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinLengthFacet(soap, "ns3:minLength", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minLength), "xsd:XmlSchemaMinLengthFacet"))
				{	soap_flag_minLength1--;
					continue;
				}
			if (soap_flag_maxLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxLengthFacet(soap, "ns3:maxLength", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxLength), "xsd:XmlSchemaMaxLengthFacet"))
				{	soap_flag_maxLength1--;
					continue;
				}
			if (soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaPatternFacet(soap, "ns3:pattern", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::pattern), "xsd:XmlSchemaPatternFacet"))
				{	soap_flag_pattern1--;
					continue;
				}
			if (soap_flag_maxExclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, "ns3:maxExclusive", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::maxExclusive), "xsd:XmlSchemaMaxExclusiveFacet"))
				{	soap_flag_maxExclusive1--;
					continue;
				}
			if (soap_flag_minInclusive1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, "ns3:minInclusive", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::minInclusive), "xsd:XmlSchemaMinInclusiveFacet"))
				{	soap_flag_minInclusive1--;
					continue;
				}
			if (soap_flag_whiteSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, "ns3:whiteSpace", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::whiteSpace), "xsd:XmlSchemaWhiteSpaceFacet"))
				{	soap_flag_whiteSpace1--;
					continue;
				}
			if (soap_flag_totalDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, "ns3:totalDigits", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::totalDigits), "xsd:XmlSchemaTotalDigitsFacet"))
				{	soap_flag_totalDigits1--;
					continue;
				}
			if (soap_flag_fractionDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, "ns3:fractionDigits", &(a->__ns3__union_XmlSchemaSimpleContentRestriction::fractionDigits), "xsd:XmlSchemaFractionDigitsFacet"))
				{	soap_flag_fractionDigits1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaSimpleContentRestriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentRestriction", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentRestriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaSimpleContentRestriction(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaSimpleContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaSimpleContentRestriction * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaSimpleContentRestriction);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaSimpleContentRestriction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaSimpleContentRestriction, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaSimpleContentRestriction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaSimpleContentRestriction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaSimpleContentRestriction %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaSimpleContentRestriction*)p = *(__ns3__union_XmlSchemaSimpleContentRestriction*)q;
}

void __ns3__union_XmlSchemaSimpleContentExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaSimpleContentExtension::attribute = NULL;
	this->__ns3__union_XmlSchemaSimpleContentExtension::attributeGroup = NULL;
}

void __ns3__union_XmlSchemaSimpleContentExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaSimpleContentExtension::attribute);
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaSimpleContentExtension::attributeGroup);
#endif
}

int __ns3__union_XmlSchemaSimpleContentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaSimpleContentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaSimpleContentExtension *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaSimpleContentExtension::attribute), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaSimpleContentExtension::attributeGroup), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaSimpleContentExtension(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentExtension * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentExtension *a, const char *type)
{
	a = (__ns3__union_XmlSchemaSimpleContentExtension *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension, sizeof(__ns3__union_XmlSchemaSimpleContentExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attribute1 = 1;
	size_t soap_flag_attributeGroup1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaSimpleContentExtension::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaSimpleContentExtension::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaSimpleContentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentExtension", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSimpleContentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaSimpleContentExtension(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentExtension * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, __ns3__union_XmlSchemaSimpleContentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaSimpleContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaSimpleContentExtension * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaSimpleContentExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaSimpleContentExtension);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaSimpleContentExtension);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaSimpleContentExtension, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaSimpleContentExtension);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaSimpleContentExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaSimpleContentExtension %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaSimpleContentExtension*)p = *(__ns3__union_XmlSchemaSimpleContentExtension*)q;
}

void __ns3__union_XmlSchemaSequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaSequence::group = NULL;
	this->__ns3__union_XmlSchemaSequence::any = NULL;
	this->__ns3__union_XmlSchemaSequence::sequence = NULL;
	this->__ns3__union_XmlSchemaSequence::element = NULL;
	this->__ns3__union_XmlSchemaSequence::choice = NULL;
}

void __ns3__union_XmlSchemaSequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, &this->__ns3__union_XmlSchemaSequence::group);
	soap_serialize_PointerToxsd__XmlSchemaAny(soap, &this->__ns3__union_XmlSchemaSequence::any);
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->__ns3__union_XmlSchemaSequence::sequence);
	soap_serialize_PointerToxsd__XmlSchemaElement(soap, &this->__ns3__union_XmlSchemaSequence::element);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->__ns3__union_XmlSchemaSequence::choice);
#endif
}

int __ns3__union_XmlSchemaSequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaSequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaSequence(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaSequence *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", -1, &(a->__ns3__union_XmlSchemaSequence::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAny(soap, "ns3:any", -1, &(a->__ns3__union_XmlSchemaSequence::any), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->__ns3__union_XmlSchemaSequence::sequence), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaElement(soap, "ns3:element", -1, &(a->__ns3__union_XmlSchemaSequence::element), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->__ns3__union_XmlSchemaSequence::choice), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaSequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSequence * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaSequence(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSequence *a, const char *type)
{
	a = (__ns3__union_XmlSchemaSequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaSequence, sizeof(__ns3__union_XmlSchemaSequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_group1 = 1;
	size_t soap_flag_any1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_element1 = 1;
	size_t soap_flag_choice1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", &(a->__ns3__union_XmlSchemaSequence::group), "xsd:XmlSchemaGroupRef"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAny(soap, "ns3:any", &(a->__ns3__union_XmlSchemaSequence::any), "xsd:XmlSchemaAny"))
				{	soap_flag_any1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->__ns3__union_XmlSchemaSequence::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_element1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaElement(soap, "ns3:element", &(a->__ns3__union_XmlSchemaSequence::element), "xsd:XmlSchemaElement"))
				{	soap_flag_element1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->__ns3__union_XmlSchemaSequence::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaSequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaSequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaSequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaSequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSequence * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaSequence(struct soap *soap, __ns3__union_XmlSchemaSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaSequence * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaSequence);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaSequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaSequence, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaSequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaSequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaSequence %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaSequence*)p = *(__ns3__union_XmlSchemaSequence*)q;
}

void __ns3__union_XmlSchemaChoice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaChoice::any = NULL;
	this->__ns3__union_XmlSchemaChoice::choice = NULL;
	this->__ns3__union_XmlSchemaChoice::sequence = NULL;
	this->__ns3__union_XmlSchemaChoice::element = NULL;
	this->__ns3__union_XmlSchemaChoice::group = NULL;
}

void __ns3__union_XmlSchemaChoice::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAny(soap, &this->__ns3__union_XmlSchemaChoice::any);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->__ns3__union_XmlSchemaChoice::choice);
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->__ns3__union_XmlSchemaChoice::sequence);
	soap_serialize_PointerToxsd__XmlSchemaElement(soap, &this->__ns3__union_XmlSchemaChoice::element);
	soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, &this->__ns3__union_XmlSchemaChoice::group);
#endif
}

int __ns3__union_XmlSchemaChoice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaChoice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaChoice(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaChoice *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAny(soap, "ns3:any", -1, &(a->__ns3__union_XmlSchemaChoice::any), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->__ns3__union_XmlSchemaChoice::choice), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->__ns3__union_XmlSchemaChoice::sequence), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaElement(soap, "ns3:element", -1, &(a->__ns3__union_XmlSchemaChoice::element), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", -1, &(a->__ns3__union_XmlSchemaChoice::group), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaChoice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaChoice(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaChoice * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaChoice(struct soap *soap, const char *tag, __ns3__union_XmlSchemaChoice *a, const char *type)
{
	a = (__ns3__union_XmlSchemaChoice *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaChoice, sizeof(__ns3__union_XmlSchemaChoice), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_any1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_element1 = 1;
	size_t soap_flag_group1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAny(soap, "ns3:any", &(a->__ns3__union_XmlSchemaChoice::any), "xsd:XmlSchemaAny"))
				{	soap_flag_any1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->__ns3__union_XmlSchemaChoice::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->__ns3__union_XmlSchemaChoice::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_element1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaElement(soap, "ns3:element", &(a->__ns3__union_XmlSchemaChoice::element), "xsd:XmlSchemaElement"))
				{	soap_flag_element1--;
					continue;
				}
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", &(a->__ns3__union_XmlSchemaChoice::group), "xsd:XmlSchemaGroupRef"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaChoice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaChoice", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaChoice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaChoice(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaChoice * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaChoice(struct soap *soap, __ns3__union_XmlSchemaChoice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaChoice * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaChoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaChoice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaChoice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaChoice);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaChoice);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaChoice, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaChoice);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaChoice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaChoice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaChoice %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaChoice*)p = *(__ns3__union_XmlSchemaChoice*)q;
}

void __ns3__union_XmlSchemaElement_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaElement_::unique = NULL;
	this->__ns3__union_XmlSchemaElement_::key = NULL;
	this->__ns3__union_XmlSchemaElement_::keyref = NULL;
}

void __ns3__union_XmlSchemaElement_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaUnique(soap, &this->__ns3__union_XmlSchemaElement_::unique);
	soap_serialize_PointerToxsd__XmlSchemaKey(soap, &this->__ns3__union_XmlSchemaElement_::key);
	soap_serialize_PointerToxsd__XmlSchemaKeyref(soap, &this->__ns3__union_XmlSchemaElement_::keyref);
#endif
}

int __ns3__union_XmlSchemaElement_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaElement_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaElement_(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaElement_ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaUnique(soap, "ns3:unique", -1, &(a->__ns3__union_XmlSchemaElement_::unique), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaKey(soap, "ns3:key", -1, &(a->__ns3__union_XmlSchemaElement_::key), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaKeyref(soap, "ns3:keyref", -1, &(a->__ns3__union_XmlSchemaElement_::keyref), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaElement_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaElement_(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaElement_ * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaElement_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaElement_ *a, const char *type)
{
	a = (__ns3__union_XmlSchemaElement_ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaElement_, sizeof(__ns3__union_XmlSchemaElement_), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_unique1 = 1;
	size_t soap_flag_key1 = 1;
	size_t soap_flag_keyref1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unique1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaUnique(soap, "ns3:unique", &(a->__ns3__union_XmlSchemaElement_::unique), "xsd:XmlSchemaUnique"))
				{	soap_flag_unique1--;
					continue;
				}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaKey(soap, "ns3:key", &(a->__ns3__union_XmlSchemaElement_::key), "xsd:XmlSchemaKey"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_keyref1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaKeyref(soap, "ns3:keyref", &(a->__ns3__union_XmlSchemaElement_::keyref), "xsd:XmlSchemaKeyref"))
				{	soap_flag_keyref1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaElement_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaElement", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaElement_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaElement_(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaElement_ * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaElement_(struct soap *soap, __ns3__union_XmlSchemaElement_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaElement_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaElement_ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaElement_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaElement_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaElement_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaElement_);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaElement_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaElement_, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaElement_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaElement_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaElement_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaElement_ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaElement_*)p = *(__ns3__union_XmlSchemaElement_*)q;
}

void __ns3__union_XmlSchemaComplexContentExtension_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaComplexContentExtension_::attributeGroup = NULL;
	this->__ns3__union_XmlSchemaComplexContentExtension_::attribute = NULL;
}

void __ns3__union_XmlSchemaComplexContentExtension_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaComplexContentExtension_::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaComplexContentExtension_::attribute);
#endif
}

int __ns3__union_XmlSchemaComplexContentExtension_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaComplexContentExtension_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaComplexContentExtension_ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaComplexContentExtension_::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaComplexContentExtension_::attribute), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexContentExtension_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaComplexContentExtension_(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentExtension_ * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexContentExtension_ *a, const char *type)
{
	a = (__ns3__union_XmlSchemaComplexContentExtension_ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_, sizeof(__ns3__union_XmlSchemaComplexContentExtension_), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_attribute1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaComplexContentExtension_::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaComplexContentExtension_::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaComplexContentExtension_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaComplexContentExtension", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexContentExtension_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaComplexContentExtension_(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentExtension_ * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, __ns3__union_XmlSchemaComplexContentExtension_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaComplexContentExtension_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaComplexContentExtension_ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaComplexContentExtension_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaComplexContentExtension_);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaComplexContentExtension_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaComplexContentExtension_, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaComplexContentExtension_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaComplexContentExtension_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaComplexContentExtension_ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaComplexContentExtension_*)p = *(__ns3__union_XmlSchemaComplexContentExtension_*)q;
}

void __ns3__union_XmlSchemaComplexContentRestriction_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaComplexContentRestriction_::attributeGroup = NULL;
	this->__ns3__union_XmlSchemaComplexContentRestriction_::attribute = NULL;
}

void __ns3__union_XmlSchemaComplexContentRestriction_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaComplexContentRestriction_::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaComplexContentRestriction_::attribute);
#endif
}

int __ns3__union_XmlSchemaComplexContentRestriction_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaComplexContentRestriction_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaComplexContentRestriction_ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaComplexContentRestriction_::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaComplexContentRestriction_::attribute), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexContentRestriction_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaComplexContentRestriction_(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentRestriction_ * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexContentRestriction_ *a, const char *type)
{
	a = (__ns3__union_XmlSchemaComplexContentRestriction_ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_, sizeof(__ns3__union_XmlSchemaComplexContentRestriction_), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_attribute1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaComplexContentRestriction_::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaComplexContentRestriction_::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaComplexContentRestriction_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaComplexContentRestriction", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexContentRestriction_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaComplexContentRestriction_(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentRestriction_ * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaComplexContentRestriction_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaComplexContentRestriction_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaComplexContentRestriction_ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaComplexContentRestriction_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaComplexContentRestriction_);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaComplexContentRestriction_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaComplexContentRestriction_, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaComplexContentRestriction_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaComplexContentRestriction_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaComplexContentRestriction_ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaComplexContentRestriction_*)p = *(__ns3__union_XmlSchemaComplexContentRestriction_*)q;
}

void __ns3__union_XmlSchemaComplexType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaComplexType__::attributeGroup = NULL;
	this->__ns3__union_XmlSchemaComplexType__::attribute = NULL;
}

void __ns3__union_XmlSchemaComplexType__::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaComplexType__::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaComplexType__::attribute);
#endif
}

int __ns3__union_XmlSchemaComplexType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaComplexType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaComplexType__(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaComplexType__ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaComplexType__::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaComplexType__::attribute), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexType__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaComplexType__(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexType__ * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaComplexType__(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexType__ *a, const char *type)
{
	a = (__ns3__union_XmlSchemaComplexType__ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaComplexType__, sizeof(__ns3__union_XmlSchemaComplexType__), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_attribute1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaComplexType__::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaComplexType__::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaComplexType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaComplexType", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaComplexType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaComplexType__(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexType__ * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaComplexType__(struct soap *soap, __ns3__union_XmlSchemaComplexType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaComplexType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaComplexType__ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaComplexType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaComplexType__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaComplexType__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaComplexType__);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaComplexType__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaComplexType__, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaComplexType__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaComplexType__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaComplexType__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaComplexType__ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaComplexType__*)p = *(__ns3__union_XmlSchemaComplexType__*)q;
}

void __ns3__union_XmlSchemaAttributeGroup::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaAttributeGroup::attributeGroup = NULL;
	this->__ns3__union_XmlSchemaAttributeGroup::attribute = NULL;
}

void __ns3__union_XmlSchemaAttributeGroup::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(soap, &this->__ns3__union_XmlSchemaAttributeGroup::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchemaAttributeGroup::attribute);
#endif
}

int __ns3__union_XmlSchemaAttributeGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaAttributeGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaAttributeGroup(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaAttributeGroup *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchemaAttributeGroup::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchemaAttributeGroup::attribute), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaAttributeGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaAttributeGroup(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAttributeGroup * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaAttributeGroup(struct soap *soap, const char *tag, __ns3__union_XmlSchemaAttributeGroup *a, const char *type)
{
	a = (__ns3__union_XmlSchemaAttributeGroup *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup, sizeof(__ns3__union_XmlSchemaAttributeGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_attribute1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchemaAttributeGroup::attributeGroup), "xsd:XmlSchemaAttributeGroupRef"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchemaAttributeGroup::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaAttributeGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaAttributeGroup", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaAttributeGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaAttributeGroup(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAttributeGroup * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaAttributeGroup(struct soap *soap, __ns3__union_XmlSchemaAttributeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaAttributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaAttributeGroup * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaAttributeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaAttributeGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaAttributeGroup);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaAttributeGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaAttributeGroup, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaAttributeGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaAttributeGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaAttributeGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaAttributeGroup %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaAttributeGroup*)p = *(__ns3__union_XmlSchemaAttributeGroup*)q;
}

void __ns3__union_XmlSchemaAnnotation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchemaAnnotation::documentation = NULL;
	this->__ns3__union_XmlSchemaAnnotation::appinfo = NULL;
}

void __ns3__union_XmlSchemaAnnotation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaDocumentation(soap, &this->__ns3__union_XmlSchemaAnnotation::documentation);
	soap_serialize_PointerToxsd__XmlSchemaAppInfo(soap, &this->__ns3__union_XmlSchemaAnnotation::appinfo);
#endif
}

int __ns3__union_XmlSchemaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchemaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchemaAnnotation(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchemaAnnotation *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaDocumentation(soap, "ns3:documentation", -1, &(a->__ns3__union_XmlSchemaAnnotation::documentation), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAppInfo(soap, "ns3:appinfo", -1, &(a->__ns3__union_XmlSchemaAnnotation::appinfo), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchemaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAnnotation * SOAP_FMAC4 soap_in___ns3__union_XmlSchemaAnnotation(struct soap *soap, const char *tag, __ns3__union_XmlSchemaAnnotation *a, const char *type)
{
	a = (__ns3__union_XmlSchemaAnnotation *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchemaAnnotation, sizeof(__ns3__union_XmlSchemaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_appinfo1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaDocumentation(soap, "ns3:documentation", &(a->__ns3__union_XmlSchemaAnnotation::documentation), "xsd:XmlSchemaDocumentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			if (soap_flag_appinfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAppInfo(soap, "ns3:appinfo", &(a->__ns3__union_XmlSchemaAnnotation::appinfo), "xsd:XmlSchemaAppInfo"))
				{	soap_flag_appinfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchemaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchemaAnnotation", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchemaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchemaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAnnotation * SOAP_FMAC4 soap_get___ns3__union_XmlSchemaAnnotation(struct soap *soap, __ns3__union_XmlSchemaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchemaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchemaAnnotation * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchemaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchemaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchemaAnnotation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchemaAnnotation);
		if (size)
			*size = sizeof(__ns3__union_XmlSchemaAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchemaAnnotation, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchemaAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchemaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchemaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchemaAnnotation %p -> %p\n", q, p));
	*(__ns3__union_XmlSchemaAnnotation*)p = *(__ns3__union_XmlSchemaAnnotation*)q;
}

void __ns3__union_XmlSchema_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchema_::notation = NULL;
	this->__ns3__union_XmlSchema_::group = NULL;
	this->__ns3__union_XmlSchema_::annotation = NULL;
	this->__ns3__union_XmlSchema_::attribute = NULL;
	this->__ns3__union_XmlSchema_::attributeGroup = NULL;
	this->__ns3__union_XmlSchema_::complexType = NULL;
	this->__ns3__union_XmlSchema_::simpleType = NULL;
	this->__ns3__union_XmlSchema_::element = NULL;
}

void __ns3__union_XmlSchema_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaNotation(soap, &this->__ns3__union_XmlSchema_::notation);
	soap_serialize_PointerToxsd__XmlSchemaGroup(soap, &this->__ns3__union_XmlSchema_::group);
	soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, &this->__ns3__union_XmlSchema_::annotation);
	soap_serialize_PointerToxsd__XmlSchemaAttribute(soap, &this->__ns3__union_XmlSchema_::attribute);
	soap_serialize_PointerToxsd__XmlSchemaAttributeGroup(soap, &this->__ns3__union_XmlSchema_::attributeGroup);
	soap_serialize_PointerToxsd__XmlSchemaComplexType(soap, &this->__ns3__union_XmlSchema_::complexType);
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->__ns3__union_XmlSchema_::simpleType);
	soap_serialize_PointerToxsd__XmlSchemaElement(soap, &this->__ns3__union_XmlSchema_::element);
#endif
}

int __ns3__union_XmlSchema_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchema_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchema_(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchema_ *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaNotation(soap, "ns3:notation", -1, &(a->__ns3__union_XmlSchema_::notation), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaGroup(soap, "ns3:group", -1, &(a->__ns3__union_XmlSchema_::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", -1, &(a->__ns3__union_XmlSchema_::annotation), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", -1, &(a->__ns3__union_XmlSchema_::attribute), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroup(soap, "ns3:attributeGroup", -1, &(a->__ns3__union_XmlSchema_::attributeGroup), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", -1, &(a->__ns3__union_XmlSchema_::complexType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->__ns3__union_XmlSchema_::simpleType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaElement(soap, "ns3:element", -1, &(a->__ns3__union_XmlSchema_::element), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchema_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchema_(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema_ * SOAP_FMAC4 soap_in___ns3__union_XmlSchema_(struct soap *soap, const char *tag, __ns3__union_XmlSchema_ *a, const char *type)
{
	a = (__ns3__union_XmlSchema_ *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchema_, sizeof(__ns3__union_XmlSchema_), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_notation1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_attribute1 = 1;
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_complexType1 = 1;
	size_t soap_flag_simpleType1 = 1;
	size_t soap_flag_element1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_notation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaNotation(soap, "ns3:notation", &(a->__ns3__union_XmlSchema_::notation), "xsd:XmlSchemaNotation"))
				{	soap_flag_notation1--;
					continue;
				}
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroup(soap, "ns3:group", &(a->__ns3__union_XmlSchema_::group), "xsd:XmlSchemaGroup"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_annotation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", &(a->__ns3__union_XmlSchema_::annotation), "xsd:XmlSchemaAnnotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			if (soap_flag_attribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttribute(soap, "ns3:attribute", &(a->__ns3__union_XmlSchema_::attribute), "xsd:XmlSchemaAttribute"))
				{	soap_flag_attribute1--;
					continue;
				}
			if (soap_flag_attributeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAttributeGroup(soap, "ns3:attributeGroup", &(a->__ns3__union_XmlSchema_::attributeGroup), "xsd:XmlSchemaAttributeGroup"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			if (soap_flag_complexType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", &(a->__ns3__union_XmlSchema_::complexType), "xsd:XmlSchemaComplexType"))
				{	soap_flag_complexType1--;
					continue;
				}
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->__ns3__union_XmlSchema_::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap_flag_element1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaElement(soap, "ns3:element", &(a->__ns3__union_XmlSchema_::element), "xsd:XmlSchemaElement"))
				{	soap_flag_element1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchema_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchema", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchema_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchema_(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema_ * SOAP_FMAC4 soap_get___ns3__union_XmlSchema_(struct soap *soap, __ns3__union_XmlSchema_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchema_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchema_ * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchema_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchema_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchema_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchema_);
		if (size)
			*size = sizeof(__ns3__union_XmlSchema_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchema_, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchema_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchema_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchema_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchema_ %p -> %p\n", q, p));
	*(__ns3__union_XmlSchema_*)p = *(__ns3__union_XmlSchema_*)q;
}

void __ns3__union_XmlSchema::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns3__union_XmlSchema::include = NULL;
	this->__ns3__union_XmlSchema::redefine = NULL;
	this->__ns3__union_XmlSchema::import = NULL;
}

void __ns3__union_XmlSchema::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaInclude(soap, &this->__ns3__union_XmlSchema::include);
	soap_serialize_PointerToxsd__XmlSchemaRedefine(soap, &this->__ns3__union_XmlSchema::redefine);
	soap_serialize_PointerToxsd__XmlSchemaImport(soap, &this->__ns3__union_XmlSchema::import);
#endif
}

int __ns3__union_XmlSchema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns3__union_XmlSchema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__union_XmlSchema(struct soap *soap, const char *tag, int id, const __ns3__union_XmlSchema *a, const char *type)
{
	if (soap_out_PointerToxsd__XmlSchemaInclude(soap, "ns3:include", -1, &(a->__ns3__union_XmlSchema::include), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaRedefine(soap, "ns3:redefine", -1, &(a->__ns3__union_XmlSchema::redefine), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaImport(soap, "ns3:import", -1, &(a->__ns3__union_XmlSchema::import), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns3__union_XmlSchema(soap, tag, this, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema * SOAP_FMAC4 soap_in___ns3__union_XmlSchema(struct soap *soap, const char *tag, __ns3__union_XmlSchema *a, const char *type)
{
	a = (__ns3__union_XmlSchema *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns3__union_XmlSchema, sizeof(__ns3__union_XmlSchema), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_include1 = 1;
	size_t soap_flag_redefine1 = 1;
	size_t soap_flag_import1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_include1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaInclude(soap, "ns3:include", &(a->__ns3__union_XmlSchema::include), "xsd:XmlSchemaInclude"))
				{	soap_flag_include1--;
					continue;
				}
			if (soap_flag_redefine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaRedefine(soap, "ns3:redefine", &(a->__ns3__union_XmlSchema::redefine), "xsd:XmlSchemaRedefine"))
				{	soap_flag_redefine1--;
					continue;
				}
			if (soap_flag_import1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaImport(soap, "ns3:import", &(a->__ns3__union_XmlSchema::import), "xsd:XmlSchemaImport"))
				{	soap_flag_import1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns3__union_XmlSchema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns3:union-XmlSchema", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns3__union_XmlSchema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns3__union_XmlSchema(soap, this, tag, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema * SOAP_FMAC4 soap_get___ns3__union_XmlSchema(struct soap *soap, __ns3__union_XmlSchema *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__union_XmlSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns3__union_XmlSchema * SOAP_FMAC2 soap_instantiate___ns3__union_XmlSchema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__union_XmlSchema(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__union_XmlSchema, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns3__union_XmlSchema);
		if (size)
			*size = sizeof(__ns3__union_XmlSchema);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns3__union_XmlSchema, n);
		if (size)
			*size = n * sizeof(__ns3__union_XmlSchema);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns3__union_XmlSchema*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__union_XmlSchema(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns3__union_XmlSchema %p -> %p\n", q, p));
	*(__ns3__union_XmlSchema*)p = *(__ns3__union_XmlSchema*)q;
}

void __ns5__union_Axis::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns5__union_Axis::Tuples = NULL;
	this->__ns5__union_Axis::CrossProduct = NULL;
}

void __ns5__union_Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__Tuples(soap, &this->__ns5__union_Axis::Tuples);
	soap_serialize_PointerTons5__CrossProduct(soap, &this->__ns5__union_Axis::CrossProduct);
#endif
}

int __ns5__union_Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns5__union_Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__union_Axis(struct soap *soap, const char *tag, int id, const __ns5__union_Axis *a, const char *type)
{
	if (soap_out_PointerTons5__Tuples(soap, "ns5:Tuples", -1, &(a->__ns5__union_Axis::Tuples), ""))
		return soap->error;
	if (soap_out_PointerTons5__CrossProduct(soap, "ns5:CrossProduct", -1, &(a->__ns5__union_Axis::CrossProduct), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns5__union_Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns5__union_Axis(soap, tag, this, type);
}

SOAP_FMAC3 __ns5__union_Axis * SOAP_FMAC4 soap_in___ns5__union_Axis(struct soap *soap, const char *tag, __ns5__union_Axis *a, const char *type)
{
	a = (__ns5__union_Axis *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns5__union_Axis, sizeof(__ns5__union_Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_Tuples1 = 1;
	size_t soap_flag_CrossProduct1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tuples1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__Tuples(soap, "ns5:Tuples", &(a->__ns5__union_Axis::Tuples), "ns5:Tuples"))
				{	soap_flag_Tuples1--;
					continue;
				}
			if (soap_flag_CrossProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__CrossProduct(soap, "ns5:CrossProduct", &(a->__ns5__union_Axis::CrossProduct), "ns5:CrossProduct"))
				{	soap_flag_CrossProduct1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns5__union_Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns5:union-Axis", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns5__union_Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns5__union_Axis(soap, this, tag, type);
}

SOAP_FMAC3 __ns5__union_Axis * SOAP_FMAC4 soap_get___ns5__union_Axis(struct soap *soap, __ns5__union_Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns5__union_Axis * SOAP_FMAC2 soap_instantiate___ns5__union_Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__union_Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__union_Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns5__union_Axis);
		if (size)
			*size = sizeof(__ns5__union_Axis);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns5__union_Axis, n);
		if (size)
			*size = n * sizeof(__ns5__union_Axis);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns5__union_Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__union_Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns5__union_Axis %p -> %p\n", q, p));
	*(__ns5__union_Axis*)p = *(__ns5__union_Axis*)q;
}

void __ns5__union_ResultXmlRoot::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns5__union_ResultXmlRoot::CellData = NULL;
	this->__ns5__union_ResultXmlRoot::Axes = NULL;
	this->__ns5__union_ResultXmlRoot::row = NULL;
	this->__ns5__union_ResultXmlRoot::OlapInfo = NULL;
}

void __ns5__union_ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__CellData(soap, &this->__ns5__union_ResultXmlRoot::CellData);
	soap_serialize_PointerTons5__Axes(soap, &this->__ns5__union_ResultXmlRoot::Axes);
	soap_serialize_PointerTons5__Row(soap, &this->__ns5__union_ResultXmlRoot::row);
	soap_serialize_PointerTons5__OlapInfo(soap, &this->__ns5__union_ResultXmlRoot::OlapInfo);
#endif
}

int __ns5__union_ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns5__union_ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, const __ns5__union_ResultXmlRoot *a, const char *type)
{
	if (soap_out_PointerTons5__CellData(soap, "ns5:CellData", -1, &(a->__ns5__union_ResultXmlRoot::CellData), ""))
		return soap->error;
	if (soap_out_PointerTons5__Axes(soap, "ns5:Axes", -1, &(a->__ns5__union_ResultXmlRoot::Axes), ""))
		return soap->error;
	if (soap_out_PointerTons5__Row(soap, "ns5:row", -1, &(a->__ns5__union_ResultXmlRoot::row), ""))
		return soap->error;
	if (soap_out_PointerTons5__OlapInfo(soap, "ns5:OlapInfo", -1, &(a->__ns5__union_ResultXmlRoot::OlapInfo), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns5__union_ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns5__union_ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 __ns5__union_ResultXmlRoot * SOAP_FMAC4 soap_in___ns5__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns5__union_ResultXmlRoot *a, const char *type)
{
	a = (__ns5__union_ResultXmlRoot *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns5__union_ResultXmlRoot, sizeof(__ns5__union_ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_CellData1 = 1;
	size_t soap_flag_Axes1 = 1;
	size_t soap_flag_row1 = 1;
	size_t soap_flag_OlapInfo1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CellData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__CellData(soap, "ns5:CellData", &(a->__ns5__union_ResultXmlRoot::CellData), "ns5:CellData"))
				{	soap_flag_CellData1--;
					continue;
				}
			if (soap_flag_Axes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__Axes(soap, "ns5:Axes", &(a->__ns5__union_ResultXmlRoot::Axes), "ns5:Axes"))
				{	soap_flag_Axes1--;
					continue;
				}
			if (soap_flag_row1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__Row(soap, "ns5:row", &(a->__ns5__union_ResultXmlRoot::row), "ns5:Row"))
				{	soap_flag_row1--;
					continue;
				}
			if (soap_flag_OlapInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__OlapInfo(soap, "ns5:OlapInfo", &(a->__ns5__union_ResultXmlRoot::OlapInfo), "ns5:OlapInfo"))
				{	soap_flag_OlapInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns5__union_ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns5:union-ResultXmlRoot", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns5__union_ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns5__union_ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 __ns5__union_ResultXmlRoot * SOAP_FMAC4 soap_get___ns5__union_ResultXmlRoot(struct soap *soap, __ns5__union_ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns5__union_ResultXmlRoot * SOAP_FMAC2 soap_instantiate___ns5__union_ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__union_ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__union_ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns5__union_ResultXmlRoot);
		if (size)
			*size = sizeof(__ns5__union_ResultXmlRoot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns5__union_ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(__ns5__union_ResultXmlRoot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns5__union_ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__union_ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns5__union_ResultXmlRoot %p -> %p\n", q, p));
	*(__ns5__union_ResultXmlRoot*)p = *(__ns5__union_ResultXmlRoot*)q;
}

void __ns4__union_Axis::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns4__union_Axis::Tuples = NULL;
	this->__ns4__union_Axis::CrossProduct = NULL;
}

void __ns4__union_Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Tuples(soap, &this->__ns4__union_Axis::Tuples);
	soap_serialize_PointerTons4__CrossProduct(soap, &this->__ns4__union_Axis::CrossProduct);
#endif
}

int __ns4__union_Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns4__union_Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__union_Axis(struct soap *soap, const char *tag, int id, const __ns4__union_Axis *a, const char *type)
{
	if (soap_out_PointerTons4__Tuples(soap, "ns4:Tuples", -1, &(a->__ns4__union_Axis::Tuples), ""))
		return soap->error;
	if (soap_out_PointerTons4__CrossProduct(soap, "ns4:CrossProduct", -1, &(a->__ns4__union_Axis::CrossProduct), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__union_Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns4__union_Axis(soap, tag, this, type);
}

SOAP_FMAC3 __ns4__union_Axis * SOAP_FMAC4 soap_in___ns4__union_Axis(struct soap *soap, const char *tag, __ns4__union_Axis *a, const char *type)
{
	a = (__ns4__union_Axis *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns4__union_Axis, sizeof(__ns4__union_Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_Tuples1 = 1;
	size_t soap_flag_CrossProduct1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tuples1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Tuples(soap, "ns4:Tuples", &(a->__ns4__union_Axis::Tuples), "ns4:Tuples"))
				{	soap_flag_Tuples1--;
					continue;
				}
			if (soap_flag_CrossProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CrossProduct(soap, "ns4:CrossProduct", &(a->__ns4__union_Axis::CrossProduct), "ns4:CrossProduct"))
				{	soap_flag_CrossProduct1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns4__union_Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns4:union-Axis", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__union_Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns4__union_Axis(soap, this, tag, type);
}

SOAP_FMAC3 __ns4__union_Axis * SOAP_FMAC4 soap_get___ns4__union_Axis(struct soap *soap, __ns4__union_Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns4__union_Axis * SOAP_FMAC2 soap_instantiate___ns4__union_Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__union_Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__union_Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns4__union_Axis);
		if (size)
			*size = sizeof(__ns4__union_Axis);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns4__union_Axis, n);
		if (size)
			*size = n * sizeof(__ns4__union_Axis);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns4__union_Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__union_Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns4__union_Axis %p -> %p\n", q, p));
	*(__ns4__union_Axis*)p = *(__ns4__union_Axis*)q;
}

void __ns4__union_ResultXmlRoot::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns4__union_ResultXmlRoot::CellData = NULL;
	this->__ns4__union_ResultXmlRoot::Axes = NULL;
	this->__ns4__union_ResultXmlRoot::row = NULL;
	this->__ns4__union_ResultXmlRoot::OlapInfo = NULL;
}

void __ns4__union_ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CellData(soap, &this->__ns4__union_ResultXmlRoot::CellData);
	soap_serialize_PointerTons4__Axes(soap, &this->__ns4__union_ResultXmlRoot::Axes);
	soap_serialize_PointerTons4__Row(soap, &this->__ns4__union_ResultXmlRoot::row);
	soap_serialize_PointerTons4__OlapInfo(soap, &this->__ns4__union_ResultXmlRoot::OlapInfo);
#endif
}

int __ns4__union_ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns4__union_ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, const __ns4__union_ResultXmlRoot *a, const char *type)
{
	if (soap_out_PointerTons4__CellData(soap, "ns4:CellData", -1, &(a->__ns4__union_ResultXmlRoot::CellData), ""))
		return soap->error;
	if (soap_out_PointerTons4__Axes(soap, "ns4:Axes", -1, &(a->__ns4__union_ResultXmlRoot::Axes), ""))
		return soap->error;
	if (soap_out_PointerTons4__Row(soap, "ns4:row", -1, &(a->__ns4__union_ResultXmlRoot::row), ""))
		return soap->error;
	if (soap_out_PointerTons4__OlapInfo(soap, "ns4:OlapInfo", -1, &(a->__ns4__union_ResultXmlRoot::OlapInfo), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__union_ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns4__union_ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 __ns4__union_ResultXmlRoot * SOAP_FMAC4 soap_in___ns4__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns4__union_ResultXmlRoot *a, const char *type)
{
	a = (__ns4__union_ResultXmlRoot *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns4__union_ResultXmlRoot, sizeof(__ns4__union_ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_CellData1 = 1;
	size_t soap_flag_Axes1 = 1;
	size_t soap_flag_row1 = 1;
	size_t soap_flag_OlapInfo1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CellData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CellData(soap, "ns4:CellData", &(a->__ns4__union_ResultXmlRoot::CellData), "ns4:CellData"))
				{	soap_flag_CellData1--;
					continue;
				}
			if (soap_flag_Axes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Axes(soap, "ns4:Axes", &(a->__ns4__union_ResultXmlRoot::Axes), "ns4:Axes"))
				{	soap_flag_Axes1--;
					continue;
				}
			if (soap_flag_row1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Row(soap, "ns4:row", &(a->__ns4__union_ResultXmlRoot::row), "ns4:Row"))
				{	soap_flag_row1--;
					continue;
				}
			if (soap_flag_OlapInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OlapInfo(soap, "ns4:OlapInfo", &(a->__ns4__union_ResultXmlRoot::OlapInfo), "ns4:OlapInfo"))
				{	soap_flag_OlapInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns4__union_ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns4:union-ResultXmlRoot", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__union_ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns4__union_ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 __ns4__union_ResultXmlRoot * SOAP_FMAC4 soap_get___ns4__union_ResultXmlRoot(struct soap *soap, __ns4__union_ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns4__union_ResultXmlRoot * SOAP_FMAC2 soap_instantiate___ns4__union_ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__union_ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__union_ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns4__union_ResultXmlRoot);
		if (size)
			*size = sizeof(__ns4__union_ResultXmlRoot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns4__union_ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(__ns4__union_ResultXmlRoot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns4__union_ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__union_ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns4__union_ResultXmlRoot %p -> %p\n", q, p));
	*(__ns4__union_ResultXmlRoot*)p = *(__ns4__union_ResultXmlRoot*)q;
}

void __ns2__union_Axis::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_Axis::Tuples = NULL;
	this->__ns2__union_Axis::CrossProduct = NULL;
}

void __ns2__union_Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Tuples(soap, &this->__ns2__union_Axis::Tuples);
	soap_serialize_PointerTons2__CrossProduct(soap, &this->__ns2__union_Axis::CrossProduct);
#endif
}

int __ns2__union_Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_Axis(struct soap *soap, const char *tag, int id, const __ns2__union_Axis *a, const char *type)
{
	if (soap_out_PointerTons2__Tuples(soap, "ns2:Tuples", -1, &(a->__ns2__union_Axis::Tuples), ""))
		return soap->error;
	if (soap_out_PointerTons2__CrossProduct(soap, "ns2:CrossProduct", -1, &(a->__ns2__union_Axis::CrossProduct), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_Axis(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_Axis * SOAP_FMAC4 soap_in___ns2__union_Axis(struct soap *soap, const char *tag, __ns2__union_Axis *a, const char *type)
{
	a = (__ns2__union_Axis *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_Axis, sizeof(__ns2__union_Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_Tuples1 = 1;
	size_t soap_flag_CrossProduct1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tuples1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Tuples(soap, "ns2:Tuples", &(a->__ns2__union_Axis::Tuples), "ns2:Tuples"))
				{	soap_flag_Tuples1--;
					continue;
				}
			if (soap_flag_CrossProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CrossProduct(soap, "ns2:CrossProduct", &(a->__ns2__union_Axis::CrossProduct), "ns2:CrossProduct"))
				{	soap_flag_CrossProduct1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns2__union_Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-Axis", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_Axis(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_Axis * SOAP_FMAC4 soap_get___ns2__union_Axis(struct soap *soap, __ns2__union_Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_Axis * SOAP_FMAC2 soap_instantiate___ns2__union_Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_Axis);
		if (size)
			*size = sizeof(__ns2__union_Axis);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns2__union_Axis, n);
		if (size)
			*size = n * sizeof(__ns2__union_Axis);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns2__union_Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_Axis %p -> %p\n", q, p));
	*(__ns2__union_Axis*)p = *(__ns2__union_Axis*)q;
}

void __ns2__union_ResultXmlRoot::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_ResultXmlRoot::CellData = NULL;
	this->__ns2__union_ResultXmlRoot::Axes = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->__ns2__union_ResultXmlRoot::row);
	this->__ns2__union_ResultXmlRoot::OlapInfo = NULL;
}

void __ns2__union_ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CellData(soap, &this->__ns2__union_ResultXmlRoot::CellData);
	soap_serialize_PointerTons2__Axes(soap, &this->__ns2__union_ResultXmlRoot::Axes);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->__ns2__union_ResultXmlRoot::row);
	soap_serialize_PointerTons2__OlapInfo(soap, &this->__ns2__union_ResultXmlRoot::OlapInfo);
#endif
}

int __ns2__union_ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, const __ns2__union_ResultXmlRoot *a, const char *type)
{
	if (soap_out_PointerTons2__CellData(soap, "ns2:CellData", -1, &(a->__ns2__union_ResultXmlRoot::CellData), ""))
		return soap->error;
	if (soap_out_PointerTons2__Axes(soap, "ns2:Axes", -1, &(a->__ns2__union_ResultXmlRoot::Axes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns2:row", -1, &(a->__ns2__union_ResultXmlRoot::row), ""))
		return soap->error;
	if (soap_out_PointerTons2__OlapInfo(soap, "ns2:OlapInfo", -1, &(a->__ns2__union_ResultXmlRoot::OlapInfo), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_ResultXmlRoot * SOAP_FMAC4 soap_in___ns2__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns2__union_ResultXmlRoot *a, const char *type)
{
	a = (__ns2__union_ResultXmlRoot *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_ResultXmlRoot, sizeof(__ns2__union_ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_CellData1 = 1;
	size_t soap_flag_Axes1 = 1;
	size_t soap_flag_OlapInfo1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CellData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CellData(soap, "ns2:CellData", &(a->__ns2__union_ResultXmlRoot::CellData), "ns2:CellData"))
				{	soap_flag_CellData1--;
					continue;
				}
			if (soap_flag_Axes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Axes(soap, "ns2:Axes", &(a->__ns2__union_ResultXmlRoot::Axes), "ns2:Axes"))
				{	soap_flag_Axes1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "ns2:row", &(a->__ns2__union_ResultXmlRoot::row), ""))
					continue;
			if (soap_flag_OlapInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OlapInfo(soap, "ns2:OlapInfo", &(a->__ns2__union_ResultXmlRoot::OlapInfo), "ns2:OlapInfo"))
				{	soap_flag_OlapInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns2__union_ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-ResultXmlRoot", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_ResultXmlRoot * SOAP_FMAC4 soap_get___ns2__union_ResultXmlRoot(struct soap *soap, __ns2__union_ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_ResultXmlRoot * SOAP_FMAC2 soap_instantiate___ns2__union_ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_ResultXmlRoot);
		if (size)
			*size = sizeof(__ns2__union_ResultXmlRoot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns2__union_ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(__ns2__union_ResultXmlRoot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns2__union_ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_ResultXmlRoot %p -> %p\n", q, p));
	*(__ns2__union_ResultXmlRoot*)p = *(__ns2__union_ResultXmlRoot*)q;
}

void ns6__UsernameTokenElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__UsernameTokenElement::Username = NULL;
	this->ns6__UsernameTokenElement::Password = NULL;
	/* transient soap skipped */
}

void ns6__UsernameTokenElement::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns6__UsernameTokenElement::Username);
	soap_serialize_PointerTostd__string(soap, &this->ns6__UsernameTokenElement::Password);
	/* transient soap skipped */
#endif
}

int ns6__UsernameTokenElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UsernameTokenElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UsernameTokenElement(struct soap *soap, const char *tag, int id, const ns6__UsernameTokenElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UsernameTokenElement), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns6:Username", -1, &(a->ns6__UsernameTokenElement::Username), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns6:Password", -1, &(a->ns6__UsernameTokenElement::Password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__UsernameTokenElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UsernameTokenElement(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UsernameTokenElement * SOAP_FMAC4 soap_in_ns6__UsernameTokenElement(struct soap *soap, const char *tag, ns6__UsernameTokenElement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UsernameTokenElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UsernameTokenElement, sizeof(ns6__UsernameTokenElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__UsernameTokenElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__UsernameTokenElement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:Username", &(a->ns6__UsernameTokenElement::Username), "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:Password", &(a->ns6__UsernameTokenElement::Password), "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__UsernameTokenElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UsernameTokenElement, 0, sizeof(ns6__UsernameTokenElement), 0, soap_copy_ns6__UsernameTokenElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__UsernameTokenElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__UsernameTokenElement);
	if (this->soap_out(soap, tag?tag:"ns6:UsernameTokenElement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UsernameTokenElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UsernameTokenElement(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UsernameTokenElement * SOAP_FMAC4 soap_get_ns6__UsernameTokenElement(struct soap *soap, ns6__UsernameTokenElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UsernameTokenElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__UsernameTokenElement * SOAP_FMAC2 soap_instantiate_ns6__UsernameTokenElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__UsernameTokenElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__UsernameTokenElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__UsernameTokenElement);
		if (size)
			*size = sizeof(ns6__UsernameTokenElement);
		((ns6__UsernameTokenElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__UsernameTokenElement, n);
		if (size)
			*size = n * sizeof(ns6__UsernameTokenElement);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__UsernameTokenElement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__UsernameTokenElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__UsernameTokenElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__UsernameTokenElement %p -> %p\n", q, p));
	*(ns6__UsernameTokenElement*)p = *(ns6__UsernameTokenElement*)q;
}

void ns6__Security::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Security::UsernameToken = NULL;
	this->ns6__Security::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns6__Security::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__UsernameTokenElement(soap, &this->ns6__Security::UsernameToken);
	/* transient soap skipped */
#endif
}

int ns6__Security::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Security(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Security(struct soap *soap, const char *tag, int id, const ns6__Security *a, const char *type)
{
	if (((ns6__Security*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns6__Security*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Security), type))
		return soap->error;
	if (soap_out_PointerTons6__UsernameTokenElement(soap, "ns6:UsernameToken", -1, &(a->ns6__Security::UsernameToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Security::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Security(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Security * SOAP_FMAC4 soap_in_ns6__Security(struct soap *soap, const char *tag, ns6__Security *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Security *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Security, sizeof(ns6__Security), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Security)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Security *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns6__Security*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_UsernameToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UsernameToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__UsernameTokenElement(soap, "ns6:UsernameToken", &(a->ns6__Security::UsernameToken), "ns6:UsernameTokenElement"))
				{	soap_flag_UsernameToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Security, 0, sizeof(ns6__Security), 0, soap_copy_ns6__Security);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Security::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Security);
	if (this->soap_out(soap, tag?tag:"ns6:Security", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__Security::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Security(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Security * SOAP_FMAC4 soap_get_ns6__Security(struct soap *soap, ns6__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Security * SOAP_FMAC2 soap_instantiate_ns6__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Security(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Security, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__Security);
		if (size)
			*size = sizeof(ns6__Security);
		((ns6__Security*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__Security, n);
		if (size)
			*size = n * sizeof(ns6__Security);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__Security*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__Security*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Security(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Security %p -> %p\n", q, p));
	*(ns6__Security*)p = *(ns6__Security*)q;
}

void ns5__CellInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns5__CellInfo::__any);
	/* transient soap skipped */
}

void ns5__CellInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns5__CellInfo::__any);
	/* transient soap skipped */
#endif
}

int ns5__CellInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CellInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CellInfo(struct soap *soap, const char *tag, int id, const ns5__CellInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CellInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns5__CellInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__CellInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__CellInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CellInfo * SOAP_FMAC4 soap_in_ns5__CellInfo(struct soap *soap, const char *tag, ns5__CellInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CellInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CellInfo, sizeof(ns5__CellInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__CellInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CellInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns5__CellInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__CellInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CellInfo, 0, sizeof(ns5__CellInfo), 0, soap_copy_ns5__CellInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__CellInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CellInfo);
	if (this->soap_out(soap, tag?tag:"ns5:CellInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__CellInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CellInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CellInfo * SOAP_FMAC4 soap_get_ns5__CellInfo(struct soap *soap, ns5__CellInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CellInfo * SOAP_FMAC2 soap_instantiate_ns5__CellInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CellInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CellInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__CellInfo);
		if (size)
			*size = sizeof(ns5__CellInfo);
		((ns5__CellInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__CellInfo, n);
		if (size)
			*size = n * sizeof(ns5__CellInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__CellInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__CellInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CellInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CellInfo %p -> %p\n", q, p));
	*(ns5__CellInfo*)p = *(ns5__CellInfo*)q;
}

void ns5__HierarchyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns5__HierarchyInfo::__any);
	this->ns5__HierarchyInfo::name = NULL;
	/* transient soap skipped */
}

void ns5__HierarchyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns5__HierarchyInfo::__any);
	/* transient soap skipped */
#endif
}

int ns5__HierarchyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__HierarchyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__HierarchyInfo(struct soap *soap, const char *tag, int id, const ns5__HierarchyInfo *a, const char *type)
{
	if (((ns5__HierarchyInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns5__HierarchyInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__HierarchyInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns5__HierarchyInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__HierarchyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__HierarchyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__HierarchyInfo * SOAP_FMAC4 soap_in_ns5__HierarchyInfo(struct soap *soap, const char *tag, ns5__HierarchyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__HierarchyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__HierarchyInfo, sizeof(ns5__HierarchyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__HierarchyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__HierarchyInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns5__HierarchyInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns5__HierarchyInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns5__HierarchyInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__HierarchyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__HierarchyInfo, 0, sizeof(ns5__HierarchyInfo), 0, soap_copy_ns5__HierarchyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__HierarchyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__HierarchyInfo);
	if (this->soap_out(soap, tag?tag:"ns5:HierarchyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__HierarchyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__HierarchyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__HierarchyInfo * SOAP_FMAC4 soap_get_ns5__HierarchyInfo(struct soap *soap, ns5__HierarchyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__HierarchyInfo * SOAP_FMAC2 soap_instantiate_ns5__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__HierarchyInfo);
		if (size)
			*size = sizeof(ns5__HierarchyInfo);
		((ns5__HierarchyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__HierarchyInfo, n);
		if (size)
			*size = n * sizeof(ns5__HierarchyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__HierarchyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__HierarchyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__HierarchyInfo %p -> %p\n", q, p));
	*(ns5__HierarchyInfo*)p = *(ns5__HierarchyInfo*)q;
}

void ns5__AxisInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, &this->ns5__AxisInfo::HierarchyInfo);
	this->ns5__AxisInfo::name = NULL;
	/* transient soap skipped */
}

void ns5__AxisInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, &this->ns5__AxisInfo::HierarchyInfo);
	/* transient soap skipped */
#endif
}

int ns5__AxisInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__AxisInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__AxisInfo(struct soap *soap, const char *tag, int id, const ns5__AxisInfo *a, const char *type)
{
	if (((ns5__AxisInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns5__AxisInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AxisInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, "ns5:HierarchyInfo", -1, &(a->ns5__AxisInfo::HierarchyInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__AxisInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__AxisInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__AxisInfo * SOAP_FMAC4 soap_in_ns5__AxisInfo(struct soap *soap, const char *tag, ns5__AxisInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__AxisInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AxisInfo, sizeof(ns5__AxisInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__AxisInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__AxisInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns5__AxisInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns5__AxisInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, "ns5:HierarchyInfo", &(a->ns5__AxisInfo::HierarchyInfo), "ns5:HierarchyInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__AxisInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AxisInfo, 0, sizeof(ns5__AxisInfo), 0, soap_copy_ns5__AxisInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__AxisInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__AxisInfo);
	if (this->soap_out(soap, tag?tag:"ns5:AxisInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__AxisInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__AxisInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__AxisInfo * SOAP_FMAC4 soap_get_ns5__AxisInfo(struct soap *soap, ns5__AxisInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__AxisInfo * SOAP_FMAC2 soap_instantiate_ns5__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__AxisInfo);
		if (size)
			*size = sizeof(ns5__AxisInfo);
		((ns5__AxisInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__AxisInfo, n);
		if (size)
			*size = n * sizeof(ns5__AxisInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__AxisInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__AxisInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__AxisInfo %p -> %p\n", q, p));
	*(ns5__AxisInfo*)p = *(ns5__AxisInfo*)q;
}

void ns5__AxesInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__AxisInfo(soap, &this->ns5__AxesInfo::AxisInfo);
	/* transient soap skipped */
}

void ns5__AxesInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__AxisInfo(soap, &this->ns5__AxesInfo::AxisInfo);
	/* transient soap skipped */
#endif
}

int ns5__AxesInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__AxesInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__AxesInfo(struct soap *soap, const char *tag, int id, const ns5__AxesInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AxesInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__AxisInfo(soap, "ns5:AxisInfo", -1, &(a->ns5__AxesInfo::AxisInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__AxesInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__AxesInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__AxesInfo * SOAP_FMAC4 soap_in_ns5__AxesInfo(struct soap *soap, const char *tag, ns5__AxesInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__AxesInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AxesInfo, sizeof(ns5__AxesInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__AxesInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__AxesInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__AxisInfo(soap, "ns5:AxisInfo", &(a->ns5__AxesInfo::AxisInfo), "ns5:AxisInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__AxesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AxesInfo, 0, sizeof(ns5__AxesInfo), 0, soap_copy_ns5__AxesInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__AxesInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__AxesInfo);
	if (this->soap_out(soap, tag?tag:"ns5:AxesInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__AxesInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__AxesInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__AxesInfo * SOAP_FMAC4 soap_get_ns5__AxesInfo(struct soap *soap, ns5__AxesInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__AxesInfo * SOAP_FMAC2 soap_instantiate_ns5__AxesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__AxesInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__AxesInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__AxesInfo);
		if (size)
			*size = sizeof(ns5__AxesInfo);
		((ns5__AxesInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__AxesInfo, n);
		if (size)
			*size = n * sizeof(ns5__AxesInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__AxesInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__AxesInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__AxesInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__AxesInfo %p -> %p\n", q, p));
	*(ns5__AxesInfo*)p = *(ns5__AxesInfo*)q;
}

void ns5__Cube::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Cube::CubeName = NULL;
	/* transient soap skipped */
}

void ns5__Cube::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__Cube::CubeName);
	/* transient soap skipped */
#endif
}

int ns5__Cube::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Cube(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Cube(struct soap *soap, const char *tag, int id, const ns5__Cube *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Cube), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:CubeName", -1, &(a->ns5__Cube::CubeName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Cube::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Cube(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Cube * SOAP_FMAC4 soap_in_ns5__Cube(struct soap *soap, const char *tag, ns5__Cube *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Cube *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Cube, sizeof(ns5__Cube), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Cube)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Cube *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:CubeName", &(a->ns5__Cube::CubeName), "xsd:string"))
				{	soap_flag_CubeName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Cube *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Cube, 0, sizeof(ns5__Cube), 0, soap_copy_ns5__Cube);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Cube::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Cube);
	if (this->soap_out(soap, tag?tag:"ns5:Cube", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Cube::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Cube(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Cube * SOAP_FMAC4 soap_get_ns5__Cube(struct soap *soap, ns5__Cube *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Cube * SOAP_FMAC2 soap_instantiate_ns5__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Cube);
		if (size)
			*size = sizeof(ns5__Cube);
		((ns5__Cube*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Cube, n);
		if (size)
			*size = n * sizeof(ns5__Cube);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Cube*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Cube*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Cube %p -> %p\n", q, p));
	*(ns5__Cube*)p = *(ns5__Cube*)q;
}

void ns5__CubeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Cube(soap, &this->ns5__CubeInfo::Cube);
	/* transient soap skipped */
}

void ns5__CubeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Cube(soap, &this->ns5__CubeInfo::Cube);
	/* transient soap skipped */
#endif
}

int ns5__CubeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CubeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CubeInfo(struct soap *soap, const char *tag, int id, const ns5__CubeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CubeInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Cube(soap, "ns5:Cube", -1, &(a->ns5__CubeInfo::Cube), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__CubeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__CubeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CubeInfo * SOAP_FMAC4 soap_in_ns5__CubeInfo(struct soap *soap, const char *tag, ns5__CubeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CubeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CubeInfo, sizeof(ns5__CubeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__CubeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CubeInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Cube(soap, "ns5:Cube", &(a->ns5__CubeInfo::Cube), "ns5:Cube"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__CubeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CubeInfo, 0, sizeof(ns5__CubeInfo), 0, soap_copy_ns5__CubeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__CubeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CubeInfo);
	if (this->soap_out(soap, tag?tag:"ns5:CubeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__CubeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CubeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CubeInfo * SOAP_FMAC4 soap_get_ns5__CubeInfo(struct soap *soap, ns5__CubeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CubeInfo * SOAP_FMAC2 soap_instantiate_ns5__CubeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CubeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CubeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__CubeInfo);
		if (size)
			*size = sizeof(ns5__CubeInfo);
		((ns5__CubeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__CubeInfo, n);
		if (size)
			*size = n * sizeof(ns5__CubeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__CubeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__CubeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CubeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CubeInfo %p -> %p\n", q, p));
	*(ns5__CubeInfo*)p = *(ns5__CubeInfo*)q;
}

void ns5__OlapInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__OlapInfo::CubeInfo = NULL;
	this->ns5__OlapInfo::AxesInfo = NULL;
	this->ns5__OlapInfo::CellInfo = NULL;
	/* transient soap skipped */
}

void ns5__OlapInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__CubeInfo(soap, &this->ns5__OlapInfo::CubeInfo);
	soap_serialize_PointerTons5__AxesInfo(soap, &this->ns5__OlapInfo::AxesInfo);
	soap_serialize_PointerTons5__CellInfo(soap, &this->ns5__OlapInfo::CellInfo);
	/* transient soap skipped */
#endif
}

int ns5__OlapInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__OlapInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__OlapInfo(struct soap *soap, const char *tag, int id, const ns5__OlapInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__OlapInfo), type))
		return soap->error;
	if (soap_out_PointerTons5__CubeInfo(soap, "ns5:CubeInfo", -1, &(a->ns5__OlapInfo::CubeInfo), ""))
		return soap->error;
	if (soap_out_PointerTons5__AxesInfo(soap, "ns5:AxesInfo", -1, &(a->ns5__OlapInfo::AxesInfo), ""))
		return soap->error;
	if (soap_out_PointerTons5__CellInfo(soap, "ns5:CellInfo", -1, &(a->ns5__OlapInfo::CellInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__OlapInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__OlapInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__OlapInfo * SOAP_FMAC4 soap_in_ns5__OlapInfo(struct soap *soap, const char *tag, ns5__OlapInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__OlapInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__OlapInfo, sizeof(ns5__OlapInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__OlapInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__OlapInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeInfo1 = 1;
	size_t soap_flag_AxesInfo1 = 1;
	size_t soap_flag_CellInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__CubeInfo(soap, "ns5:CubeInfo", &(a->ns5__OlapInfo::CubeInfo), "ns5:CubeInfo"))
				{	soap_flag_CubeInfo1--;
					continue;
				}
			if (soap_flag_AxesInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__AxesInfo(soap, "ns5:AxesInfo", &(a->ns5__OlapInfo::AxesInfo), "ns5:AxesInfo"))
				{	soap_flag_AxesInfo1--;
					continue;
				}
			if (soap_flag_CellInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__CellInfo(soap, "ns5:CellInfo", &(a->ns5__OlapInfo::CellInfo), "ns5:CellInfo"))
				{	soap_flag_CellInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__OlapInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__OlapInfo, 0, sizeof(ns5__OlapInfo), 0, soap_copy_ns5__OlapInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__OlapInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__OlapInfo);
	if (this->soap_out(soap, tag?tag:"ns5:OlapInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__OlapInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__OlapInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__OlapInfo * SOAP_FMAC4 soap_get_ns5__OlapInfo(struct soap *soap, ns5__OlapInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__OlapInfo * SOAP_FMAC2 soap_instantiate_ns5__OlapInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__OlapInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__OlapInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__OlapInfo);
		if (size)
			*size = sizeof(ns5__OlapInfo);
		((ns5__OlapInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__OlapInfo, n);
		if (size)
			*size = n * sizeof(ns5__OlapInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__OlapInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__OlapInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__OlapInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__OlapInfo %p -> %p\n", q, p));
	*(ns5__OlapInfo*)p = *(ns5__OlapInfo*)q;
}

void ns5__Row::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns5__Row::__any);
	/* transient soap skipped */
}

void ns5__Row::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns5__Row::__any);
	/* transient soap skipped */
#endif
}

int ns5__Row::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Row(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Row(struct soap *soap, const char *tag, int id, const ns5__Row *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Row), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns5__Row::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Row::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Row(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Row * SOAP_FMAC4 soap_in_ns5__Row(struct soap *soap, const char *tag, ns5__Row *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Row *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Row, sizeof(ns5__Row), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Row)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Row *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns5__Row::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Row *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Row, 0, sizeof(ns5__Row), 0, soap_copy_ns5__Row);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Row::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Row);
	if (this->soap_out(soap, tag?tag:"ns5:Row", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Row::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Row(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Row * SOAP_FMAC4 soap_get_ns5__Row(struct soap *soap, ns5__Row *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Row(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Row * SOAP_FMAC2 soap_instantiate_ns5__Row(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Row(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Row, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Row);
		if (size)
			*size = sizeof(ns5__Row);
		((ns5__Row*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Row, n);
		if (size)
			*size = n * sizeof(ns5__Row);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Row*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Row*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Row(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Row %p -> %p\n", q, p));
	*(ns5__Row*)p = *(ns5__Row*)q;
}

void ns5__Members::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Member(soap, &this->ns5__Members::Member);
	this->ns5__Members::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns5__Members::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Member(soap, &this->ns5__Members::Member);
	/* transient soap skipped */
#endif
}

int ns5__Members::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Members(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Members(struct soap *soap, const char *tag, int id, const ns5__Members *a, const char *type)
{
	if (((ns5__Members*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns5__Members*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Members), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Member(soap, "ns5:Member", -1, &(a->ns5__Members::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Members::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Members(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Members * SOAP_FMAC4 soap_in_ns5__Members(struct soap *soap, const char *tag, ns5__Members *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Members *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Members, sizeof(ns5__Members), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Members)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Members *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns5__Members*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns5__Members*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Member(soap, "ns5:Member", &(a->ns5__Members::Member), "ns5:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Members *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Members, 0, sizeof(ns5__Members), 0, soap_copy_ns5__Members);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Members::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Members);
	if (this->soap_out(soap, tag?tag:"ns5:Members", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Members::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Members(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Members * SOAP_FMAC4 soap_get_ns5__Members(struct soap *soap, ns5__Members *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Members * SOAP_FMAC2 soap_instantiate_ns5__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Members);
		if (size)
			*size = sizeof(ns5__Members);
		((ns5__Members*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Members, n);
		if (size)
			*size = n * sizeof(ns5__Members);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Members*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Members*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Members %p -> %p\n", q, p));
	*(ns5__Members*)p = *(ns5__Members*)q;
}

void ns5__CrossProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Members(soap, &this->ns5__CrossProduct::Members);
	soap_default_int(soap, &this->ns5__CrossProduct::Size);
	/* transient soap skipped */
}

void ns5__CrossProduct::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Members(soap, &this->ns5__CrossProduct::Members);
	/* transient soap skipped */
#endif
}

int ns5__CrossProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CrossProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CrossProduct(struct soap *soap, const char *tag, int id, const ns5__CrossProduct *a, const char *type)
{
	soap_set_attr(soap, "Size", soap_int2s(soap, ((ns5__CrossProduct*)a)->Size), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CrossProduct), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Members(soap, "ns5:Members", -1, &(a->ns5__CrossProduct::Members), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__CrossProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__CrossProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CrossProduct * SOAP_FMAC4 soap_in_ns5__CrossProduct(struct soap *soap, const char *tag, ns5__CrossProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CrossProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CrossProduct, sizeof(ns5__CrossProduct), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__CrossProduct)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CrossProduct *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Size", 1), &((ns5__CrossProduct*)a)->Size))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Members(soap, "ns5:Members", &(a->ns5__CrossProduct::Members), "ns5:Members"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__CrossProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CrossProduct, 0, sizeof(ns5__CrossProduct), 0, soap_copy_ns5__CrossProduct);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__CrossProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CrossProduct);
	if (this->soap_out(soap, tag?tag:"ns5:CrossProduct", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__CrossProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CrossProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CrossProduct * SOAP_FMAC4 soap_get_ns5__CrossProduct(struct soap *soap, ns5__CrossProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CrossProduct * SOAP_FMAC2 soap_instantiate_ns5__CrossProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CrossProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CrossProduct, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__CrossProduct);
		if (size)
			*size = sizeof(ns5__CrossProduct);
		((ns5__CrossProduct*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__CrossProduct, n);
		if (size)
			*size = n * sizeof(ns5__CrossProduct);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__CrossProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__CrossProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CrossProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CrossProduct %p -> %p\n", q, p));
	*(ns5__CrossProduct*)p = *(ns5__CrossProduct*)q;
}

void ns5__Member::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Member::UName = NULL;
	this->ns5__Member::Caption = NULL;
	this->ns5__Member::LName = NULL;
	this->ns5__Member::LNum = NULL;
	this->ns5__Member::DisplayInfo = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns5__Member::__any);
	this->ns5__Member::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns5__Member::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__Member::UName);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Member::Caption);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Member::LName);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Member::LNum);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Member::DisplayInfo);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns5__Member::__any);
	/* transient soap skipped */
#endif
}

int ns5__Member::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Member(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Member(struct soap *soap, const char *tag, int id, const ns5__Member *a, const char *type)
{
	if (((ns5__Member*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns5__Member*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Member), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:UName", -1, &(a->ns5__Member::UName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Caption", -1, &(a->ns5__Member::Caption), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:LName", -1, &(a->ns5__Member::LName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:LNum", -1, &(a->ns5__Member::LNum), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:DisplayInfo", -1, &(a->ns5__Member::DisplayInfo), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns5__Member::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Member::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Member(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Member * SOAP_FMAC4 soap_in_ns5__Member(struct soap *soap, const char *tag, ns5__Member *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Member *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Member, sizeof(ns5__Member), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Member)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Member *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns5__Member*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns5__Member*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_UName1 = 1;
	size_t soap_flag_Caption1 = 1;
	size_t soap_flag_LName1 = 1;
	size_t soap_flag_LNum1 = 1;
	size_t soap_flag_DisplayInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:UName", &(a->ns5__Member::UName), "xsd:string"))
				{	soap_flag_UName1--;
					continue;
				}
			if (soap_flag_Caption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Caption", &(a->ns5__Member::Caption), "xsd:string"))
				{	soap_flag_Caption1--;
					continue;
				}
			if (soap_flag_LName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:LName", &(a->ns5__Member::LName), "xsd:string"))
				{	soap_flag_LName1--;
					continue;
				}
			if (soap_flag_LNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:LNum", &(a->ns5__Member::LNum), "xsd:string"))
				{	soap_flag_LNum1--;
					continue;
				}
			if (soap_flag_DisplayInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:DisplayInfo", &(a->ns5__Member::DisplayInfo), "xsd:string"))
				{	soap_flag_DisplayInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns5__Member::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Member *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Member, 0, sizeof(ns5__Member), 0, soap_copy_ns5__Member);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Member::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Member);
	if (this->soap_out(soap, tag?tag:"ns5:Member", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Member::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Member(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Member * SOAP_FMAC4 soap_get_ns5__Member(struct soap *soap, ns5__Member *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Member * SOAP_FMAC2 soap_instantiate_ns5__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Member);
		if (size)
			*size = sizeof(ns5__Member);
		((ns5__Member*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Member, n);
		if (size)
			*size = n * sizeof(ns5__Member);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Member*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Member*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Member %p -> %p\n", q, p));
	*(ns5__Member*)p = *(ns5__Member*)q;
}

void ns5__Tuple::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Member(soap, &this->ns5__Tuple::Member);
	/* transient soap skipped */
}

void ns5__Tuple::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Member(soap, &this->ns5__Tuple::Member);
	/* transient soap skipped */
#endif
}

int ns5__Tuple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Tuple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Tuple(struct soap *soap, const char *tag, int id, const ns5__Tuple *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Tuple), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Member(soap, "ns5:Member", -1, &(a->ns5__Tuple::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Tuple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Tuple(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Tuple * SOAP_FMAC4 soap_in_ns5__Tuple(struct soap *soap, const char *tag, ns5__Tuple *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Tuple *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Tuple, sizeof(ns5__Tuple), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Tuple)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Tuple *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Member(soap, "ns5:Member", &(a->ns5__Tuple::Member), "ns5:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Tuple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Tuple, 0, sizeof(ns5__Tuple), 0, soap_copy_ns5__Tuple);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Tuple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Tuple);
	if (this->soap_out(soap, tag?tag:"ns5:Tuple", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Tuple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Tuple(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Tuple * SOAP_FMAC4 soap_get_ns5__Tuple(struct soap *soap, ns5__Tuple *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Tuple * SOAP_FMAC2 soap_instantiate_ns5__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Tuple);
		if (size)
			*size = sizeof(ns5__Tuple);
		((ns5__Tuple*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Tuple, n);
		if (size)
			*size = n * sizeof(ns5__Tuple);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Tuple*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Tuple*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Tuple %p -> %p\n", q, p));
	*(ns5__Tuple*)p = *(ns5__Tuple*)q;
}

void ns5__Tuples::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Tuple(soap, &this->ns5__Tuples::Tuple);
	/* transient soap skipped */
}

void ns5__Tuples::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Tuple(soap, &this->ns5__Tuples::Tuple);
	/* transient soap skipped */
#endif
}

int ns5__Tuples::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Tuples(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Tuples(struct soap *soap, const char *tag, int id, const ns5__Tuples *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Tuples), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Tuple(soap, "ns5:Tuple", -1, &(a->ns5__Tuples::Tuple), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Tuples::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Tuples(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Tuples * SOAP_FMAC4 soap_in_ns5__Tuples(struct soap *soap, const char *tag, ns5__Tuples *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Tuples *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Tuples, sizeof(ns5__Tuples), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Tuples)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Tuples *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Tuple(soap, "ns5:Tuple", &(a->ns5__Tuples::Tuple), "ns5:Tuple"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Tuples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Tuples, 0, sizeof(ns5__Tuples), 0, soap_copy_ns5__Tuples);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Tuples::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Tuples);
	if (this->soap_out(soap, tag?tag:"ns5:Tuples", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Tuples::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Tuples(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Tuples * SOAP_FMAC4 soap_get_ns5__Tuples(struct soap *soap, ns5__Tuples *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Tuples * SOAP_FMAC2 soap_instantiate_ns5__Tuples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Tuples(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Tuples, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Tuples);
		if (size)
			*size = sizeof(ns5__Tuples);
		((ns5__Tuples*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Tuples, n);
		if (size)
			*size = n * sizeof(ns5__Tuples);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Tuples*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Tuples*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Tuples(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Tuples %p -> %p\n", q, p));
	*(ns5__Tuples*)p = *(ns5__Tuples*)q;
}

void ns5__Axis::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Axis::__size_Axis = 0;
	this->ns5__Axis::__union_Axis = NULL;
	this->ns5__Axis::name = NULL;
	/* transient soap skipped */
}

void ns5__Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns5__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < this->ns5__Axis::__size_Axis; i++)
		{
			this->ns5__Axis::__union_Axis[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns5__Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Axis(struct soap *soap, const char *tag, int id, const ns5__Axis *a, const char *type)
{
	if (((ns5__Axis*)a)->name)
		soap_set_attr(soap, "name", ((ns5__Axis*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Axis), type))
		return soap->error;
	if (a->ns5__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < a->ns5__Axis::__size_Axis; i++)
			if (a->ns5__Axis::__union_Axis[i].soap_out(soap, "-union-Axis", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Axis(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Axis * SOAP_FMAC4 soap_in_ns5__Axis(struct soap *soap, const char *tag, ns5__Axis *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Axis *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Axis, sizeof(ns5__Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Axis)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Axis *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns5__Axis*)a)->name = soap_new_std__string(soap, -1);
				((ns5__Axis*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_Axis1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns5__Axis::__union_Axis == NULL)
				{	if (soap_blist___union_Axis1 == NULL)
						soap_blist___union_Axis1 = soap_new_block(soap);
					a->ns5__Axis::__union_Axis = (__ns5__union_Axis *)soap_push_block(soap, soap_blist___union_Axis1, sizeof(__ns5__union_Axis));
					if (a->ns5__Axis::__union_Axis == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns5__Axis::__union_Axis, __ns5__union_Axis);
					a->ns5__Axis::__union_Axis->soap_default(soap);
				}
				if (soap_in___ns5__union_Axis(soap, "-union-Axis", a->ns5__Axis::__union_Axis, "-ns5:union-Axis"))
				{	a->ns5__Axis::__size_Axis++;
					a->ns5__Axis::__union_Axis = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns5__Axis::__union_Axis)
			soap_pop_block(soap, soap_blist___union_Axis1);
		if (a->ns5__Axis::__size_Axis)
			a->ns5__Axis::__union_Axis = (__ns5__union_Axis *)soap_save_block(soap, soap_blist___union_Axis1, NULL, 1);
		else
		{	a->ns5__Axis::__union_Axis = NULL;
			if (soap_blist___union_Axis1)
				soap_end_block(soap, soap_blist___union_Axis1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Axis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Axis, 0, sizeof(ns5__Axis), 0, soap_copy_ns5__Axis);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Axis);
	if (this->soap_out(soap, tag?tag:"ns5:Axis", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Axis(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Axis * SOAP_FMAC4 soap_get_ns5__Axis(struct soap *soap, ns5__Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Axis * SOAP_FMAC2 soap_instantiate_ns5__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Axis);
		if (size)
			*size = sizeof(ns5__Axis);
		((ns5__Axis*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Axis, n);
		if (size)
			*size = n * sizeof(ns5__Axis);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Axis*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Axis %p -> %p\n", q, p));
	*(ns5__Axis*)p = *(ns5__Axis*)q;
}

void ns5__Axes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Axis(soap, &this->ns5__Axes::Axis);
	/* transient soap skipped */
}

void ns5__Axes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Axis(soap, &this->ns5__Axes::Axis);
	/* transient soap skipped */
#endif
}

int ns5__Axes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Axes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Axes(struct soap *soap, const char *tag, int id, const ns5__Axes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Axes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Axis(soap, "ns5:Axis", -1, &(a->ns5__Axes::Axis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Axes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Axes(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Axes * SOAP_FMAC4 soap_in_ns5__Axes(struct soap *soap, const char *tag, ns5__Axes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Axes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Axes, sizeof(ns5__Axes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Axes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Axes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Axis(soap, "ns5:Axis", &(a->ns5__Axes::Axis), "ns5:Axis"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Axes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Axes, 0, sizeof(ns5__Axes), 0, soap_copy_ns5__Axes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Axes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Axes);
	if (this->soap_out(soap, tag?tag:"ns5:Axes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Axes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Axes(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Axes * SOAP_FMAC4 soap_get_ns5__Axes(struct soap *soap, ns5__Axes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Axes * SOAP_FMAC2 soap_instantiate_ns5__Axes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Axes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Axes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Axes);
		if (size)
			*size = sizeof(ns5__Axes);
		((ns5__Axes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Axes, n);
		if (size)
			*size = n * sizeof(ns5__Axes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Axes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Axes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Axes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Axes %p -> %p\n", q, p));
	*(ns5__Axes*)p = *(ns5__Axes*)q;
}

void ns5__Cell::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Cell::Value = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns5__Cell::__any);
	soap_default_int(soap, &this->ns5__Cell::CellOrdinal);
	/* transient soap skipped */
}

void ns5__Cell::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns5__Cell::Value);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns5__Cell::__any);
	/* transient soap skipped */
#endif
}

int ns5__Cell::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Cell(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Cell(struct soap *soap, const char *tag, int id, const ns5__Cell *a, const char *type)
{
	soap_set_attr(soap, "CellOrdinal", soap_int2s(soap, ((ns5__Cell*)a)->CellOrdinal), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Cell), type))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns5:Value", -1, &(a->ns5__Cell::Value), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns5__Cell::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Cell::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Cell(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Cell * SOAP_FMAC4 soap_in_ns5__Cell(struct soap *soap, const char *tag, ns5__Cell *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Cell *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Cell, sizeof(ns5__Cell), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Cell)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Cell *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "CellOrdinal", 1), &((ns5__Cell*)a)->CellOrdinal))
		return NULL;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns5:Value", &(a->ns5__Cell::Value), "xsd:double"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns5__Cell::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Cell *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Cell, 0, sizeof(ns5__Cell), 0, soap_copy_ns5__Cell);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Cell::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Cell);
	if (this->soap_out(soap, tag?tag:"ns5:Cell", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Cell::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Cell(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Cell * SOAP_FMAC4 soap_get_ns5__Cell(struct soap *soap, ns5__Cell *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Cell * SOAP_FMAC2 soap_instantiate_ns5__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Cell);
		if (size)
			*size = sizeof(ns5__Cell);
		((ns5__Cell*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Cell, n);
		if (size)
			*size = n * sizeof(ns5__Cell);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Cell*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Cell*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Cell %p -> %p\n", q, p));
	*(ns5__Cell*)p = *(ns5__Cell*)q;
}

void ns5__CellData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__Cell(soap, &this->ns5__CellData::Cell);
	/* transient soap skipped */
}

void ns5__CellData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__Cell(soap, &this->ns5__CellData::Cell);
	/* transient soap skipped */
#endif
}

int ns5__CellData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CellData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CellData(struct soap *soap, const char *tag, int id, const ns5__CellData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CellData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__Cell(soap, "ns5:Cell", -1, &(a->ns5__CellData::Cell), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__CellData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__CellData(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CellData * SOAP_FMAC4 soap_in_ns5__CellData(struct soap *soap, const char *tag, ns5__CellData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CellData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CellData, sizeof(ns5__CellData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__CellData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CellData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__Cell(soap, "ns5:Cell", &(a->ns5__CellData::Cell), "ns5:Cell"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__CellData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CellData, 0, sizeof(ns5__CellData), 0, soap_copy_ns5__CellData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__CellData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CellData);
	if (this->soap_out(soap, tag?tag:"ns5:CellData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__CellData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CellData(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CellData * SOAP_FMAC4 soap_get_ns5__CellData(struct soap *soap, ns5__CellData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CellData * SOAP_FMAC2 soap_instantiate_ns5__CellData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CellData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CellData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__CellData);
		if (size)
			*size = sizeof(ns5__CellData);
		((ns5__CellData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__CellData, n);
		if (size)
			*size = n * sizeof(ns5__CellData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__CellData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__CellData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CellData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CellData %p -> %p\n", q, p));
	*(ns5__CellData*)p = *(ns5__CellData*)q;
}

void ns5__ResultXmlRoot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xsd__schema(soap, &this->ns5__ResultXmlRoot::xsd__schema);
	this->ns5__ResultXmlRoot::__size_ResultXmlRoot = 0;
	this->ns5__ResultXmlRoot::__union_ResultXmlRoot = NULL;
	/* transient soap skipped */
}

void ns5__ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__xsd__schema(soap, &this->ns5__ResultXmlRoot::xsd__schema);
	if (this->ns5__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < this->ns5__ResultXmlRoot::__size_ResultXmlRoot; i++)
		{
			this->ns5__ResultXmlRoot::__union_ResultXmlRoot[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns5__ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ResultXmlRoot(struct soap *soap, const char *tag, int id, const ns5__ResultXmlRoot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ResultXmlRoot), type))
		return soap->error;
	if (soap_out__xsd__schema(soap, "xsd:schema", -1, &(a->ns5__ResultXmlRoot::xsd__schema), ""))
		return soap->error;
	if (a->ns5__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < a->ns5__ResultXmlRoot::__size_ResultXmlRoot; i++)
			if (a->ns5__ResultXmlRoot::__union_ResultXmlRoot[i].soap_out(soap, "-union-ResultXmlRoot", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ResultXmlRoot * SOAP_FMAC4 soap_in_ns5__ResultXmlRoot(struct soap *soap, const char *tag, ns5__ResultXmlRoot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ResultXmlRoot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ResultXmlRoot, sizeof(ns5__ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ResultXmlRoot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ResultXmlRoot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xsd__schema1 = 1;
	struct soap_blist *soap_blist___union_ResultXmlRoot1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__xsd__schema(soap, "xsd:schema", &(a->ns5__ResultXmlRoot::xsd__schema), ""))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns5__ResultXmlRoot::__union_ResultXmlRoot == NULL)
				{	if (soap_blist___union_ResultXmlRoot1 == NULL)
						soap_blist___union_ResultXmlRoot1 = soap_new_block(soap);
					a->ns5__ResultXmlRoot::__union_ResultXmlRoot = (__ns5__union_ResultXmlRoot *)soap_push_block(soap, soap_blist___union_ResultXmlRoot1, sizeof(__ns5__union_ResultXmlRoot));
					if (a->ns5__ResultXmlRoot::__union_ResultXmlRoot == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns5__ResultXmlRoot::__union_ResultXmlRoot, __ns5__union_ResultXmlRoot);
					a->ns5__ResultXmlRoot::__union_ResultXmlRoot->soap_default(soap);
				}
				if (soap_in___ns5__union_ResultXmlRoot(soap, "-union-ResultXmlRoot", a->ns5__ResultXmlRoot::__union_ResultXmlRoot, "-ns5:union-ResultXmlRoot"))
				{	a->ns5__ResultXmlRoot::__size_ResultXmlRoot++;
					a->ns5__ResultXmlRoot::__union_ResultXmlRoot = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns5__ResultXmlRoot::__union_ResultXmlRoot)
			soap_pop_block(soap, soap_blist___union_ResultXmlRoot1);
		if (a->ns5__ResultXmlRoot::__size_ResultXmlRoot)
			a->ns5__ResultXmlRoot::__union_ResultXmlRoot = (__ns5__union_ResultXmlRoot *)soap_save_block(soap, soap_blist___union_ResultXmlRoot1, NULL, 1);
		else
		{	a->ns5__ResultXmlRoot::__union_ResultXmlRoot = NULL;
			if (soap_blist___union_ResultXmlRoot1)
				soap_end_block(soap, soap_blist___union_ResultXmlRoot1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ResultXmlRoot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ResultXmlRoot, 0, sizeof(ns5__ResultXmlRoot), 0, soap_copy_ns5__ResultXmlRoot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ResultXmlRoot);
	if (this->soap_out(soap, tag?tag:"ns5:ResultXmlRoot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ResultXmlRoot * SOAP_FMAC4 soap_get_ns5__ResultXmlRoot(struct soap *soap, ns5__ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ResultXmlRoot * SOAP_FMAC2 soap_instantiate_ns5__ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ResultXmlRoot);
		if (size)
			*size = sizeof(ns5__ResultXmlRoot);
		((ns5__ResultXmlRoot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(ns5__ResultXmlRoot);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ResultXmlRoot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ResultXmlRoot %p -> %p\n", q, p));
	*(ns5__ResultXmlRoot*)p = *(ns5__ResultXmlRoot*)q;
}

void ns4__CellInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns4__CellInfo::__any);
	/* transient soap skipped */
}

void ns4__CellInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns4__CellInfo::__any);
	/* transient soap skipped */
#endif
}

int ns4__CellInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CellInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CellInfo(struct soap *soap, const char *tag, int id, const ns4__CellInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CellInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns4__CellInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__CellInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CellInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CellInfo * SOAP_FMAC4 soap_in_ns4__CellInfo(struct soap *soap, const char *tag, ns4__CellInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__CellInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CellInfo, sizeof(ns4__CellInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CellInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__CellInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns4__CellInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__CellInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CellInfo, 0, sizeof(ns4__CellInfo), 0, soap_copy_ns4__CellInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__CellInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CellInfo);
	if (this->soap_out(soap, tag?tag:"ns4:CellInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__CellInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CellInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CellInfo * SOAP_FMAC4 soap_get_ns4__CellInfo(struct soap *soap, ns4__CellInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__CellInfo * SOAP_FMAC2 soap_instantiate_ns4__CellInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CellInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CellInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__CellInfo);
		if (size)
			*size = sizeof(ns4__CellInfo);
		((ns4__CellInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__CellInfo, n);
		if (size)
			*size = n * sizeof(ns4__CellInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__CellInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__CellInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CellInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CellInfo %p -> %p\n", q, p));
	*(ns4__CellInfo*)p = *(ns4__CellInfo*)q;
}

void ns4__HierarchyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns4__HierarchyInfo::__any);
	this->ns4__HierarchyInfo::name = NULL;
	/* transient soap skipped */
}

void ns4__HierarchyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns4__HierarchyInfo::__any);
	/* transient soap skipped */
#endif
}

int ns4__HierarchyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__HierarchyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HierarchyInfo(struct soap *soap, const char *tag, int id, const ns4__HierarchyInfo *a, const char *type)
{
	if (((ns4__HierarchyInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns4__HierarchyInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HierarchyInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns4__HierarchyInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__HierarchyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__HierarchyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__HierarchyInfo * SOAP_FMAC4 soap_in_ns4__HierarchyInfo(struct soap *soap, const char *tag, ns4__HierarchyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__HierarchyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HierarchyInfo, sizeof(ns4__HierarchyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__HierarchyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__HierarchyInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns4__HierarchyInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns4__HierarchyInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns4__HierarchyInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__HierarchyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HierarchyInfo, 0, sizeof(ns4__HierarchyInfo), 0, soap_copy_ns4__HierarchyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__HierarchyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__HierarchyInfo);
	if (this->soap_out(soap, tag?tag:"ns4:HierarchyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__HierarchyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__HierarchyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__HierarchyInfo * SOAP_FMAC4 soap_get_ns4__HierarchyInfo(struct soap *soap, ns4__HierarchyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__HierarchyInfo * SOAP_FMAC2 soap_instantiate_ns4__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__HierarchyInfo);
		if (size)
			*size = sizeof(ns4__HierarchyInfo);
		((ns4__HierarchyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__HierarchyInfo, n);
		if (size)
			*size = n * sizeof(ns4__HierarchyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__HierarchyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__HierarchyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__HierarchyInfo %p -> %p\n", q, p));
	*(ns4__HierarchyInfo*)p = *(ns4__HierarchyInfo*)q;
}

void ns4__AxisInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, &this->ns4__AxisInfo::HierarchyInfo);
	this->ns4__AxisInfo::name = NULL;
	/* transient soap skipped */
}

void ns4__AxisInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, &this->ns4__AxisInfo::HierarchyInfo);
	/* transient soap skipped */
#endif
}

int ns4__AxisInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__AxisInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AxisInfo(struct soap *soap, const char *tag, int id, const ns4__AxisInfo *a, const char *type)
{
	if (((ns4__AxisInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns4__AxisInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AxisInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, "ns4:HierarchyInfo", -1, &(a->ns4__AxisInfo::HierarchyInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__AxisInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__AxisInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__AxisInfo * SOAP_FMAC4 soap_in_ns4__AxisInfo(struct soap *soap, const char *tag, ns4__AxisInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__AxisInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AxisInfo, sizeof(ns4__AxisInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__AxisInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__AxisInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns4__AxisInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns4__AxisInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, "ns4:HierarchyInfo", &(a->ns4__AxisInfo::HierarchyInfo), "ns4:HierarchyInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__AxisInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AxisInfo, 0, sizeof(ns4__AxisInfo), 0, soap_copy_ns4__AxisInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__AxisInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__AxisInfo);
	if (this->soap_out(soap, tag?tag:"ns4:AxisInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__AxisInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__AxisInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__AxisInfo * SOAP_FMAC4 soap_get_ns4__AxisInfo(struct soap *soap, ns4__AxisInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__AxisInfo * SOAP_FMAC2 soap_instantiate_ns4__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__AxisInfo);
		if (size)
			*size = sizeof(ns4__AxisInfo);
		((ns4__AxisInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__AxisInfo, n);
		if (size)
			*size = n * sizeof(ns4__AxisInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__AxisInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__AxisInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__AxisInfo %p -> %p\n", q, p));
	*(ns4__AxisInfo*)p = *(ns4__AxisInfo*)q;
}

void ns4__AxesInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__AxisInfo(soap, &this->ns4__AxesInfo::AxisInfo);
	/* transient soap skipped */
}

void ns4__AxesInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__AxisInfo(soap, &this->ns4__AxesInfo::AxisInfo);
	/* transient soap skipped */
#endif
}

int ns4__AxesInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__AxesInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AxesInfo(struct soap *soap, const char *tag, int id, const ns4__AxesInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AxesInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__AxisInfo(soap, "ns4:AxisInfo", -1, &(a->ns4__AxesInfo::AxisInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__AxesInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__AxesInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__AxesInfo * SOAP_FMAC4 soap_in_ns4__AxesInfo(struct soap *soap, const char *tag, ns4__AxesInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__AxesInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AxesInfo, sizeof(ns4__AxesInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__AxesInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__AxesInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__AxisInfo(soap, "ns4:AxisInfo", &(a->ns4__AxesInfo::AxisInfo), "ns4:AxisInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__AxesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AxesInfo, 0, sizeof(ns4__AxesInfo), 0, soap_copy_ns4__AxesInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__AxesInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__AxesInfo);
	if (this->soap_out(soap, tag?tag:"ns4:AxesInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__AxesInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__AxesInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__AxesInfo * SOAP_FMAC4 soap_get_ns4__AxesInfo(struct soap *soap, ns4__AxesInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__AxesInfo * SOAP_FMAC2 soap_instantiate_ns4__AxesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__AxesInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__AxesInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__AxesInfo);
		if (size)
			*size = sizeof(ns4__AxesInfo);
		((ns4__AxesInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__AxesInfo, n);
		if (size)
			*size = n * sizeof(ns4__AxesInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__AxesInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__AxesInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__AxesInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__AxesInfo %p -> %p\n", q, p));
	*(ns4__AxesInfo*)p = *(ns4__AxesInfo*)q;
}

void ns4__Cube::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Cube::CubeName = NULL;
	/* transient soap skipped */
}

void ns4__Cube::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns4__Cube::CubeName);
	/* transient soap skipped */
#endif
}

int ns4__Cube::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Cube(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Cube(struct soap *soap, const char *tag, int id, const ns4__Cube *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Cube), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:CubeName", -1, &(a->ns4__Cube::CubeName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Cube::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Cube(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Cube * SOAP_FMAC4 soap_in_ns4__Cube(struct soap *soap, const char *tag, ns4__Cube *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Cube *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Cube, sizeof(ns4__Cube), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Cube)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Cube *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:CubeName", &(a->ns4__Cube::CubeName), "xsd:string"))
				{	soap_flag_CubeName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Cube *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Cube, 0, sizeof(ns4__Cube), 0, soap_copy_ns4__Cube);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Cube::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Cube);
	if (this->soap_out(soap, tag?tag:"ns4:Cube", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Cube::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Cube(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Cube * SOAP_FMAC4 soap_get_ns4__Cube(struct soap *soap, ns4__Cube *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Cube * SOAP_FMAC2 soap_instantiate_ns4__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Cube);
		if (size)
			*size = sizeof(ns4__Cube);
		((ns4__Cube*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Cube, n);
		if (size)
			*size = n * sizeof(ns4__Cube);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Cube*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Cube*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Cube %p -> %p\n", q, p));
	*(ns4__Cube*)p = *(ns4__Cube*)q;
}

void ns4__CubeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Cube(soap, &this->ns4__CubeInfo::Cube);
	/* transient soap skipped */
}

void ns4__CubeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Cube(soap, &this->ns4__CubeInfo::Cube);
	/* transient soap skipped */
#endif
}

int ns4__CubeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CubeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CubeInfo(struct soap *soap, const char *tag, int id, const ns4__CubeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CubeInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Cube(soap, "ns4:Cube", -1, &(a->ns4__CubeInfo::Cube), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__CubeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CubeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CubeInfo * SOAP_FMAC4 soap_in_ns4__CubeInfo(struct soap *soap, const char *tag, ns4__CubeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__CubeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CubeInfo, sizeof(ns4__CubeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CubeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__CubeInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Cube(soap, "ns4:Cube", &(a->ns4__CubeInfo::Cube), "ns4:Cube"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__CubeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CubeInfo, 0, sizeof(ns4__CubeInfo), 0, soap_copy_ns4__CubeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__CubeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CubeInfo);
	if (this->soap_out(soap, tag?tag:"ns4:CubeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__CubeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CubeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CubeInfo * SOAP_FMAC4 soap_get_ns4__CubeInfo(struct soap *soap, ns4__CubeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__CubeInfo * SOAP_FMAC2 soap_instantiate_ns4__CubeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CubeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CubeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__CubeInfo);
		if (size)
			*size = sizeof(ns4__CubeInfo);
		((ns4__CubeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__CubeInfo, n);
		if (size)
			*size = n * sizeof(ns4__CubeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__CubeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__CubeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CubeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CubeInfo %p -> %p\n", q, p));
	*(ns4__CubeInfo*)p = *(ns4__CubeInfo*)q;
}

void ns4__OlapInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__OlapInfo::CubeInfo = NULL;
	this->ns4__OlapInfo::AxesInfo = NULL;
	this->ns4__OlapInfo::CellInfo = NULL;
	/* transient soap skipped */
}

void ns4__OlapInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CubeInfo(soap, &this->ns4__OlapInfo::CubeInfo);
	soap_serialize_PointerTons4__AxesInfo(soap, &this->ns4__OlapInfo::AxesInfo);
	soap_serialize_PointerTons4__CellInfo(soap, &this->ns4__OlapInfo::CellInfo);
	/* transient soap skipped */
#endif
}

int ns4__OlapInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__OlapInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OlapInfo(struct soap *soap, const char *tag, int id, const ns4__OlapInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OlapInfo), type))
		return soap->error;
	if (soap_out_PointerTons4__CubeInfo(soap, "ns4:CubeInfo", -1, &(a->ns4__OlapInfo::CubeInfo), ""))
		return soap->error;
	if (soap_out_PointerTons4__AxesInfo(soap, "ns4:AxesInfo", -1, &(a->ns4__OlapInfo::AxesInfo), ""))
		return soap->error;
	if (soap_out_PointerTons4__CellInfo(soap, "ns4:CellInfo", -1, &(a->ns4__OlapInfo::CellInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__OlapInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__OlapInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__OlapInfo * SOAP_FMAC4 soap_in_ns4__OlapInfo(struct soap *soap, const char *tag, ns4__OlapInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__OlapInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OlapInfo, sizeof(ns4__OlapInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__OlapInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__OlapInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeInfo1 = 1;
	size_t soap_flag_AxesInfo1 = 1;
	size_t soap_flag_CellInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CubeInfo(soap, "ns4:CubeInfo", &(a->ns4__OlapInfo::CubeInfo), "ns4:CubeInfo"))
				{	soap_flag_CubeInfo1--;
					continue;
				}
			if (soap_flag_AxesInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__AxesInfo(soap, "ns4:AxesInfo", &(a->ns4__OlapInfo::AxesInfo), "ns4:AxesInfo"))
				{	soap_flag_AxesInfo1--;
					continue;
				}
			if (soap_flag_CellInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CellInfo(soap, "ns4:CellInfo", &(a->ns4__OlapInfo::CellInfo), "ns4:CellInfo"))
				{	soap_flag_CellInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__OlapInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OlapInfo, 0, sizeof(ns4__OlapInfo), 0, soap_copy_ns4__OlapInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__OlapInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__OlapInfo);
	if (this->soap_out(soap, tag?tag:"ns4:OlapInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__OlapInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__OlapInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__OlapInfo * SOAP_FMAC4 soap_get_ns4__OlapInfo(struct soap *soap, ns4__OlapInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__OlapInfo * SOAP_FMAC2 soap_instantiate_ns4__OlapInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__OlapInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__OlapInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__OlapInfo);
		if (size)
			*size = sizeof(ns4__OlapInfo);
		((ns4__OlapInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__OlapInfo, n);
		if (size)
			*size = n * sizeof(ns4__OlapInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__OlapInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__OlapInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__OlapInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__OlapInfo %p -> %p\n", q, p));
	*(ns4__OlapInfo*)p = *(ns4__OlapInfo*)q;
}

void ns4__Row::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns4__Row::__any);
	/* transient soap skipped */
}

void ns4__Row::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns4__Row::__any);
	/* transient soap skipped */
#endif
}

int ns4__Row::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Row(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Row(struct soap *soap, const char *tag, int id, const ns4__Row *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Row), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns4__Row::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Row::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Row(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Row * SOAP_FMAC4 soap_in_ns4__Row(struct soap *soap, const char *tag, ns4__Row *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Row *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Row, sizeof(ns4__Row), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Row)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Row *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns4__Row::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Row *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Row, 0, sizeof(ns4__Row), 0, soap_copy_ns4__Row);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Row::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Row);
	if (this->soap_out(soap, tag?tag:"ns4:Row", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Row::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Row(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Row * SOAP_FMAC4 soap_get_ns4__Row(struct soap *soap, ns4__Row *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Row(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Row * SOAP_FMAC2 soap_instantiate_ns4__Row(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Row(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Row, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Row);
		if (size)
			*size = sizeof(ns4__Row);
		((ns4__Row*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Row, n);
		if (size)
			*size = n * sizeof(ns4__Row);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Row*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Row*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Row(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Row %p -> %p\n", q, p));
	*(ns4__Row*)p = *(ns4__Row*)q;
}

void ns4__Members::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Member(soap, &this->ns4__Members::Member);
	this->ns4__Members::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns4__Members::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Member(soap, &this->ns4__Members::Member);
	/* transient soap skipped */
#endif
}

int ns4__Members::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Members(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Members(struct soap *soap, const char *tag, int id, const ns4__Members *a, const char *type)
{
	if (((ns4__Members*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns4__Members*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Members), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Member(soap, "ns4:Member", -1, &(a->ns4__Members::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Members::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Members(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Members * SOAP_FMAC4 soap_in_ns4__Members(struct soap *soap, const char *tag, ns4__Members *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Members *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Members, sizeof(ns4__Members), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Members)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Members *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns4__Members*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns4__Members*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Member(soap, "ns4:Member", &(a->ns4__Members::Member), "ns4:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Members *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Members, 0, sizeof(ns4__Members), 0, soap_copy_ns4__Members);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Members::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Members);
	if (this->soap_out(soap, tag?tag:"ns4:Members", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Members::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Members(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Members * SOAP_FMAC4 soap_get_ns4__Members(struct soap *soap, ns4__Members *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Members * SOAP_FMAC2 soap_instantiate_ns4__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Members);
		if (size)
			*size = sizeof(ns4__Members);
		((ns4__Members*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Members, n);
		if (size)
			*size = n * sizeof(ns4__Members);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Members*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Members*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Members %p -> %p\n", q, p));
	*(ns4__Members*)p = *(ns4__Members*)q;
}

void ns4__CrossProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Members(soap, &this->ns4__CrossProduct::Members);
	soap_default_int(soap, &this->ns4__CrossProduct::Size);
	/* transient soap skipped */
}

void ns4__CrossProduct::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Members(soap, &this->ns4__CrossProduct::Members);
	/* transient soap skipped */
#endif
}

int ns4__CrossProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CrossProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CrossProduct(struct soap *soap, const char *tag, int id, const ns4__CrossProduct *a, const char *type)
{
	soap_set_attr(soap, "Size", soap_int2s(soap, ((ns4__CrossProduct*)a)->Size), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CrossProduct), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Members(soap, "ns4:Members", -1, &(a->ns4__CrossProduct::Members), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__CrossProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CrossProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CrossProduct * SOAP_FMAC4 soap_in_ns4__CrossProduct(struct soap *soap, const char *tag, ns4__CrossProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__CrossProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CrossProduct, sizeof(ns4__CrossProduct), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CrossProduct)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__CrossProduct *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Size", 1), &((ns4__CrossProduct*)a)->Size))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Members(soap, "ns4:Members", &(a->ns4__CrossProduct::Members), "ns4:Members"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__CrossProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CrossProduct, 0, sizeof(ns4__CrossProduct), 0, soap_copy_ns4__CrossProduct);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__CrossProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CrossProduct);
	if (this->soap_out(soap, tag?tag:"ns4:CrossProduct", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__CrossProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CrossProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CrossProduct * SOAP_FMAC4 soap_get_ns4__CrossProduct(struct soap *soap, ns4__CrossProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__CrossProduct * SOAP_FMAC2 soap_instantiate_ns4__CrossProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CrossProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CrossProduct, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__CrossProduct);
		if (size)
			*size = sizeof(ns4__CrossProduct);
		((ns4__CrossProduct*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__CrossProduct, n);
		if (size)
			*size = n * sizeof(ns4__CrossProduct);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__CrossProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__CrossProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CrossProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CrossProduct %p -> %p\n", q, p));
	*(ns4__CrossProduct*)p = *(ns4__CrossProduct*)q;
}

void ns4__Member::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Member::UName = NULL;
	this->ns4__Member::Caption = NULL;
	this->ns4__Member::LName = NULL;
	this->ns4__Member::LNum = NULL;
	this->ns4__Member::DisplayInfo = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns4__Member::__any);
	this->ns4__Member::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns4__Member::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns4__Member::UName);
	soap_serialize_PointerTostd__string(soap, &this->ns4__Member::Caption);
	soap_serialize_PointerTostd__string(soap, &this->ns4__Member::LName);
	soap_serialize_PointerTostd__string(soap, &this->ns4__Member::LNum);
	soap_serialize_PointerTostd__string(soap, &this->ns4__Member::DisplayInfo);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns4__Member::__any);
	/* transient soap skipped */
#endif
}

int ns4__Member::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Member(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Member(struct soap *soap, const char *tag, int id, const ns4__Member *a, const char *type)
{
	if (((ns4__Member*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns4__Member*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Member), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:UName", -1, &(a->ns4__Member::UName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Caption", -1, &(a->ns4__Member::Caption), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:LName", -1, &(a->ns4__Member::LName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:LNum", -1, &(a->ns4__Member::LNum), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:DisplayInfo", -1, &(a->ns4__Member::DisplayInfo), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns4__Member::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Member::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Member(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Member * SOAP_FMAC4 soap_in_ns4__Member(struct soap *soap, const char *tag, ns4__Member *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Member *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Member, sizeof(ns4__Member), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Member)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Member *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns4__Member*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns4__Member*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_UName1 = 1;
	size_t soap_flag_Caption1 = 1;
	size_t soap_flag_LName1 = 1;
	size_t soap_flag_LNum1 = 1;
	size_t soap_flag_DisplayInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:UName", &(a->ns4__Member::UName), "xsd:string"))
				{	soap_flag_UName1--;
					continue;
				}
			if (soap_flag_Caption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:Caption", &(a->ns4__Member::Caption), "xsd:string"))
				{	soap_flag_Caption1--;
					continue;
				}
			if (soap_flag_LName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:LName", &(a->ns4__Member::LName), "xsd:string"))
				{	soap_flag_LName1--;
					continue;
				}
			if (soap_flag_LNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:LNum", &(a->ns4__Member::LNum), "xsd:string"))
				{	soap_flag_LNum1--;
					continue;
				}
			if (soap_flag_DisplayInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DisplayInfo", &(a->ns4__Member::DisplayInfo), "xsd:string"))
				{	soap_flag_DisplayInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns4__Member::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Member *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Member, 0, sizeof(ns4__Member), 0, soap_copy_ns4__Member);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Member::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Member);
	if (this->soap_out(soap, tag?tag:"ns4:Member", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Member::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Member(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Member * SOAP_FMAC4 soap_get_ns4__Member(struct soap *soap, ns4__Member *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Member * SOAP_FMAC2 soap_instantiate_ns4__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Member);
		if (size)
			*size = sizeof(ns4__Member);
		((ns4__Member*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Member, n);
		if (size)
			*size = n * sizeof(ns4__Member);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Member*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Member*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Member %p -> %p\n", q, p));
	*(ns4__Member*)p = *(ns4__Member*)q;
}

void ns4__Tuple::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Member(soap, &this->ns4__Tuple::Member);
	/* transient soap skipped */
}

void ns4__Tuple::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Member(soap, &this->ns4__Tuple::Member);
	/* transient soap skipped */
#endif
}

int ns4__Tuple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Tuple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Tuple(struct soap *soap, const char *tag, int id, const ns4__Tuple *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Tuple), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Member(soap, "ns4:Member", -1, &(a->ns4__Tuple::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Tuple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Tuple(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Tuple * SOAP_FMAC4 soap_in_ns4__Tuple(struct soap *soap, const char *tag, ns4__Tuple *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Tuple *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Tuple, sizeof(ns4__Tuple), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Tuple)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Tuple *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Member(soap, "ns4:Member", &(a->ns4__Tuple::Member), "ns4:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Tuple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Tuple, 0, sizeof(ns4__Tuple), 0, soap_copy_ns4__Tuple);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Tuple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Tuple);
	if (this->soap_out(soap, tag?tag:"ns4:Tuple", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Tuple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Tuple(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Tuple * SOAP_FMAC4 soap_get_ns4__Tuple(struct soap *soap, ns4__Tuple *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Tuple * SOAP_FMAC2 soap_instantiate_ns4__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Tuple);
		if (size)
			*size = sizeof(ns4__Tuple);
		((ns4__Tuple*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Tuple, n);
		if (size)
			*size = n * sizeof(ns4__Tuple);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Tuple*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Tuple*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Tuple %p -> %p\n", q, p));
	*(ns4__Tuple*)p = *(ns4__Tuple*)q;
}

void ns4__Tuples::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Tuple(soap, &this->ns4__Tuples::Tuple);
	/* transient soap skipped */
}

void ns4__Tuples::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Tuple(soap, &this->ns4__Tuples::Tuple);
	/* transient soap skipped */
#endif
}

int ns4__Tuples::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Tuples(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Tuples(struct soap *soap, const char *tag, int id, const ns4__Tuples *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Tuples), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Tuple(soap, "ns4:Tuple", -1, &(a->ns4__Tuples::Tuple), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Tuples::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Tuples(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Tuples * SOAP_FMAC4 soap_in_ns4__Tuples(struct soap *soap, const char *tag, ns4__Tuples *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Tuples *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Tuples, sizeof(ns4__Tuples), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Tuples)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Tuples *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Tuple(soap, "ns4:Tuple", &(a->ns4__Tuples::Tuple), "ns4:Tuple"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Tuples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Tuples, 0, sizeof(ns4__Tuples), 0, soap_copy_ns4__Tuples);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Tuples::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Tuples);
	if (this->soap_out(soap, tag?tag:"ns4:Tuples", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Tuples::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Tuples(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Tuples * SOAP_FMAC4 soap_get_ns4__Tuples(struct soap *soap, ns4__Tuples *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Tuples * SOAP_FMAC2 soap_instantiate_ns4__Tuples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Tuples(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Tuples, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Tuples);
		if (size)
			*size = sizeof(ns4__Tuples);
		((ns4__Tuples*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Tuples, n);
		if (size)
			*size = n * sizeof(ns4__Tuples);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Tuples*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Tuples*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Tuples(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Tuples %p -> %p\n", q, p));
	*(ns4__Tuples*)p = *(ns4__Tuples*)q;
}

void ns4__Axis::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Axis::__size_Axis = 0;
	this->ns4__Axis::__union_Axis = NULL;
	this->ns4__Axis::name = NULL;
	/* transient soap skipped */
}

void ns4__Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < this->ns4__Axis::__size_Axis; i++)
		{
			this->ns4__Axis::__union_Axis[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns4__Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Axis(struct soap *soap, const char *tag, int id, const ns4__Axis *a, const char *type)
{
	if (((ns4__Axis*)a)->name)
		soap_set_attr(soap, "name", ((ns4__Axis*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Axis), type))
		return soap->error;
	if (a->ns4__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < a->ns4__Axis::__size_Axis; i++)
			if (a->ns4__Axis::__union_Axis[i].soap_out(soap, "-union-Axis", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Axis(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Axis * SOAP_FMAC4 soap_in_ns4__Axis(struct soap *soap, const char *tag, ns4__Axis *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Axis *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Axis, sizeof(ns4__Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Axis)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Axis *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns4__Axis*)a)->name = soap_new_std__string(soap, -1);
				((ns4__Axis*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_Axis1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns4__Axis::__union_Axis == NULL)
				{	if (soap_blist___union_Axis1 == NULL)
						soap_blist___union_Axis1 = soap_new_block(soap);
					a->ns4__Axis::__union_Axis = (__ns4__union_Axis *)soap_push_block(soap, soap_blist___union_Axis1, sizeof(__ns4__union_Axis));
					if (a->ns4__Axis::__union_Axis == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns4__Axis::__union_Axis, __ns4__union_Axis);
					a->ns4__Axis::__union_Axis->soap_default(soap);
				}
				if (soap_in___ns4__union_Axis(soap, "-union-Axis", a->ns4__Axis::__union_Axis, "-ns4:union-Axis"))
				{	a->ns4__Axis::__size_Axis++;
					a->ns4__Axis::__union_Axis = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__Axis::__union_Axis)
			soap_pop_block(soap, soap_blist___union_Axis1);
		if (a->ns4__Axis::__size_Axis)
			a->ns4__Axis::__union_Axis = (__ns4__union_Axis *)soap_save_block(soap, soap_blist___union_Axis1, NULL, 1);
		else
		{	a->ns4__Axis::__union_Axis = NULL;
			if (soap_blist___union_Axis1)
				soap_end_block(soap, soap_blist___union_Axis1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Axis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Axis, 0, sizeof(ns4__Axis), 0, soap_copy_ns4__Axis);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Axis);
	if (this->soap_out(soap, tag?tag:"ns4:Axis", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Axis(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Axis * SOAP_FMAC4 soap_get_ns4__Axis(struct soap *soap, ns4__Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Axis * SOAP_FMAC2 soap_instantiate_ns4__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Axis);
		if (size)
			*size = sizeof(ns4__Axis);
		((ns4__Axis*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Axis, n);
		if (size)
			*size = n * sizeof(ns4__Axis);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Axis*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Axis %p -> %p\n", q, p));
	*(ns4__Axis*)p = *(ns4__Axis*)q;
}

void ns4__Axes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Axis(soap, &this->ns4__Axes::Axis);
	/* transient soap skipped */
}

void ns4__Axes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Axis(soap, &this->ns4__Axes::Axis);
	/* transient soap skipped */
#endif
}

int ns4__Axes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Axes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Axes(struct soap *soap, const char *tag, int id, const ns4__Axes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Axes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Axis(soap, "ns4:Axis", -1, &(a->ns4__Axes::Axis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Axes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Axes(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Axes * SOAP_FMAC4 soap_in_ns4__Axes(struct soap *soap, const char *tag, ns4__Axes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Axes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Axes, sizeof(ns4__Axes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Axes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Axes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Axis(soap, "ns4:Axis", &(a->ns4__Axes::Axis), "ns4:Axis"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Axes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Axes, 0, sizeof(ns4__Axes), 0, soap_copy_ns4__Axes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Axes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Axes);
	if (this->soap_out(soap, tag?tag:"ns4:Axes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Axes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Axes(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Axes * SOAP_FMAC4 soap_get_ns4__Axes(struct soap *soap, ns4__Axes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Axes * SOAP_FMAC2 soap_instantiate_ns4__Axes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Axes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Axes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Axes);
		if (size)
			*size = sizeof(ns4__Axes);
		((ns4__Axes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Axes, n);
		if (size)
			*size = n * sizeof(ns4__Axes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Axes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Axes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Axes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Axes %p -> %p\n", q, p));
	*(ns4__Axes*)p = *(ns4__Axes*)q;
}

void ns4__Cell::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Cell::Value = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns4__Cell::__any);
	soap_default_int(soap, &this->ns4__Cell::CellOrdinal);
	/* transient soap skipped */
}

void ns4__Cell::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns4__Cell::Value);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns4__Cell::__any);
	/* transient soap skipped */
#endif
}

int ns4__Cell::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Cell(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Cell(struct soap *soap, const char *tag, int id, const ns4__Cell *a, const char *type)
{
	soap_set_attr(soap, "CellOrdinal", soap_int2s(soap, ((ns4__Cell*)a)->CellOrdinal), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Cell), type))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Value", -1, &(a->ns4__Cell::Value), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns4__Cell::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Cell::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Cell(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Cell * SOAP_FMAC4 soap_in_ns4__Cell(struct soap *soap, const char *tag, ns4__Cell *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Cell *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Cell, sizeof(ns4__Cell), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Cell)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Cell *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "CellOrdinal", 1), &((ns4__Cell*)a)->CellOrdinal))
		return NULL;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Value", &(a->ns4__Cell::Value), "xsd:double"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns4__Cell::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Cell *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Cell, 0, sizeof(ns4__Cell), 0, soap_copy_ns4__Cell);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Cell::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Cell);
	if (this->soap_out(soap, tag?tag:"ns4:Cell", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Cell::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Cell(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Cell * SOAP_FMAC4 soap_get_ns4__Cell(struct soap *soap, ns4__Cell *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Cell * SOAP_FMAC2 soap_instantiate_ns4__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__Cell);
		if (size)
			*size = sizeof(ns4__Cell);
		((ns4__Cell*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__Cell, n);
		if (size)
			*size = n * sizeof(ns4__Cell);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__Cell*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__Cell*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Cell %p -> %p\n", q, p));
	*(ns4__Cell*)p = *(ns4__Cell*)q;
}

void ns4__CellData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Cell(soap, &this->ns4__CellData::Cell);
	/* transient soap skipped */
}

void ns4__CellData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__Cell(soap, &this->ns4__CellData::Cell);
	/* transient soap skipped */
#endif
}

int ns4__CellData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CellData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CellData(struct soap *soap, const char *tag, int id, const ns4__CellData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CellData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Cell(soap, "ns4:Cell", -1, &(a->ns4__CellData::Cell), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__CellData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CellData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CellData * SOAP_FMAC4 soap_in_ns4__CellData(struct soap *soap, const char *tag, ns4__CellData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__CellData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CellData, sizeof(ns4__CellData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CellData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__CellData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__Cell(soap, "ns4:Cell", &(a->ns4__CellData::Cell), "ns4:Cell"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__CellData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CellData, 0, sizeof(ns4__CellData), 0, soap_copy_ns4__CellData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__CellData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CellData);
	if (this->soap_out(soap, tag?tag:"ns4:CellData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__CellData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CellData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CellData * SOAP_FMAC4 soap_get_ns4__CellData(struct soap *soap, ns4__CellData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__CellData * SOAP_FMAC2 soap_instantiate_ns4__CellData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CellData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CellData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__CellData);
		if (size)
			*size = sizeof(ns4__CellData);
		((ns4__CellData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__CellData, n);
		if (size)
			*size = n * sizeof(ns4__CellData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__CellData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__CellData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CellData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CellData %p -> %p\n", q, p));
	*(ns4__CellData*)p = *(ns4__CellData*)q;
}

void ns4__ResultXmlRoot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xsd__schema(soap, &this->ns4__ResultXmlRoot::xsd__schema);
	this->ns4__ResultXmlRoot::__size_ResultXmlRoot = 0;
	this->ns4__ResultXmlRoot::__union_ResultXmlRoot = NULL;
	/* transient soap skipped */
}

void ns4__ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__xsd__schema(soap, &this->ns4__ResultXmlRoot::xsd__schema);
	if (this->ns4__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < this->ns4__ResultXmlRoot::__size_ResultXmlRoot; i++)
		{
			this->ns4__ResultXmlRoot::__union_ResultXmlRoot[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns4__ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResultXmlRoot(struct soap *soap, const char *tag, int id, const ns4__ResultXmlRoot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResultXmlRoot), type))
		return soap->error;
	if (soap_out__xsd__schema(soap, "xsd:schema", -1, &(a->ns4__ResultXmlRoot::xsd__schema), ""))
		return soap->error;
	if (a->ns4__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < a->ns4__ResultXmlRoot::__size_ResultXmlRoot; i++)
			if (a->ns4__ResultXmlRoot::__union_ResultXmlRoot[i].soap_out(soap, "-union-ResultXmlRoot", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ResultXmlRoot * SOAP_FMAC4 soap_in_ns4__ResultXmlRoot(struct soap *soap, const char *tag, ns4__ResultXmlRoot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ResultXmlRoot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResultXmlRoot, sizeof(ns4__ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ResultXmlRoot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ResultXmlRoot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xsd__schema1 = 1;
	struct soap_blist *soap_blist___union_ResultXmlRoot1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__xsd__schema(soap, "xsd:schema", &(a->ns4__ResultXmlRoot::xsd__schema), ""))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns4__ResultXmlRoot::__union_ResultXmlRoot == NULL)
				{	if (soap_blist___union_ResultXmlRoot1 == NULL)
						soap_blist___union_ResultXmlRoot1 = soap_new_block(soap);
					a->ns4__ResultXmlRoot::__union_ResultXmlRoot = (__ns4__union_ResultXmlRoot *)soap_push_block(soap, soap_blist___union_ResultXmlRoot1, sizeof(__ns4__union_ResultXmlRoot));
					if (a->ns4__ResultXmlRoot::__union_ResultXmlRoot == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns4__ResultXmlRoot::__union_ResultXmlRoot, __ns4__union_ResultXmlRoot);
					a->ns4__ResultXmlRoot::__union_ResultXmlRoot->soap_default(soap);
				}
				if (soap_in___ns4__union_ResultXmlRoot(soap, "-union-ResultXmlRoot", a->ns4__ResultXmlRoot::__union_ResultXmlRoot, "-ns4:union-ResultXmlRoot"))
				{	a->ns4__ResultXmlRoot::__size_ResultXmlRoot++;
					a->ns4__ResultXmlRoot::__union_ResultXmlRoot = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ResultXmlRoot::__union_ResultXmlRoot)
			soap_pop_block(soap, soap_blist___union_ResultXmlRoot1);
		if (a->ns4__ResultXmlRoot::__size_ResultXmlRoot)
			a->ns4__ResultXmlRoot::__union_ResultXmlRoot = (__ns4__union_ResultXmlRoot *)soap_save_block(soap, soap_blist___union_ResultXmlRoot1, NULL, 1);
		else
		{	a->ns4__ResultXmlRoot::__union_ResultXmlRoot = NULL;
			if (soap_blist___union_ResultXmlRoot1)
				soap_end_block(soap, soap_blist___union_ResultXmlRoot1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ResultXmlRoot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResultXmlRoot, 0, sizeof(ns4__ResultXmlRoot), 0, soap_copy_ns4__ResultXmlRoot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ResultXmlRoot);
	if (this->soap_out(soap, tag?tag:"ns4:ResultXmlRoot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ResultXmlRoot * SOAP_FMAC4 soap_get_ns4__ResultXmlRoot(struct soap *soap, ns4__ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ResultXmlRoot * SOAP_FMAC2 soap_instantiate_ns4__ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__ResultXmlRoot);
		if (size)
			*size = sizeof(ns4__ResultXmlRoot);
		((ns4__ResultXmlRoot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(ns4__ResultXmlRoot);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__ResultXmlRoot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ResultXmlRoot %p -> %p\n", q, p));
	*(ns4__ResultXmlRoot*)p = *(ns4__ResultXmlRoot*)q;
}

void ns3__XmlSchemaInclude::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaInclude::annotation = NULL;
}

void ns3__XmlSchemaInclude::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, &this->ns3__XmlSchemaInclude::annotation);
#endif
}

int ns3__XmlSchemaInclude::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaInclude(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaInclude(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaInclude *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaInclude), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", -1, &(a->ns3__XmlSchemaInclude::annotation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaInclude::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaInclude(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaInclude * SOAP_FMAC4 soap_in_ns3__XmlSchemaInclude(struct soap *soap, const char *tag, ns3__XmlSchemaInclude *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaInclude *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaInclude, sizeof(ns3__XmlSchemaInclude), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaInclude)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaInclude *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annotation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", &(a->ns3__XmlSchemaInclude::annotation), "xsd:XmlSchemaAnnotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaInclude *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaInclude, 0, sizeof(ns3__XmlSchemaInclude), 0, soap_copy_ns3__XmlSchemaInclude);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaInclude::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaInclude);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaInclude", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaInclude::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaInclude(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaInclude * SOAP_FMAC4 soap_get_ns3__XmlSchemaInclude(struct soap *soap, ns3__XmlSchemaInclude *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaInclude * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaInclude(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaInclude(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaInclude, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaInclude);
		if (size)
			*size = sizeof(ns3__XmlSchemaInclude);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaInclude, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaInclude);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaInclude*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaInclude(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaInclude %p -> %p\n", q, p));
	*(ns3__XmlSchemaInclude*)p = *(ns3__XmlSchemaInclude*)q;
}

void ns3__XmlSchemaRedefine::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaRedefine::__size_XmlSchemaRedefine = 0;
	this->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine = NULL;
}

void ns3__XmlSchemaRedefine::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaRedefine::__size_XmlSchemaRedefine; i++)
		{
			this->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaRedefine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaRedefine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaRedefine(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaRedefine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaRedefine), type))
		return soap->error;
	if (a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaRedefine::__size_XmlSchemaRedefine; i++)
			if (a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine[i].soap_out(soap, "-union-XmlSchemaRedefine", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaRedefine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaRedefine(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaRedefine * SOAP_FMAC4 soap_in_ns3__XmlSchemaRedefine(struct soap *soap, const char *tag, ns3__XmlSchemaRedefine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaRedefine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaRedefine, sizeof(ns3__XmlSchemaRedefine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaRedefine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaRedefine *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_XmlSchemaRedefine1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine == NULL)
				{	if (soap_blist___union_XmlSchemaRedefine1 == NULL)
						soap_blist___union_XmlSchemaRedefine1 = soap_new_block(soap);
					a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine = (__ns3__union_XmlSchemaRedefine *)soap_push_block(soap, soap_blist___union_XmlSchemaRedefine1, sizeof(__ns3__union_XmlSchemaRedefine));
					if (a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine, __ns3__union_XmlSchemaRedefine);
					a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaRedefine(soap, "-union-XmlSchemaRedefine", a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine, "-ns3:union-XmlSchemaRedefine"))
				{	a->ns3__XmlSchemaRedefine::__size_XmlSchemaRedefine++;
					a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine)
			soap_pop_block(soap, soap_blist___union_XmlSchemaRedefine1);
		if (a->ns3__XmlSchemaRedefine::__size_XmlSchemaRedefine)
			a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine = (__ns3__union_XmlSchemaRedefine *)soap_save_block(soap, soap_blist___union_XmlSchemaRedefine1, NULL, 1);
		else
		{	a->ns3__XmlSchemaRedefine::__union_XmlSchemaRedefine = NULL;
			if (soap_blist___union_XmlSchemaRedefine1)
				soap_end_block(soap, soap_blist___union_XmlSchemaRedefine1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaRedefine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaRedefine, 0, sizeof(ns3__XmlSchemaRedefine), 0, soap_copy_ns3__XmlSchemaRedefine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaRedefine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaRedefine);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaRedefine", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaRedefine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaRedefine(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaRedefine * SOAP_FMAC4 soap_get_ns3__XmlSchemaRedefine(struct soap *soap, ns3__XmlSchemaRedefine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaRedefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaRedefine * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaRedefine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaRedefine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaRedefine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaRedefine);
		if (size)
			*size = sizeof(ns3__XmlSchemaRedefine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaRedefine, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaRedefine);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaRedefine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaRedefine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaRedefine %p -> %p\n", q, p));
	*(ns3__XmlSchemaRedefine*)p = *(ns3__XmlSchemaRedefine*)q;
}

void ns3__XmlSchemaImport::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaImport::annotation = NULL;
	this->ns3__XmlSchemaImport::namespace_ = NULL;
}

void ns3__XmlSchemaImport::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, &this->ns3__XmlSchemaImport::annotation);
#endif
}

int ns3__XmlSchemaImport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaImport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaImport(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaImport *a, const char *type)
{
	if (((ns3__XmlSchemaImport*)a)->namespace_)
		soap_set_attr(soap, "namespace", ((ns3__XmlSchemaImport*)a)->namespace_->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaImport), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", -1, &(a->ns3__XmlSchemaImport::annotation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaImport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaImport(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaImport * SOAP_FMAC4 soap_in_ns3__XmlSchemaImport(struct soap *soap, const char *tag, ns3__XmlSchemaImport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaImport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaImport, sizeof(ns3__XmlSchemaImport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaImport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaImport *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "namespace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaImport*)a)->namespace_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaImport*)a)->namespace_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_annotation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", &(a->ns3__XmlSchemaImport::annotation), "xsd:XmlSchemaAnnotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaImport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaImport, 0, sizeof(ns3__XmlSchemaImport), 0, soap_copy_ns3__XmlSchemaImport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaImport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaImport);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaImport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaImport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaImport(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaImport * SOAP_FMAC4 soap_get_ns3__XmlSchemaImport(struct soap *soap, ns3__XmlSchemaImport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaImport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaImport * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaImport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaImport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaImport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaImport);
		if (size)
			*size = sizeof(ns3__XmlSchemaImport);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaImport, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaImport);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaImport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaImport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaImport %p -> %p\n", q, p));
	*(ns3__XmlSchemaImport*)p = *(ns3__XmlSchemaImport*)q;
}

void ns3__XmlSchemaExternal::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaExternal::schemaLocation = NULL;
	this->ns3__XmlSchemaExternal::id = NULL;
	this->ns3__XmlSchemaExternal::__anyAttribute = NULL;
}

void ns3__XmlSchemaExternal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaExternal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaExternal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaExternal(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaExternal *a, const char *type)
{
	if (((ns3__XmlSchemaExternal*)a)->schemaLocation)
		soap_set_attr(soap, "schemaLocation", ((ns3__XmlSchemaExternal*)a)->schemaLocation->c_str(), 1);
	if (((ns3__XmlSchemaExternal*)a)->id)
		soap_set_attr(soap, "id", ((ns3__XmlSchemaExternal*)a)->id->c_str(), 1);
	if (((ns3__XmlSchemaExternal*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__XmlSchemaExternal*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaExternal), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaExternal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaExternal(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaExternal * SOAP_FMAC4 soap_in_ns3__XmlSchemaExternal(struct soap *soap, const char *tag, ns3__XmlSchemaExternal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaExternal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaExternal, sizeof(ns3__XmlSchemaExternal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaExternal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaExternal *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "schemaLocation", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaExternal*)a)->schemaLocation = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaExternal*)a)->schemaLocation->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaExternal*)a)->id = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaExternal*)a)->id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns3__XmlSchemaExternal*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaExternal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaExternal, 0, sizeof(ns3__XmlSchemaExternal), 0, soap_copy_ns3__XmlSchemaExternal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaExternal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaExternal);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaExternal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaExternal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaExternal(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaExternal * SOAP_FMAC4 soap_get_ns3__XmlSchemaExternal(struct soap *soap, ns3__XmlSchemaExternal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaExternal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaExternal * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaExternal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaExternal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaExternal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaExternal);
		if (size)
			*size = sizeof(ns3__XmlSchemaExternal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaExternal, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaExternal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaExternal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaExternal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaExternal %p -> %p\n", q, p));
	*(ns3__XmlSchemaExternal*)p = *(ns3__XmlSchemaExternal*)q;
}

void ns3__XmlSchemaGroup::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaGroup::sequence = NULL;
	this->ns3__XmlSchemaGroup::choice = NULL;
	this->ns3__XmlSchemaGroup::all = NULL;
	this->ns3__XmlSchemaGroup::name = NULL;
}

void ns3__XmlSchemaGroup::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->ns3__XmlSchemaGroup::sequence);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->ns3__XmlSchemaGroup::choice);
	soap_serialize_PointerToxsd__XmlSchemaAll(soap, &this->ns3__XmlSchemaGroup::all);
#endif
}

int ns3__XmlSchemaGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaGroup(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaGroup *a, const char *type)
{
	if (((ns3__XmlSchemaGroup*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaGroup*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaGroup), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->ns3__XmlSchemaGroup::sequence), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->ns3__XmlSchemaGroup::choice), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAll(soap, "ns3:all", -1, &(a->ns3__XmlSchemaGroup::all), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroup * SOAP_FMAC4 soap_in_ns3__XmlSchemaGroup(struct soap *soap, const char *tag, ns3__XmlSchemaGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaGroup, sizeof(ns3__XmlSchemaGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaGroup *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaGroup*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaGroup*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_all1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->ns3__XmlSchemaGroup::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->ns3__XmlSchemaGroup::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap_flag_all1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAll(soap, "ns3:all", &(a->ns3__XmlSchemaGroup::all), "xsd:XmlSchemaAll"))
				{	soap_flag_all1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaGroup, 0, sizeof(ns3__XmlSchemaGroup), 0, soap_copy_ns3__XmlSchemaGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaGroup);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroup * SOAP_FMAC4 soap_get_ns3__XmlSchemaGroup(struct soap *soap, ns3__XmlSchemaGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaGroup * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaGroup);
		if (size)
			*size = sizeof(ns3__XmlSchemaGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaGroup, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaGroup %p -> %p\n", q, p));
	*(ns3__XmlSchemaGroup*)p = *(ns3__XmlSchemaGroup*)q;
}

void ns3__XmlSchemaSimpleTypeList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleTypeList::simpleType = NULL;
	this->ns3__XmlSchemaSimpleTypeList::itemType = NULL;
}

void ns3__XmlSchemaSimpleTypeList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaSimpleTypeList::simpleType);
#endif
}

int ns3__XmlSchemaSimpleTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleTypeList *a, const char *type)
{
	if (((ns3__XmlSchemaSimpleTypeList*)a)->itemType)
		soap_set_attr(soap, "itemType", soap_QName2s(soap, ((ns3__XmlSchemaSimpleTypeList*)a)->itemType->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeList), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaSimpleTypeList::simpleType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleTypeList(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeList * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleTypeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleTypeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeList, sizeof(ns3__XmlSchemaSimpleTypeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleTypeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleTypeList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "itemType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaSimpleTypeList*)a)->itemType = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaSimpleTypeList*)a)->itemType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_simpleType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaSimpleTypeList::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleTypeList, 0, sizeof(ns3__XmlSchemaSimpleTypeList), 0, soap_copy_ns3__XmlSchemaSimpleTypeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleTypeList);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleTypeList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleTypeList(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeList * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleTypeList(struct soap *soap, ns3__XmlSchemaSimpleTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleTypeList * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleTypeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleTypeList);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleTypeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleTypeList, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleTypeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleTypeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleTypeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleTypeList %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleTypeList*)p = *(ns3__XmlSchemaSimpleTypeList*)q;
}

void ns3__XmlSchemaSimpleTypeRestriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleTypeRestriction::simpleType = NULL;
	this->ns3__XmlSchemaSimpleTypeRestriction::__size_XmlSchemaSimpleTypeRestriction = 0;
	this->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction = NULL;
	this->ns3__XmlSchemaSimpleTypeRestriction::base = NULL;
}

void ns3__XmlSchemaSimpleTypeRestriction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaSimpleTypeRestriction::simpleType);
	if (this->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaSimpleTypeRestriction::__size_XmlSchemaSimpleTypeRestriction; i++)
		{
			this->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaSimpleTypeRestriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleTypeRestriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleTypeRestriction *a, const char *type)
{
	if (((ns3__XmlSchemaSimpleTypeRestriction*)a)->base)
		soap_set_attr(soap, "base", soap_QName2s(soap, ((ns3__XmlSchemaSimpleTypeRestriction*)a)->base->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaSimpleTypeRestriction::simpleType), ""))
		return soap->error;
	if (a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaSimpleTypeRestriction::__size_XmlSchemaSimpleTypeRestriction; i++)
			if (a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction[i].soap_out(soap, "-union-XmlSchemaSimpleTypeRestriction", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleTypeRestriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleTypeRestriction(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeRestriction * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleTypeRestriction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleTypeRestriction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction, sizeof(ns3__XmlSchemaSimpleTypeRestriction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleTypeRestriction *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "base", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaSimpleTypeRestriction*)a)->base = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaSimpleTypeRestriction*)a)->base->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_simpleType1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaSimpleTypeRestriction1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaSimpleTypeRestriction::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction == NULL)
				{	if (soap_blist___union_XmlSchemaSimpleTypeRestriction1 == NULL)
						soap_blist___union_XmlSchemaSimpleTypeRestriction1 = soap_new_block(soap);
					a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction = (__ns3__union_XmlSchemaSimpleTypeRestriction *)soap_push_block(soap, soap_blist___union_XmlSchemaSimpleTypeRestriction1, sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction));
					if (a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction, __ns3__union_XmlSchemaSimpleTypeRestriction);
					a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaSimpleTypeRestriction(soap, "-union-XmlSchemaSimpleTypeRestriction", a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction, "-ns3:union-XmlSchemaSimpleTypeRestriction"))
				{	a->ns3__XmlSchemaSimpleTypeRestriction::__size_XmlSchemaSimpleTypeRestriction++;
					a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction)
			soap_pop_block(soap, soap_blist___union_XmlSchemaSimpleTypeRestriction1);
		if (a->ns3__XmlSchemaSimpleTypeRestriction::__size_XmlSchemaSimpleTypeRestriction)
			a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction = (__ns3__union_XmlSchemaSimpleTypeRestriction *)soap_save_block(soap, soap_blist___union_XmlSchemaSimpleTypeRestriction1, NULL, 1);
		else
		{	a->ns3__XmlSchemaSimpleTypeRestriction::__union_XmlSchemaSimpleTypeRestriction = NULL;
			if (soap_blist___union_XmlSchemaSimpleTypeRestriction1)
				soap_end_block(soap, soap_blist___union_XmlSchemaSimpleTypeRestriction1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleTypeRestriction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction, 0, sizeof(ns3__XmlSchemaSimpleTypeRestriction), 0, soap_copy_ns3__XmlSchemaSimpleTypeRestriction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleTypeRestriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleTypeRestriction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleTypeRestriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleTypeRestriction(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeRestriction * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleTypeRestriction(struct soap *soap, ns3__XmlSchemaSimpleTypeRestriction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleTypeRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleTypeRestriction * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleTypeRestriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleTypeRestriction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleTypeRestriction);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleTypeRestriction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleTypeRestriction, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleTypeRestriction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleTypeRestriction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleTypeRestriction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleTypeRestriction %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleTypeRestriction*)p = *(ns3__XmlSchemaSimpleTypeRestriction*)q;
}

void ns3__XmlSchemaSimpleTypeContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaSimpleTypeContent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaSimpleTypeContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleTypeContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleTypeContent(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleTypeContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleTypeContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleTypeContent(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeContent * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleTypeContent(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleTypeContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleTypeContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent, sizeof(ns3__XmlSchemaSimpleTypeContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleTypeContent *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleTypeContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent, 0, sizeof(ns3__XmlSchemaSimpleTypeContent), 0, soap_copy_ns3__XmlSchemaSimpleTypeContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleTypeContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleTypeContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleTypeContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleTypeContent(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeContent * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleTypeContent(struct soap *soap, ns3__XmlSchemaSimpleTypeContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleTypeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleTypeContent * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleTypeContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleTypeContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleTypeContent);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleTypeContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleTypeContent, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleTypeContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleTypeContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleTypeContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleTypeContent %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleTypeContent*)p = *(ns3__XmlSchemaSimpleTypeContent*)q;
}

void ns3__XmlSchemaSimpleTypeUnion::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaSimpleTypeUnion::simpleType);
	this->ns3__XmlSchemaSimpleTypeUnion::memberTypes = NULL;
}

void ns3__XmlSchemaSimpleTypeUnion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaSimpleTypeUnion::simpleType);
#endif
}

int ns3__XmlSchemaSimpleTypeUnion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleTypeUnion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleTypeUnion *a, const char *type)
{
	if (((ns3__XmlSchemaSimpleTypeUnion*)a)->memberTypes)
		soap_set_attr(soap, "memberTypes", soap_QName2s(soap, ((ns3__XmlSchemaSimpleTypeUnion*)a)->memberTypes->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaSimpleTypeUnion::simpleType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleTypeUnion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleTypeUnion(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeUnion * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleTypeUnion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleTypeUnion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion, sizeof(ns3__XmlSchemaSimpleTypeUnion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleTypeUnion *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "memberTypes", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaSimpleTypeUnion*)a)->memberTypes = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaSimpleTypeUnion*)a)->memberTypes->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaSimpleTypeUnion::simpleType), "xsd:XmlSchemaSimpleType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleTypeUnion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion, 0, sizeof(ns3__XmlSchemaSimpleTypeUnion), 0, soap_copy_ns3__XmlSchemaSimpleTypeUnion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleTypeUnion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleTypeUnion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleTypeUnion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleTypeUnion(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleTypeUnion * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleTypeUnion(struct soap *soap, ns3__XmlSchemaSimpleTypeUnion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleTypeUnion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleTypeUnion * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleTypeUnion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleTypeUnion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleTypeUnion);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleTypeUnion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleTypeUnion, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleTypeUnion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleTypeUnion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleTypeUnion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleTypeUnion %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleTypeUnion*)p = *(ns3__XmlSchemaSimpleTypeUnion*)q;
}

void ns3__XmlSchemaMaxExclusiveFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMaxExclusiveFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMaxExclusiveFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMaxExclusiveFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMaxExclusiveFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMaxExclusiveFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMaxExclusiveFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxExclusiveFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMaxExclusiveFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMaxExclusiveFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet, sizeof(ns3__XmlSchemaMaxExclusiveFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMaxExclusiveFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMaxExclusiveFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet, 0, sizeof(ns3__XmlSchemaMaxExclusiveFacet), 0, soap_copy_ns3__XmlSchemaMaxExclusiveFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMaxExclusiveFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMaxExclusiveFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMaxExclusiveFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMaxExclusiveFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxExclusiveFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMaxExclusiveFacet(struct soap *soap, ns3__XmlSchemaMaxExclusiveFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMaxExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMaxExclusiveFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMaxExclusiveFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMaxExclusiveFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMaxExclusiveFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMaxExclusiveFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMaxExclusiveFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMaxExclusiveFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMaxExclusiveFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMaxExclusiveFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMaxExclusiveFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMaxExclusiveFacet*)p = *(ns3__XmlSchemaMaxExclusiveFacet*)q;
}

void ns3__XmlSchemaMinInclusiveFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMinInclusiveFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMinInclusiveFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMinInclusiveFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMinInclusiveFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMinInclusiveFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMinInclusiveFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinInclusiveFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMinInclusiveFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMinInclusiveFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet, sizeof(ns3__XmlSchemaMinInclusiveFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMinInclusiveFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMinInclusiveFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet, 0, sizeof(ns3__XmlSchemaMinInclusiveFacet), 0, soap_copy_ns3__XmlSchemaMinInclusiveFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMinInclusiveFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMinInclusiveFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMinInclusiveFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMinInclusiveFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinInclusiveFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMinInclusiveFacet(struct soap *soap, ns3__XmlSchemaMinInclusiveFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMinInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMinInclusiveFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMinInclusiveFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMinInclusiveFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMinInclusiveFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMinInclusiveFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMinInclusiveFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMinInclusiveFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMinInclusiveFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMinInclusiveFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMinInclusiveFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMinInclusiveFacet*)p = *(ns3__XmlSchemaMinInclusiveFacet*)q;
}

void ns3__XmlSchemaMaxInclusiveFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMaxInclusiveFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMaxInclusiveFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMaxInclusiveFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMaxInclusiveFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMaxInclusiveFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMaxInclusiveFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxInclusiveFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMaxInclusiveFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMaxInclusiveFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet, sizeof(ns3__XmlSchemaMaxInclusiveFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMaxInclusiveFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMaxInclusiveFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet, 0, sizeof(ns3__XmlSchemaMaxInclusiveFacet), 0, soap_copy_ns3__XmlSchemaMaxInclusiveFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMaxInclusiveFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMaxInclusiveFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMaxInclusiveFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMaxInclusiveFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxInclusiveFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMaxInclusiveFacet(struct soap *soap, ns3__XmlSchemaMaxInclusiveFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMaxInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMaxInclusiveFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMaxInclusiveFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMaxInclusiveFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMaxInclusiveFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMaxInclusiveFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMaxInclusiveFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMaxInclusiveFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMaxInclusiveFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMaxInclusiveFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMaxInclusiveFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMaxInclusiveFacet*)p = *(ns3__XmlSchemaMaxInclusiveFacet*)q;
}

void ns3__XmlSchemaMinLengthFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMinLengthFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMinLengthFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMinLengthFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMinLengthFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMinLengthFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMinLengthFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMinLengthFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinLengthFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMinLengthFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMinLengthFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMinLengthFacet, sizeof(ns3__XmlSchemaMinLengthFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMinLengthFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMinLengthFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMinLengthFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMinLengthFacet, 0, sizeof(ns3__XmlSchemaMinLengthFacet), 0, soap_copy_ns3__XmlSchemaMinLengthFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMinLengthFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMinLengthFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMinLengthFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMinLengthFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMinLengthFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinLengthFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMinLengthFacet(struct soap *soap, ns3__XmlSchemaMinLengthFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMinLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMinLengthFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMinLengthFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMinLengthFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMinLengthFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMinLengthFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMinLengthFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMinLengthFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMinLengthFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMinLengthFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMinLengthFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMinLengthFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMinLengthFacet*)p = *(ns3__XmlSchemaMinLengthFacet*)q;
}

void ns3__XmlSchemaMaxLengthFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMaxLengthFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMaxLengthFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMaxLengthFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMaxLengthFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMaxLengthFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMaxLengthFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxLengthFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMaxLengthFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMaxLengthFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet, sizeof(ns3__XmlSchemaMaxLengthFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMaxLengthFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMaxLengthFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet, 0, sizeof(ns3__XmlSchemaMaxLengthFacet), 0, soap_copy_ns3__XmlSchemaMaxLengthFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMaxLengthFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMaxLengthFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMaxLengthFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMaxLengthFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMaxLengthFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMaxLengthFacet(struct soap *soap, ns3__XmlSchemaMaxLengthFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMaxLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMaxLengthFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMaxLengthFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMaxLengthFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMaxLengthFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMaxLengthFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMaxLengthFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMaxLengthFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMaxLengthFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMaxLengthFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMaxLengthFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMaxLengthFacet*)p = *(ns3__XmlSchemaMaxLengthFacet*)q;
}

void ns3__XmlSchemaLengthFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaLengthFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaLengthFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaLengthFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaLengthFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaLengthFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaLengthFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaLengthFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaLengthFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaLengthFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaLengthFacet(struct soap *soap, const char *tag, ns3__XmlSchemaLengthFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaLengthFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaLengthFacet, sizeof(ns3__XmlSchemaLengthFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaLengthFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaLengthFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaLengthFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaLengthFacet, 0, sizeof(ns3__XmlSchemaLengthFacet), 0, soap_copy_ns3__XmlSchemaLengthFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaLengthFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaLengthFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaLengthFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaLengthFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaLengthFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaLengthFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaLengthFacet(struct soap *soap, ns3__XmlSchemaLengthFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaLengthFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaLengthFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaLengthFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaLengthFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaLengthFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaLengthFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaLengthFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaLengthFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaLengthFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaLengthFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaLengthFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaLengthFacet*)p = *(ns3__XmlSchemaLengthFacet*)q;
}

void ns3__XmlSchemaTotalDigitsFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaTotalDigitsFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaTotalDigitsFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaTotalDigitsFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaTotalDigitsFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaTotalDigitsFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaTotalDigitsFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaTotalDigitsFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, ns3__XmlSchemaTotalDigitsFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaTotalDigitsFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet, sizeof(ns3__XmlSchemaTotalDigitsFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaTotalDigitsFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaTotalDigitsFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet, 0, sizeof(ns3__XmlSchemaTotalDigitsFacet), 0, soap_copy_ns3__XmlSchemaTotalDigitsFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaTotalDigitsFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaTotalDigitsFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaTotalDigitsFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaTotalDigitsFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaTotalDigitsFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaTotalDigitsFacet(struct soap *soap, ns3__XmlSchemaTotalDigitsFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaTotalDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaTotalDigitsFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaTotalDigitsFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaTotalDigitsFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaTotalDigitsFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaTotalDigitsFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaTotalDigitsFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaTotalDigitsFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaTotalDigitsFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaTotalDigitsFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaTotalDigitsFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaTotalDigitsFacet*)p = *(ns3__XmlSchemaTotalDigitsFacet*)q;
}

void ns3__XmlSchemaFractionDigitsFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaFractionDigitsFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaFractionDigitsFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaFractionDigitsFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaFractionDigitsFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaFractionDigitsFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaFractionDigitsFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaFractionDigitsFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, ns3__XmlSchemaFractionDigitsFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaFractionDigitsFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet, sizeof(ns3__XmlSchemaFractionDigitsFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaFractionDigitsFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaFractionDigitsFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet, 0, sizeof(ns3__XmlSchemaFractionDigitsFacet), 0, soap_copy_ns3__XmlSchemaFractionDigitsFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaFractionDigitsFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaFractionDigitsFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaFractionDigitsFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaFractionDigitsFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaFractionDigitsFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaFractionDigitsFacet(struct soap *soap, ns3__XmlSchemaFractionDigitsFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaFractionDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaFractionDigitsFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaFractionDigitsFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaFractionDigitsFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaFractionDigitsFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaFractionDigitsFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaFractionDigitsFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaFractionDigitsFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaFractionDigitsFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaFractionDigitsFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaFractionDigitsFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaFractionDigitsFacet*)p = *(ns3__XmlSchemaFractionDigitsFacet*)q;
}

void ns3__XmlSchemaNumericFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaNumericFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaNumericFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaNumericFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaNumericFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaNumericFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaNumericFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaNumericFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaNumericFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaNumericFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaNumericFacet(struct soap *soap, const char *tag, ns3__XmlSchemaNumericFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaNumericFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaNumericFacet, sizeof(ns3__XmlSchemaNumericFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaNumericFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaNumericFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaNumericFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaNumericFacet, 0, sizeof(ns3__XmlSchemaNumericFacet), 0, soap_copy_ns3__XmlSchemaNumericFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaNumericFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaNumericFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaNumericFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaNumericFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaNumericFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaNumericFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaNumericFacet(struct soap *soap, ns3__XmlSchemaNumericFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaNumericFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaNumericFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaNumericFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaNumericFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaNumericFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaNumericFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaNumericFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaNumericFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaNumericFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaNumericFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaNumericFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaNumericFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaNumericFacet*)p = *(ns3__XmlSchemaNumericFacet*)q;
}

void ns3__XmlSchemaPatternFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaPatternFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaPatternFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaPatternFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaPatternFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaPatternFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaPatternFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaPatternFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaPatternFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaPatternFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaPatternFacet(struct soap *soap, const char *tag, ns3__XmlSchemaPatternFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaPatternFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaPatternFacet, sizeof(ns3__XmlSchemaPatternFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaPatternFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaPatternFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaPatternFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaPatternFacet, 0, sizeof(ns3__XmlSchemaPatternFacet), 0, soap_copy_ns3__XmlSchemaPatternFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaPatternFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaPatternFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaPatternFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaPatternFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaPatternFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaPatternFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaPatternFacet(struct soap *soap, ns3__XmlSchemaPatternFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaPatternFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaPatternFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaPatternFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaPatternFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaPatternFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaPatternFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaPatternFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaPatternFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaPatternFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaPatternFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaPatternFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaPatternFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaPatternFacet*)p = *(ns3__XmlSchemaPatternFacet*)q;
}

void ns3__XmlSchemaEnumerationFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaEnumerationFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaEnumerationFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaEnumerationFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaEnumerationFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaEnumerationFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaEnumerationFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaEnumerationFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaEnumerationFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, ns3__XmlSchemaEnumerationFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaEnumerationFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaEnumerationFacet, sizeof(ns3__XmlSchemaEnumerationFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaEnumerationFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaEnumerationFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaEnumerationFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaEnumerationFacet, 0, sizeof(ns3__XmlSchemaEnumerationFacet), 0, soap_copy_ns3__XmlSchemaEnumerationFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaEnumerationFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaEnumerationFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaEnumerationFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaEnumerationFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaEnumerationFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaEnumerationFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaEnumerationFacet(struct soap *soap, ns3__XmlSchemaEnumerationFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaEnumerationFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaEnumerationFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaEnumerationFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaEnumerationFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaEnumerationFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaEnumerationFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaEnumerationFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaEnumerationFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaEnumerationFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaEnumerationFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaEnumerationFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaEnumerationFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaEnumerationFacet*)p = *(ns3__XmlSchemaEnumerationFacet*)q;
}

void ns3__XmlSchemaWhiteSpaceFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaWhiteSpaceFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaWhiteSpaceFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaWhiteSpaceFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaWhiteSpaceFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaWhiteSpaceFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaWhiteSpaceFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaWhiteSpaceFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, ns3__XmlSchemaWhiteSpaceFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaWhiteSpaceFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet, sizeof(ns3__XmlSchemaWhiteSpaceFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaWhiteSpaceFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaWhiteSpaceFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet, 0, sizeof(ns3__XmlSchemaWhiteSpaceFacet), 0, soap_copy_ns3__XmlSchemaWhiteSpaceFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaWhiteSpaceFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaWhiteSpaceFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaWhiteSpaceFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaWhiteSpaceFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaWhiteSpaceFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaWhiteSpaceFacet(struct soap *soap, ns3__XmlSchemaWhiteSpaceFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaWhiteSpaceFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaWhiteSpaceFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaWhiteSpaceFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaWhiteSpaceFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaWhiteSpaceFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaWhiteSpaceFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaWhiteSpaceFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaWhiteSpaceFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaWhiteSpaceFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaWhiteSpaceFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaWhiteSpaceFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaWhiteSpaceFacet*)p = *(ns3__XmlSchemaWhiteSpaceFacet*)q;
}

void ns3__XmlSchemaFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaFacet::value = NULL;
	this->ns3__XmlSchemaFacet::fixed = (bool)0;
}

void ns3__XmlSchemaFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaFacet *a, const char *type)
{
	if (((ns3__XmlSchemaFacet*)a)->value)
		soap_set_attr(soap, "value", ((ns3__XmlSchemaFacet*)a)->value->c_str(), 1);
	soap_set_attr(soap, "fixed", soap_bool2s(soap, ((ns3__XmlSchemaFacet*)a)->fixed), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaFacet(struct soap *soap, const char *tag, ns3__XmlSchemaFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaFacet, sizeof(ns3__XmlSchemaFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaFacet *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "value", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaFacet*)a)->value = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaFacet*)a)->value->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "fixed", 0), &((ns3__XmlSchemaFacet*)a)->fixed))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaFacet, 0, sizeof(ns3__XmlSchemaFacet), 0, soap_copy_ns3__XmlSchemaFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaFacet(struct soap *soap, ns3__XmlSchemaFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaFacet*)p = *(ns3__XmlSchemaFacet*)q;
}

void ns3__XmlSchemaMinExclusiveFacet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaMinExclusiveFacet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaMinExclusiveFacet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaMinExclusiveFacet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaMinExclusiveFacet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaMinExclusiveFacet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaMinExclusiveFacet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinExclusiveFacet * SOAP_FMAC4 soap_in_ns3__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, ns3__XmlSchemaMinExclusiveFacet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaMinExclusiveFacet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet, sizeof(ns3__XmlSchemaMinExclusiveFacet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaMinExclusiveFacet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaMinExclusiveFacet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet, 0, sizeof(ns3__XmlSchemaMinExclusiveFacet), 0, soap_copy_ns3__XmlSchemaMinExclusiveFacet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaMinExclusiveFacet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaMinExclusiveFacet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaMinExclusiveFacet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaMinExclusiveFacet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaMinExclusiveFacet * SOAP_FMAC4 soap_get_ns3__XmlSchemaMinExclusiveFacet(struct soap *soap, ns3__XmlSchemaMinExclusiveFacet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaMinExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaMinExclusiveFacet * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaMinExclusiveFacet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaMinExclusiveFacet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaMinExclusiveFacet);
		if (size)
			*size = sizeof(ns3__XmlSchemaMinExclusiveFacet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaMinExclusiveFacet, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaMinExclusiveFacet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaMinExclusiveFacet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaMinExclusiveFacet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaMinExclusiveFacet %p -> %p\n", q, p));
	*(ns3__XmlSchemaMinExclusiveFacet*)p = *(ns3__XmlSchemaMinExclusiveFacet*)q;
}

void ns3__XmlSchemaSimpleContentRestriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleContentRestriction::simpleType = NULL;
	this->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction = 0;
	this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction = NULL;
	this->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction_ = 0;
	this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ = NULL;
	this->ns3__XmlSchemaSimpleContentRestriction::anyAttribute = NULL;
	this->ns3__XmlSchemaSimpleContentRestriction::base = NULL;
}

void ns3__XmlSchemaSimpleContentRestriction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaSimpleContentRestriction::simpleType);
	if (this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction; i++)
		{
			this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction[i].soap_serialize(soap);
		}
	}
	if (this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction_; i++)
		{
			this->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaSimpleContentRestriction::anyAttribute);
#endif
}

int ns3__XmlSchemaSimpleContentRestriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleContentRestriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleContentRestriction *a, const char *type)
{
	if (((ns3__XmlSchemaSimpleContentRestriction*)a)->base)
		soap_set_attr(soap, "base", soap_QName2s(soap, ((ns3__XmlSchemaSimpleContentRestriction*)a)->base->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaSimpleContentRestriction::simpleType), ""))
		return soap->error;
	if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction; i++)
			if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction[i].soap_out(soap, "-union-XmlSchemaSimpleContentRestriction", -1, ""))
				return soap->error;
	}
	if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction_; i++)
			if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_[i].soap_out(soap, "-union-XmlSchemaSimpleContentRestriction", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaSimpleContentRestriction::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleContentRestriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleContentRestriction(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContentRestriction * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleContentRestriction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleContentRestriction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction, sizeof(ns3__XmlSchemaSimpleContentRestriction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleContentRestriction *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "base", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaSimpleContentRestriction*)a)->base = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaSimpleContentRestriction*)a)->base->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_simpleType1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaSimpleContentRestriction1 = NULL;
	struct soap_blist *soap_blist___union_XmlSchemaSimpleContentRestriction_1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaSimpleContentRestriction::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaSimpleContentRestriction::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction == NULL)
				{	if (soap_blist___union_XmlSchemaSimpleContentRestriction1 == NULL)
						soap_blist___union_XmlSchemaSimpleContentRestriction1 = soap_new_block(soap);
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction = (__ns3__union_XmlSchemaSimpleContentRestriction *)soap_push_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction1, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction));
					if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction, __ns3__union_XmlSchemaSimpleContentRestriction);
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaSimpleContentRestriction(soap, "-union-XmlSchemaSimpleContentRestriction", a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction, "-ns3:union-XmlSchemaSimpleContentRestriction"))
				{	a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction++;
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ == NULL)
				{	if (soap_blist___union_XmlSchemaSimpleContentRestriction_1 == NULL)
						soap_blist___union_XmlSchemaSimpleContentRestriction_1 = soap_new_block(soap);
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ = (__ns3__union_XmlSchemaSimpleContentRestriction_ *)soap_push_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction_1, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_));
					if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_, __ns3__union_XmlSchemaSimpleContentRestriction_);
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaSimpleContentRestriction_(soap, "-union-XmlSchemaSimpleContentRestriction", a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_, "-ns3:union-XmlSchemaSimpleContentRestriction"))
				{	a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction_++;
					a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction)
			soap_pop_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction1);
		if (a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction)
			a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction = (__ns3__union_XmlSchemaSimpleContentRestriction *)soap_save_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction1, NULL, 1);
		else
		{	a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction = NULL;
			if (soap_blist___union_XmlSchemaSimpleContentRestriction1)
				soap_end_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction1);
		}
		if (a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_)
			soap_pop_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction_1);
		if (a->ns3__XmlSchemaSimpleContentRestriction::__size_XmlSchemaSimpleContentRestriction_)
			a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ = (__ns3__union_XmlSchemaSimpleContentRestriction_ *)soap_save_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction_1, NULL, 1);
		else
		{	a->ns3__XmlSchemaSimpleContentRestriction::__union_XmlSchemaSimpleContentRestriction_ = NULL;
			if (soap_blist___union_XmlSchemaSimpleContentRestriction_1)
				soap_end_block(soap, soap_blist___union_XmlSchemaSimpleContentRestriction_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleContentRestriction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction, 0, sizeof(ns3__XmlSchemaSimpleContentRestriction), 0, soap_copy_ns3__XmlSchemaSimpleContentRestriction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleContentRestriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleContentRestriction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleContentRestriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleContentRestriction(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContentRestriction * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleContentRestriction(struct soap *soap, ns3__XmlSchemaSimpleContentRestriction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleContentRestriction * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleContentRestriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleContentRestriction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleContentRestriction);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleContentRestriction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleContentRestriction, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleContentRestriction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleContentRestriction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleContentRestriction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleContentRestriction %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleContentRestriction*)p = *(ns3__XmlSchemaSimpleContentRestriction*)q;
}

void ns3__XmlSchemaSimpleContentExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleContentExtension::__size_XmlSchemaSimpleContentExtension = 0;
	this->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension = NULL;
	this->ns3__XmlSchemaSimpleContentExtension::anyAttribute = NULL;
	this->ns3__XmlSchemaSimpleContentExtension::base = NULL;
}

void ns3__XmlSchemaSimpleContentExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaSimpleContentExtension::__size_XmlSchemaSimpleContentExtension; i++)
		{
			this->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaSimpleContentExtension::anyAttribute);
#endif
}

int ns3__XmlSchemaSimpleContentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleContentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleContentExtension *a, const char *type)
{
	if (((ns3__XmlSchemaSimpleContentExtension*)a)->base)
		soap_set_attr(soap, "base", soap_QName2s(soap, ((ns3__XmlSchemaSimpleContentExtension*)a)->base->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension), type))
		return soap->error;
	if (a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaSimpleContentExtension::__size_XmlSchemaSimpleContentExtension; i++)
			if (a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension[i].soap_out(soap, "-union-XmlSchemaSimpleContentExtension", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaSimpleContentExtension::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleContentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleContentExtension(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContentExtension * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleContentExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleContentExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension, sizeof(ns3__XmlSchemaSimpleContentExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleContentExtension *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "base", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaSimpleContentExtension*)a)->base = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaSimpleContentExtension*)a)->base->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_XmlSchemaSimpleContentExtension1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaSimpleContentExtension::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension == NULL)
				{	if (soap_blist___union_XmlSchemaSimpleContentExtension1 == NULL)
						soap_blist___union_XmlSchemaSimpleContentExtension1 = soap_new_block(soap);
					a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension = (__ns3__union_XmlSchemaSimpleContentExtension *)soap_push_block(soap, soap_blist___union_XmlSchemaSimpleContentExtension1, sizeof(__ns3__union_XmlSchemaSimpleContentExtension));
					if (a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension, __ns3__union_XmlSchemaSimpleContentExtension);
					a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaSimpleContentExtension(soap, "-union-XmlSchemaSimpleContentExtension", a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension, "-ns3:union-XmlSchemaSimpleContentExtension"))
				{	a->ns3__XmlSchemaSimpleContentExtension::__size_XmlSchemaSimpleContentExtension++;
					a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension)
			soap_pop_block(soap, soap_blist___union_XmlSchemaSimpleContentExtension1);
		if (a->ns3__XmlSchemaSimpleContentExtension::__size_XmlSchemaSimpleContentExtension)
			a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension = (__ns3__union_XmlSchemaSimpleContentExtension *)soap_save_block(soap, soap_blist___union_XmlSchemaSimpleContentExtension1, NULL, 1);
		else
		{	a->ns3__XmlSchemaSimpleContentExtension::__union_XmlSchemaSimpleContentExtension = NULL;
			if (soap_blist___union_XmlSchemaSimpleContentExtension1)
				soap_end_block(soap, soap_blist___union_XmlSchemaSimpleContentExtension1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleContentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension, 0, sizeof(ns3__XmlSchemaSimpleContentExtension), 0, soap_copy_ns3__XmlSchemaSimpleContentExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleContentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleContentExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleContentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleContentExtension(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContentExtension * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleContentExtension(struct soap *soap, ns3__XmlSchemaSimpleContentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleContentExtension * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleContentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleContentExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleContentExtension);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleContentExtension);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleContentExtension, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleContentExtension);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleContentExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleContentExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleContentExtension %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleContentExtension*)p = *(ns3__XmlSchemaSimpleContentExtension*)q;
}

void ns3__XmlSchemaAnyAttribute::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAnyAttribute::namespace_ = NULL;
	this->ns3__XmlSchemaAnyAttribute::processContents = NULL;
}

void ns3__XmlSchemaAnyAttribute::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaAnyAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAnyAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAnyAttribute *a, const char *type)
{
	if (((ns3__XmlSchemaAnyAttribute*)a)->namespace_)
		soap_set_attr(soap, "namespace", ((ns3__XmlSchemaAnyAttribute*)a)->namespace_->c_str(), 1);
	if (((ns3__XmlSchemaAnyAttribute*)a)->processContents)
		soap_set_attr(soap, "processContents", ((ns3__XmlSchemaAnyAttribute*)a)->processContents->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAnyAttribute), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAnyAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAnyAttribute(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnyAttribute * SOAP_FMAC4 soap_in_ns3__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, ns3__XmlSchemaAnyAttribute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAnyAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAnyAttribute, sizeof(ns3__XmlSchemaAnyAttribute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAnyAttribute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAnyAttribute *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "namespace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAnyAttribute*)a)->namespace_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAnyAttribute*)a)->namespace_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "processContents", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAnyAttribute*)a)->processContents = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAnyAttribute*)a)->processContents->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAnyAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAnyAttribute, 0, sizeof(ns3__XmlSchemaAnyAttribute), 0, soap_copy_ns3__XmlSchemaAnyAttribute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAnyAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAnyAttribute);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAnyAttribute", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAnyAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAnyAttribute(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnyAttribute * SOAP_FMAC4 soap_get_ns3__XmlSchemaAnyAttribute(struct soap *soap, ns3__XmlSchemaAnyAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAnyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAnyAttribute * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAnyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAnyAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAnyAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAnyAttribute);
		if (size)
			*size = sizeof(ns3__XmlSchemaAnyAttribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAnyAttribute, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAnyAttribute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAnyAttribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAnyAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAnyAttribute %p -> %p\n", q, p));
	*(ns3__XmlSchemaAnyAttribute*)p = *(ns3__XmlSchemaAnyAttribute*)q;
}

void ns3__XmlSchemaAll::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__XmlSchemaElement(soap, &this->ns3__XmlSchemaAll::element);
}

void ns3__XmlSchemaAll::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__XmlSchemaElement(soap, &this->ns3__XmlSchemaAll::element);
#endif
}

int ns3__XmlSchemaAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAll(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAll), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__XmlSchemaElement(soap, "ns3:element", -1, &(a->ns3__XmlSchemaAll::element), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAll(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAll * SOAP_FMAC4 soap_in_ns3__XmlSchemaAll(struct soap *soap, const char *tag, ns3__XmlSchemaAll *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAll, sizeof(ns3__XmlSchemaAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAll *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__XmlSchemaElement(soap, "ns3:element", &(a->ns3__XmlSchemaAll::element), "xsd:XmlSchemaElement"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAll, 0, sizeof(ns3__XmlSchemaAll), 0, soap_copy_ns3__XmlSchemaAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAll);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAll", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAll(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAll * SOAP_FMAC4 soap_get_ns3__XmlSchemaAll(struct soap *soap, ns3__XmlSchemaAll *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAll * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAll);
		if (size)
			*size = sizeof(ns3__XmlSchemaAll);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAll, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAll);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAll*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAll %p -> %p\n", q, p));
	*(ns3__XmlSchemaAll*)p = *(ns3__XmlSchemaAll*)q;
}

void ns3__XmlSchemaSequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSequence::__size_XmlSchemaSequence = 0;
	this->ns3__XmlSchemaSequence::__union_XmlSchemaSequence = NULL;
}

void ns3__XmlSchemaSequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaSequence::__union_XmlSchemaSequence)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaSequence::__size_XmlSchemaSequence; i++)
		{
			this->ns3__XmlSchemaSequence::__union_XmlSchemaSequence[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaSequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSequence(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSequence *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSequence), type))
		return soap->error;
	if (a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaSequence::__size_XmlSchemaSequence; i++)
			if (a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence[i].soap_out(soap, "-union-XmlSchemaSequence", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSequence(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSequence * SOAP_FMAC4 soap_in_ns3__XmlSchemaSequence(struct soap *soap, const char *tag, ns3__XmlSchemaSequence *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSequence *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSequence, sizeof(ns3__XmlSchemaSequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSequence)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSequence *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_XmlSchemaSequence1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence == NULL)
				{	if (soap_blist___union_XmlSchemaSequence1 == NULL)
						soap_blist___union_XmlSchemaSequence1 = soap_new_block(soap);
					a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence = (__ns3__union_XmlSchemaSequence *)soap_push_block(soap, soap_blist___union_XmlSchemaSequence1, sizeof(__ns3__union_XmlSchemaSequence));
					if (a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence, __ns3__union_XmlSchemaSequence);
					a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaSequence(soap, "-union-XmlSchemaSequence", a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence, "-ns3:union-XmlSchemaSequence"))
				{	a->ns3__XmlSchemaSequence::__size_XmlSchemaSequence++;
					a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence)
			soap_pop_block(soap, soap_blist___union_XmlSchemaSequence1);
		if (a->ns3__XmlSchemaSequence::__size_XmlSchemaSequence)
			a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence = (__ns3__union_XmlSchemaSequence *)soap_save_block(soap, soap_blist___union_XmlSchemaSequence1, NULL, 1);
		else
		{	a->ns3__XmlSchemaSequence::__union_XmlSchemaSequence = NULL;
			if (soap_blist___union_XmlSchemaSequence1)
				soap_end_block(soap, soap_blist___union_XmlSchemaSequence1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSequence, 0, sizeof(ns3__XmlSchemaSequence), 0, soap_copy_ns3__XmlSchemaSequence);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSequence);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSequence", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSequence(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSequence * SOAP_FMAC4 soap_get_ns3__XmlSchemaSequence(struct soap *soap, ns3__XmlSchemaSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSequence * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSequence);
		if (size)
			*size = sizeof(ns3__XmlSchemaSequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSequence, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSequence %p -> %p\n", q, p));
	*(ns3__XmlSchemaSequence*)p = *(ns3__XmlSchemaSequence*)q;
}

void ns3__XmlSchemaChoice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaChoice::__size_XmlSchemaChoice = 0;
	this->ns3__XmlSchemaChoice::__union_XmlSchemaChoice = NULL;
}

void ns3__XmlSchemaChoice::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaChoice::__union_XmlSchemaChoice)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaChoice::__size_XmlSchemaChoice; i++)
		{
			this->ns3__XmlSchemaChoice::__union_XmlSchemaChoice[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaChoice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaChoice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaChoice(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaChoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaChoice), type))
		return soap->error;
	if (a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaChoice::__size_XmlSchemaChoice; i++)
			if (a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice[i].soap_out(soap, "-union-XmlSchemaChoice", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaChoice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaChoice(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaChoice * SOAP_FMAC4 soap_in_ns3__XmlSchemaChoice(struct soap *soap, const char *tag, ns3__XmlSchemaChoice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaChoice *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaChoice, sizeof(ns3__XmlSchemaChoice), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaChoice)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaChoice *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_XmlSchemaChoice1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice == NULL)
				{	if (soap_blist___union_XmlSchemaChoice1 == NULL)
						soap_blist___union_XmlSchemaChoice1 = soap_new_block(soap);
					a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice = (__ns3__union_XmlSchemaChoice *)soap_push_block(soap, soap_blist___union_XmlSchemaChoice1, sizeof(__ns3__union_XmlSchemaChoice));
					if (a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice, __ns3__union_XmlSchemaChoice);
					a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaChoice(soap, "-union-XmlSchemaChoice", a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice, "-ns3:union-XmlSchemaChoice"))
				{	a->ns3__XmlSchemaChoice::__size_XmlSchemaChoice++;
					a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice)
			soap_pop_block(soap, soap_blist___union_XmlSchemaChoice1);
		if (a->ns3__XmlSchemaChoice::__size_XmlSchemaChoice)
			a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice = (__ns3__union_XmlSchemaChoice *)soap_save_block(soap, soap_blist___union_XmlSchemaChoice1, NULL, 1);
		else
		{	a->ns3__XmlSchemaChoice::__union_XmlSchemaChoice = NULL;
			if (soap_blist___union_XmlSchemaChoice1)
				soap_end_block(soap, soap_blist___union_XmlSchemaChoice1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaChoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaChoice, 0, sizeof(ns3__XmlSchemaChoice), 0, soap_copy_ns3__XmlSchemaChoice);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaChoice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaChoice);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaChoice", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaChoice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaChoice(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaChoice * SOAP_FMAC4 soap_get_ns3__XmlSchemaChoice(struct soap *soap, ns3__XmlSchemaChoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaChoice * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaChoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaChoice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaChoice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaChoice);
		if (size)
			*size = sizeof(ns3__XmlSchemaChoice);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaChoice, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaChoice);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaChoice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaChoice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaChoice %p -> %p\n", q, p));
	*(ns3__XmlSchemaChoice*)p = *(ns3__XmlSchemaChoice*)q;
}

void ns3__XmlSchemaGroupBase::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaGroupBase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaGroupBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaGroupBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaGroupBase(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaGroupBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaGroupBase), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaGroupBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaGroupBase(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroupBase * SOAP_FMAC4 soap_in_ns3__XmlSchemaGroupBase(struct soap *soap, const char *tag, ns3__XmlSchemaGroupBase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaGroupBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaGroupBase, sizeof(ns3__XmlSchemaGroupBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaGroupBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaGroupBase *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaGroupBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaGroupBase, 0, sizeof(ns3__XmlSchemaGroupBase), 0, soap_copy_ns3__XmlSchemaGroupBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaGroupBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaGroupBase);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaGroupBase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaGroupBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaGroupBase(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroupBase * SOAP_FMAC4 soap_get_ns3__XmlSchemaGroupBase(struct soap *soap, ns3__XmlSchemaGroupBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaGroupBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaGroupBase * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaGroupBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaGroupBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaGroupBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaGroupBase);
		if (size)
			*size = sizeof(ns3__XmlSchemaGroupBase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaGroupBase, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaGroupBase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaGroupBase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaGroupBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaGroupBase %p -> %p\n", q, p));
	*(ns3__XmlSchemaGroupBase*)p = *(ns3__XmlSchemaGroupBase*)q;
}

void ns3__XmlSchemaAny::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAny::namespace_ = NULL;
	this->ns3__XmlSchemaAny::processContents = NULL;
}

void ns3__XmlSchemaAny::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaAny::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAny(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAny(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAny *a, const char *type)
{
	if (((ns3__XmlSchemaAny*)a)->namespace_)
		soap_set_attr(soap, "namespace", ((ns3__XmlSchemaAny*)a)->namespace_->c_str(), 1);
	if (((ns3__XmlSchemaAny*)a)->processContents)
		soap_set_attr(soap, "processContents", ((ns3__XmlSchemaAny*)a)->processContents->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAny), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAny::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAny(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAny * SOAP_FMAC4 soap_in_ns3__XmlSchemaAny(struct soap *soap, const char *tag, ns3__XmlSchemaAny *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAny *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAny, sizeof(ns3__XmlSchemaAny), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAny)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAny *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "namespace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAny*)a)->namespace_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAny*)a)->namespace_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "processContents", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAny*)a)->processContents = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAny*)a)->processContents->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAny *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAny, 0, sizeof(ns3__XmlSchemaAny), 0, soap_copy_ns3__XmlSchemaAny);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAny::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAny);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAny", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAny::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAny(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAny * SOAP_FMAC4 soap_get_ns3__XmlSchemaAny(struct soap *soap, ns3__XmlSchemaAny *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAny * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAny(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAny(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAny, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAny);
		if (size)
			*size = sizeof(ns3__XmlSchemaAny);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAny, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAny);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAny*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAny(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAny %p -> %p\n", q, p));
	*(ns3__XmlSchemaAny*)p = *(ns3__XmlSchemaAny*)q;
}

void ns3__XmlSchemaKey::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaKey::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaKey(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaKey *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaKey), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaKey(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaKey * SOAP_FMAC4 soap_in_ns3__XmlSchemaKey(struct soap *soap, const char *tag, ns3__XmlSchemaKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaKey *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaKey, sizeof(ns3__XmlSchemaKey), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaKey)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaKey *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaKey, 0, sizeof(ns3__XmlSchemaKey), 0, soap_copy_ns3__XmlSchemaKey);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaKey);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaKey", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaKey(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaKey * SOAP_FMAC4 soap_get_ns3__XmlSchemaKey(struct soap *soap, ns3__XmlSchemaKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaKey * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaKey);
		if (size)
			*size = sizeof(ns3__XmlSchemaKey);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaKey, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaKey);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaKey*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaKey %p -> %p\n", q, p));
	*(ns3__XmlSchemaKey*)p = *(ns3__XmlSchemaKey*)q;
}

void ns3__XmlSchemaKeyref::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaKeyref::refer = NULL;
}

void ns3__XmlSchemaKeyref::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaKeyref::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaKeyref(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaKeyref(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaKeyref *a, const char *type)
{
	if (((ns3__XmlSchemaKeyref*)a)->refer)
		soap_set_attr(soap, "refer", soap_QName2s(soap, ((ns3__XmlSchemaKeyref*)a)->refer->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaKeyref), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaKeyref::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaKeyref(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaKeyref * SOAP_FMAC4 soap_in_ns3__XmlSchemaKeyref(struct soap *soap, const char *tag, ns3__XmlSchemaKeyref *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaKeyref *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaKeyref, sizeof(ns3__XmlSchemaKeyref), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaKeyref)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaKeyref *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "refer", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaKeyref*)a)->refer = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaKeyref*)a)->refer->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaKeyref *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaKeyref, 0, sizeof(ns3__XmlSchemaKeyref), 0, soap_copy_ns3__XmlSchemaKeyref);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaKeyref::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaKeyref);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaKeyref", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaKeyref::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaKeyref(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaKeyref * SOAP_FMAC4 soap_get_ns3__XmlSchemaKeyref(struct soap *soap, ns3__XmlSchemaKeyref *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaKeyref(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaKeyref * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaKeyref(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaKeyref(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaKeyref, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaKeyref);
		if (size)
			*size = sizeof(ns3__XmlSchemaKeyref);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaKeyref, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaKeyref);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaKeyref*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaKeyref(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaKeyref %p -> %p\n", q, p));
	*(ns3__XmlSchemaKeyref*)p = *(ns3__XmlSchemaKeyref*)q;
}

void ns3__XmlSchemaXPath::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaXPath::xpath = "";
}

void ns3__XmlSchemaXPath::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaXPath::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaXPath(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaXPath(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaXPath *a, const char *type)
{
	if (!((ns3__XmlSchemaXPath*)a)->xpath.empty())
	soap_set_attr(soap, "xpath", ((ns3__XmlSchemaXPath*)a)->xpath.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaXPath), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaXPath::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaXPath(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaXPath * SOAP_FMAC4 soap_in_ns3__XmlSchemaXPath(struct soap *soap, const char *tag, ns3__XmlSchemaXPath *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaXPath *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaXPath, sizeof(ns3__XmlSchemaXPath), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaXPath)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaXPath *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xpath", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns3__XmlSchemaXPath*)a)->xpath.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaXPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaXPath, 0, sizeof(ns3__XmlSchemaXPath), 0, soap_copy_ns3__XmlSchemaXPath);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaXPath::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaXPath);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaXPath", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaXPath::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaXPath(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaXPath * SOAP_FMAC4 soap_get_ns3__XmlSchemaXPath(struct soap *soap, ns3__XmlSchemaXPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaXPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaXPath * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaXPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaXPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaXPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaXPath);
		if (size)
			*size = sizeof(ns3__XmlSchemaXPath);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaXPath, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaXPath);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaXPath*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaXPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaXPath %p -> %p\n", q, p));
	*(ns3__XmlSchemaXPath*)p = *(ns3__XmlSchemaXPath*)q;
}

void ns3__XmlSchemaIdentityConstraint::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaIdentityConstraint::selector = NULL;
	soap_default_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, &this->ns3__XmlSchemaIdentityConstraint::field);
	this->ns3__XmlSchemaIdentityConstraint::name = NULL;
}

void ns3__XmlSchemaIdentityConstraint::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaXPath(soap, &this->ns3__XmlSchemaIdentityConstraint::selector);
	soap_serialize_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, &this->ns3__XmlSchemaIdentityConstraint::field);
#endif
}

int ns3__XmlSchemaIdentityConstraint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaIdentityConstraint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaIdentityConstraint(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaIdentityConstraint *a, const char *type)
{
	if (((ns3__XmlSchemaIdentityConstraint*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaIdentityConstraint*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaIdentityConstraint), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaXPath(soap, "ns3:selector", -1, &(a->ns3__XmlSchemaIdentityConstraint::selector), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, "ns3:field", -1, &(a->ns3__XmlSchemaIdentityConstraint::field), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaIdentityConstraint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaIdentityConstraint(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaIdentityConstraint * SOAP_FMAC4 soap_in_ns3__XmlSchemaIdentityConstraint(struct soap *soap, const char *tag, ns3__XmlSchemaIdentityConstraint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaIdentityConstraint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaIdentityConstraint, sizeof(ns3__XmlSchemaIdentityConstraint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaIdentityConstraint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaIdentityConstraint *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaIdentityConstraint*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaIdentityConstraint*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_selector1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_selector1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaXPath(soap, "ns3:selector", &(a->ns3__XmlSchemaIdentityConstraint::selector), "xsd:XmlSchemaXPath"))
				{	soap_flag_selector1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, "ns3:field", &(a->ns3__XmlSchemaIdentityConstraint::field), "xsd:XmlSchemaXPath"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaIdentityConstraint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaIdentityConstraint, 0, sizeof(ns3__XmlSchemaIdentityConstraint), 0, soap_copy_ns3__XmlSchemaIdentityConstraint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaIdentityConstraint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaIdentityConstraint);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaIdentityConstraint", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaIdentityConstraint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaIdentityConstraint(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaIdentityConstraint * SOAP_FMAC4 soap_get_ns3__XmlSchemaIdentityConstraint(struct soap *soap, ns3__XmlSchemaIdentityConstraint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaIdentityConstraint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaIdentityConstraint * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaIdentityConstraint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaIdentityConstraint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaIdentityConstraint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaIdentityConstraint);
		if (size)
			*size = sizeof(ns3__XmlSchemaIdentityConstraint);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaIdentityConstraint, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaIdentityConstraint);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaIdentityConstraint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaIdentityConstraint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaIdentityConstraint %p -> %p\n", q, p));
	*(ns3__XmlSchemaIdentityConstraint*)p = *(ns3__XmlSchemaIdentityConstraint*)q;
}

void ns3__XmlSchemaUnique::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaUnique::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaUnique::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaUnique(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaUnique(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaUnique *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaUnique), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaUnique::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaUnique(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaUnique * SOAP_FMAC4 soap_in_ns3__XmlSchemaUnique(struct soap *soap, const char *tag, ns3__XmlSchemaUnique *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaUnique *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaUnique, sizeof(ns3__XmlSchemaUnique), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaUnique)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaUnique *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaUnique *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaUnique, 0, sizeof(ns3__XmlSchemaUnique), 0, soap_copy_ns3__XmlSchemaUnique);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaUnique::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaUnique);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaUnique", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaUnique::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaUnique(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaUnique * SOAP_FMAC4 soap_get_ns3__XmlSchemaUnique(struct soap *soap, ns3__XmlSchemaUnique *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaUnique * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaUnique(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaUnique(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaUnique, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaUnique);
		if (size)
			*size = sizeof(ns3__XmlSchemaUnique);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaUnique, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaUnique);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaUnique*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaUnique(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaUnique %p -> %p\n", q, p));
	*(ns3__XmlSchemaUnique*)p = *(ns3__XmlSchemaUnique*)q;
}

void ns3__XmlSchemaElement::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaElement::simpleType = NULL;
	this->ns3__XmlSchemaElement::complexType = NULL;
	this->ns3__XmlSchemaElement::__size_XmlSchemaElement_ = 0;
	this->ns3__XmlSchemaElement::__union_XmlSchemaElement_ = NULL;
	this->ns3__XmlSchemaElement::abstract = (bool)0;
	this->ns3__XmlSchemaElement::block = NULL;
	this->ns3__XmlSchemaElement::default_ = NULL;
	this->ns3__XmlSchemaElement::final = NULL;
	this->ns3__XmlSchemaElement::fixed = NULL;
	this->ns3__XmlSchemaElement::form = NULL;
	this->ns3__XmlSchemaElement::name = "";
	this->ns3__XmlSchemaElement::nillable = (bool)0;
	this->ns3__XmlSchemaElement::ref = NULL;
	this->ns3__XmlSchemaElement::substitutionGroup = NULL;
	this->ns3__XmlSchemaElement::type = NULL;
}

void ns3__XmlSchemaElement::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaElement::simpleType);
	soap_serialize_PointerToxsd__XmlSchemaComplexType(soap, &this->ns3__XmlSchemaElement::complexType);
	if (this->ns3__XmlSchemaElement::__union_XmlSchemaElement_)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaElement::__size_XmlSchemaElement_; i++)
		{
			this->ns3__XmlSchemaElement::__union_XmlSchemaElement_[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaElement(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaElement *a, const char *type)
{
	soap_set_attr(soap, "abstract", soap_bool2s(soap, ((ns3__XmlSchemaElement*)a)->abstract), 1);
	if (((ns3__XmlSchemaElement*)a)->block)
		soap_set_attr(soap, "block", ((ns3__XmlSchemaElement*)a)->block->c_str(), 1);
	if (((ns3__XmlSchemaElement*)a)->default_)
		soap_set_attr(soap, "default", ((ns3__XmlSchemaElement*)a)->default_->c_str(), 1);
	if (((ns3__XmlSchemaElement*)a)->final)
		soap_set_attr(soap, "final", ((ns3__XmlSchemaElement*)a)->final->c_str(), 1);
	if (((ns3__XmlSchemaElement*)a)->fixed)
		soap_set_attr(soap, "fixed", ((ns3__XmlSchemaElement*)a)->fixed->c_str(), 1);
	if (((ns3__XmlSchemaElement*)a)->form)
		soap_set_attr(soap, "form", ((ns3__XmlSchemaElement*)a)->form->c_str(), 1);
	if (!((ns3__XmlSchemaElement*)a)->name.empty())
	soap_set_attr(soap, "name", ((ns3__XmlSchemaElement*)a)->name.c_str(), 1);
	soap_set_attr(soap, "nillable", soap_bool2s(soap, ((ns3__XmlSchemaElement*)a)->nillable), 1);
	if (((ns3__XmlSchemaElement*)a)->ref)
		soap_set_attr(soap, "ref", soap_QName2s(soap, ((ns3__XmlSchemaElement*)a)->ref->c_str()), 1);
	if (((ns3__XmlSchemaElement*)a)->substitutionGroup)
		soap_set_attr(soap, "substitutionGroup", soap_QName2s(soap, ((ns3__XmlSchemaElement*)a)->substitutionGroup->c_str()), 1);
	if (((ns3__XmlSchemaElement*)a)->type)
		soap_set_attr(soap, "type", soap_QName2s(soap, ((ns3__XmlSchemaElement*)a)->type->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaElement), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaElement::simpleType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", -1, &(a->ns3__XmlSchemaElement::complexType), ""))
		return soap->error;
	if (a->ns3__XmlSchemaElement::__union_XmlSchemaElement_)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaElement::__size_XmlSchemaElement_; i++)
			if (a->ns3__XmlSchemaElement::__union_XmlSchemaElement_[i].soap_out(soap, "-union-XmlSchemaElement", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaElement(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaElement * SOAP_FMAC4 soap_in_ns3__XmlSchemaElement(struct soap *soap, const char *tag, ns3__XmlSchemaElement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaElement, sizeof(ns3__XmlSchemaElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaElement *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "abstract", 0), &((ns3__XmlSchemaElement*)a)->abstract))
		return NULL;
	{	const char *t = soap_attr_value(soap, "block", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->block = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->block->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "default", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->default_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->default_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "final", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->final = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->final->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->fixed = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->fixed->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "form", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->form = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->form->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns3__XmlSchemaElement*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "nillable", 0), &((ns3__XmlSchemaElement*)a)->nillable))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ref", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->ref = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->ref->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "substitutionGroup", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->substitutionGroup = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->substitutionGroup->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "type", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaElement*)a)->type = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaElement*)a)->type->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_simpleType1 = 1;
	size_t soap_flag_complexType1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaElement_1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaElement::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap_flag_complexType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexType(soap, "ns3:complexType", &(a->ns3__XmlSchemaElement::complexType), "xsd:XmlSchemaComplexType"))
				{	soap_flag_complexType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ == NULL)
				{	if (soap_blist___union_XmlSchemaElement_1 == NULL)
						soap_blist___union_XmlSchemaElement_1 = soap_new_block(soap);
					a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ = (__ns3__union_XmlSchemaElement_ *)soap_push_block(soap, soap_blist___union_XmlSchemaElement_1, sizeof(__ns3__union_XmlSchemaElement_));
					if (a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaElement::__union_XmlSchemaElement_, __ns3__union_XmlSchemaElement_);
					a->ns3__XmlSchemaElement::__union_XmlSchemaElement_->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaElement_(soap, "-union-XmlSchemaElement", a->ns3__XmlSchemaElement::__union_XmlSchemaElement_, "-ns3:union-XmlSchemaElement"))
				{	a->ns3__XmlSchemaElement::__size_XmlSchemaElement_++;
					a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaElement::__union_XmlSchemaElement_)
			soap_pop_block(soap, soap_blist___union_XmlSchemaElement_1);
		if (a->ns3__XmlSchemaElement::__size_XmlSchemaElement_)
			a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ = (__ns3__union_XmlSchemaElement_ *)soap_save_block(soap, soap_blist___union_XmlSchemaElement_1, NULL, 1);
		else
		{	a->ns3__XmlSchemaElement::__union_XmlSchemaElement_ = NULL;
			if (soap_blist___union_XmlSchemaElement_1)
				soap_end_block(soap, soap_blist___union_XmlSchemaElement_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaElement, 0, sizeof(ns3__XmlSchemaElement), 0, soap_copy_ns3__XmlSchemaElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaElement);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaElement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaElement(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaElement * SOAP_FMAC4 soap_get_ns3__XmlSchemaElement(struct soap *soap, ns3__XmlSchemaElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaElement * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaElement);
		if (size)
			*size = sizeof(ns3__XmlSchemaElement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaElement, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaElement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaElement %p -> %p\n", q, p));
	*(ns3__XmlSchemaElement*)p = *(ns3__XmlSchemaElement*)q;
}

void ns3__XmlSchemaParticle::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaParticle::minOccurs = NULL;
	this->ns3__XmlSchemaParticle::maxOccurs = NULL;
}

void ns3__XmlSchemaParticle::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaParticle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaParticle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaParticle(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaParticle *a, const char *type)
{
	if (((ns3__XmlSchemaParticle*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", ((ns3__XmlSchemaParticle*)a)->minOccurs->c_str(), 1);
	if (((ns3__XmlSchemaParticle*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", ((ns3__XmlSchemaParticle*)a)->maxOccurs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaParticle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaParticle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaParticle(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaParticle * SOAP_FMAC4 soap_in_ns3__XmlSchemaParticle(struct soap *soap, const char *tag, ns3__XmlSchemaParticle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaParticle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaParticle, sizeof(ns3__XmlSchemaParticle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaParticle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaParticle *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "minOccurs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaParticle*)a)->minOccurs = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaParticle*)a)->minOccurs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "maxOccurs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaParticle*)a)->maxOccurs = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaParticle*)a)->maxOccurs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaParticle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaParticle, 0, sizeof(ns3__XmlSchemaParticle), 0, soap_copy_ns3__XmlSchemaParticle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaParticle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaParticle);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaParticle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaParticle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaParticle(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaParticle * SOAP_FMAC4 soap_get_ns3__XmlSchemaParticle(struct soap *soap, ns3__XmlSchemaParticle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaParticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaParticle * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaParticle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaParticle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaParticle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaParticle);
		if (size)
			*size = sizeof(ns3__XmlSchemaParticle);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaParticle, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaParticle);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaParticle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaParticle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaParticle %p -> %p\n", q, p));
	*(ns3__XmlSchemaParticle*)p = *(ns3__XmlSchemaParticle*)q;
}

void ns3__XmlSchemaGroupRef::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaGroupRef::ref = NULL;
}

void ns3__XmlSchemaGroupRef::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaGroupRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaGroupRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaGroupRef(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaGroupRef *a, const char *type)
{
	if (((ns3__XmlSchemaGroupRef*)a)->ref)
		soap_set_attr(soap, "ref", soap_QName2s(soap, ((ns3__XmlSchemaGroupRef*)a)->ref->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaGroupRef), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaGroupRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaGroupRef(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroupRef * SOAP_FMAC4 soap_in_ns3__XmlSchemaGroupRef(struct soap *soap, const char *tag, ns3__XmlSchemaGroupRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaGroupRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaGroupRef, sizeof(ns3__XmlSchemaGroupRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaGroupRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaGroupRef *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ref", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaGroupRef*)a)->ref = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaGroupRef*)a)->ref->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaGroupRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaGroupRef, 0, sizeof(ns3__XmlSchemaGroupRef), 0, soap_copy_ns3__XmlSchemaGroupRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaGroupRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaGroupRef);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaGroupRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaGroupRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaGroupRef(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaGroupRef * SOAP_FMAC4 soap_get_ns3__XmlSchemaGroupRef(struct soap *soap, ns3__XmlSchemaGroupRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaGroupRef * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaGroupRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaGroupRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaGroupRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaGroupRef);
		if (size)
			*size = sizeof(ns3__XmlSchemaGroupRef);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaGroupRef, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaGroupRef);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaGroupRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaGroupRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaGroupRef %p -> %p\n", q, p));
	*(ns3__XmlSchemaGroupRef*)p = *(ns3__XmlSchemaGroupRef*)q;
}

void ns3__XmlSchemaComplexContentExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaComplexContentExtension::group = NULL;
	this->ns3__XmlSchemaComplexContentExtension::all = NULL;
	this->ns3__XmlSchemaComplexContentExtension::sequence = NULL;
	this->ns3__XmlSchemaComplexContentExtension::choice = NULL;
	this->ns3__XmlSchemaComplexContentExtension::__size_XmlSchemaComplexContentExtension_ = 0;
	this->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ = NULL;
	this->ns3__XmlSchemaComplexContentExtension::anyAttribute = NULL;
	this->ns3__XmlSchemaComplexContentExtension::base = NULL;
}

void ns3__XmlSchemaComplexContentExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, &this->ns3__XmlSchemaComplexContentExtension::group);
	soap_serialize_PointerToxsd__XmlSchemaAll(soap, &this->ns3__XmlSchemaComplexContentExtension::all);
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->ns3__XmlSchemaComplexContentExtension::sequence);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->ns3__XmlSchemaComplexContentExtension::choice);
	if (this->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaComplexContentExtension::__size_XmlSchemaComplexContentExtension_; i++)
		{
			this->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaComplexContentExtension::anyAttribute);
#endif
}

int ns3__XmlSchemaComplexContentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaComplexContentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaComplexContentExtension *a, const char *type)
{
	if (((ns3__XmlSchemaComplexContentExtension*)a)->base)
		soap_set_attr(soap, "base", soap_QName2s(soap, ((ns3__XmlSchemaComplexContentExtension*)a)->base->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaComplexContentExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", -1, &(a->ns3__XmlSchemaComplexContentExtension::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAll(soap, "ns3:all", -1, &(a->ns3__XmlSchemaComplexContentExtension::all), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->ns3__XmlSchemaComplexContentExtension::sequence), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->ns3__XmlSchemaComplexContentExtension::choice), ""))
		return soap->error;
	if (a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaComplexContentExtension::__size_XmlSchemaComplexContentExtension_; i++)
			if (a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_[i].soap_out(soap, "-union-XmlSchemaComplexContentExtension", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaComplexContentExtension::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaComplexContentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaComplexContentExtension(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContentExtension * SOAP_FMAC4 soap_in_ns3__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, ns3__XmlSchemaComplexContentExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaComplexContentExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaComplexContentExtension, sizeof(ns3__XmlSchemaComplexContentExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaComplexContentExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaComplexContentExtension *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "base", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaComplexContentExtension*)a)->base = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaComplexContentExtension*)a)->base->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_group1 = 1;
	size_t soap_flag_all1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_choice1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaComplexContentExtension_1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", &(a->ns3__XmlSchemaComplexContentExtension::group), "xsd:XmlSchemaGroupRef"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_all1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAll(soap, "ns3:all", &(a->ns3__XmlSchemaComplexContentExtension::all), "xsd:XmlSchemaAll"))
				{	soap_flag_all1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->ns3__XmlSchemaComplexContentExtension::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->ns3__XmlSchemaComplexContentExtension::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaComplexContentExtension::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ == NULL)
				{	if (soap_blist___union_XmlSchemaComplexContentExtension_1 == NULL)
						soap_blist___union_XmlSchemaComplexContentExtension_1 = soap_new_block(soap);
					a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ = (__ns3__union_XmlSchemaComplexContentExtension_ *)soap_push_block(soap, soap_blist___union_XmlSchemaComplexContentExtension_1, sizeof(__ns3__union_XmlSchemaComplexContentExtension_));
					if (a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_, __ns3__union_XmlSchemaComplexContentExtension_);
					a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaComplexContentExtension_(soap, "-union-XmlSchemaComplexContentExtension", a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_, "-ns3:union-XmlSchemaComplexContentExtension"))
				{	a->ns3__XmlSchemaComplexContentExtension::__size_XmlSchemaComplexContentExtension_++;
					a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_)
			soap_pop_block(soap, soap_blist___union_XmlSchemaComplexContentExtension_1);
		if (a->ns3__XmlSchemaComplexContentExtension::__size_XmlSchemaComplexContentExtension_)
			a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ = (__ns3__union_XmlSchemaComplexContentExtension_ *)soap_save_block(soap, soap_blist___union_XmlSchemaComplexContentExtension_1, NULL, 1);
		else
		{	a->ns3__XmlSchemaComplexContentExtension::__union_XmlSchemaComplexContentExtension_ = NULL;
			if (soap_blist___union_XmlSchemaComplexContentExtension_1)
				soap_end_block(soap, soap_blist___union_XmlSchemaComplexContentExtension_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaComplexContentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaComplexContentExtension, 0, sizeof(ns3__XmlSchemaComplexContentExtension), 0, soap_copy_ns3__XmlSchemaComplexContentExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaComplexContentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaComplexContentExtension);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaComplexContentExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaComplexContentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaComplexContentExtension(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContentExtension * SOAP_FMAC4 soap_get_ns3__XmlSchemaComplexContentExtension(struct soap *soap, ns3__XmlSchemaComplexContentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaComplexContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaComplexContentExtension * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaComplexContentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaComplexContentExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaComplexContentExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaComplexContentExtension);
		if (size)
			*size = sizeof(ns3__XmlSchemaComplexContentExtension);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaComplexContentExtension, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaComplexContentExtension);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaComplexContentExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaComplexContentExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaComplexContentExtension %p -> %p\n", q, p));
	*(ns3__XmlSchemaComplexContentExtension*)p = *(ns3__XmlSchemaComplexContentExtension*)q;
}

void ns3__XmlSchemaContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaContent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaContent(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaContent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaContent(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaContent * SOAP_FMAC4 soap_in_ns3__XmlSchemaContent(struct soap *soap, const char *tag, ns3__XmlSchemaContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaContent, sizeof(ns3__XmlSchemaContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaContent *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaContent, 0, sizeof(ns3__XmlSchemaContent), 0, soap_copy_ns3__XmlSchemaContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaContent);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaContent(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaContent * SOAP_FMAC4 soap_get_ns3__XmlSchemaContent(struct soap *soap, ns3__XmlSchemaContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaContent * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaContent);
		if (size)
			*size = sizeof(ns3__XmlSchemaContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaContent, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaContent %p -> %p\n", q, p));
	*(ns3__XmlSchemaContent*)p = *(ns3__XmlSchemaContent*)q;
}

void ns3__XmlSchemaComplexContentRestriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaComplexContentRestriction::all = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::group = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::choice = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::sequence = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::__size_XmlSchemaComplexContentRestriction_ = 0;
	this->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::anyAttribute = NULL;
	this->ns3__XmlSchemaComplexContentRestriction::base = NULL;
}

void ns3__XmlSchemaComplexContentRestriction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAll(soap, &this->ns3__XmlSchemaComplexContentRestriction::all);
	soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, &this->ns3__XmlSchemaComplexContentRestriction::group);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->ns3__XmlSchemaComplexContentRestriction::choice);
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->ns3__XmlSchemaComplexContentRestriction::sequence);
	if (this->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaComplexContentRestriction::__size_XmlSchemaComplexContentRestriction_; i++)
		{
			this->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaComplexContentRestriction::anyAttribute);
#endif
}

int ns3__XmlSchemaComplexContentRestriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaComplexContentRestriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaComplexContentRestriction *a, const char *type)
{
	if (((ns3__XmlSchemaComplexContentRestriction*)a)->base)
		soap_set_attr(soap, "base", soap_QName2s(soap, ((ns3__XmlSchemaComplexContentRestriction*)a)->base->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAll(soap, "ns3:all", -1, &(a->ns3__XmlSchemaComplexContentRestriction::all), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", -1, &(a->ns3__XmlSchemaComplexContentRestriction::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->ns3__XmlSchemaComplexContentRestriction::choice), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->ns3__XmlSchemaComplexContentRestriction::sequence), ""))
		return soap->error;
	if (a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaComplexContentRestriction::__size_XmlSchemaComplexContentRestriction_; i++)
			if (a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_[i].soap_out(soap, "-union-XmlSchemaComplexContentRestriction", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaComplexContentRestriction::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaComplexContentRestriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaComplexContentRestriction(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContentRestriction * SOAP_FMAC4 soap_in_ns3__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, ns3__XmlSchemaComplexContentRestriction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaComplexContentRestriction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction, sizeof(ns3__XmlSchemaComplexContentRestriction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaComplexContentRestriction *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "base", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaComplexContentRestriction*)a)->base = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaComplexContentRestriction*)a)->base->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_all1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaComplexContentRestriction_1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_all1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAll(soap, "ns3:all", &(a->ns3__XmlSchemaComplexContentRestriction::all), "xsd:XmlSchemaAll"))
				{	soap_flag_all1--;
					continue;
				}
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", &(a->ns3__XmlSchemaComplexContentRestriction::group), "xsd:XmlSchemaGroupRef"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->ns3__XmlSchemaComplexContentRestriction::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->ns3__XmlSchemaComplexContentRestriction::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaComplexContentRestriction::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ == NULL)
				{	if (soap_blist___union_XmlSchemaComplexContentRestriction_1 == NULL)
						soap_blist___union_XmlSchemaComplexContentRestriction_1 = soap_new_block(soap);
					a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ = (__ns3__union_XmlSchemaComplexContentRestriction_ *)soap_push_block(soap, soap_blist___union_XmlSchemaComplexContentRestriction_1, sizeof(__ns3__union_XmlSchemaComplexContentRestriction_));
					if (a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_, __ns3__union_XmlSchemaComplexContentRestriction_);
					a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaComplexContentRestriction_(soap, "-union-XmlSchemaComplexContentRestriction", a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_, "-ns3:union-XmlSchemaComplexContentRestriction"))
				{	a->ns3__XmlSchemaComplexContentRestriction::__size_XmlSchemaComplexContentRestriction_++;
					a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_)
			soap_pop_block(soap, soap_blist___union_XmlSchemaComplexContentRestriction_1);
		if (a->ns3__XmlSchemaComplexContentRestriction::__size_XmlSchemaComplexContentRestriction_)
			a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ = (__ns3__union_XmlSchemaComplexContentRestriction_ *)soap_save_block(soap, soap_blist___union_XmlSchemaComplexContentRestriction_1, NULL, 1);
		else
		{	a->ns3__XmlSchemaComplexContentRestriction::__union_XmlSchemaComplexContentRestriction_ = NULL;
			if (soap_blist___union_XmlSchemaComplexContentRestriction_1)
				soap_end_block(soap, soap_blist___union_XmlSchemaComplexContentRestriction_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaComplexContentRestriction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction, 0, sizeof(ns3__XmlSchemaComplexContentRestriction), 0, soap_copy_ns3__XmlSchemaComplexContentRestriction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaComplexContentRestriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaComplexContentRestriction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaComplexContentRestriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaComplexContentRestriction(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContentRestriction * SOAP_FMAC4 soap_get_ns3__XmlSchemaComplexContentRestriction(struct soap *soap, ns3__XmlSchemaComplexContentRestriction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaComplexContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaComplexContentRestriction * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaComplexContentRestriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaComplexContentRestriction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaComplexContentRestriction);
		if (size)
			*size = sizeof(ns3__XmlSchemaComplexContentRestriction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaComplexContentRestriction, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaComplexContentRestriction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaComplexContentRestriction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaComplexContentRestriction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaComplexContentRestriction %p -> %p\n", q, p));
	*(ns3__XmlSchemaComplexContentRestriction*)p = *(ns3__XmlSchemaComplexContentRestriction*)q;
}

void ns3__XmlSchemaComplexContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaComplexContent::restriction = NULL;
	this->ns3__XmlSchemaComplexContent::extension = NULL;
	soap_default_bool(soap, &this->ns3__XmlSchemaComplexContent::mixed);
}

void ns3__XmlSchemaComplexContent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaComplexContentRestriction(soap, &this->ns3__XmlSchemaComplexContent::restriction);
	soap_serialize_PointerToxsd__XmlSchemaComplexContentExtension(soap, &this->ns3__XmlSchemaComplexContent::extension);
#endif
}

int ns3__XmlSchemaComplexContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaComplexContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaComplexContent(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaComplexContent *a, const char *type)
{
	soap_set_attr(soap, "mixed", soap_bool2s(soap, ((ns3__XmlSchemaComplexContent*)a)->mixed), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaComplexContent), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexContentRestriction(soap, "ns3:restriction", -1, &(a->ns3__XmlSchemaComplexContent::restriction), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexContentExtension(soap, "ns3:extension", -1, &(a->ns3__XmlSchemaComplexContent::extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaComplexContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaComplexContent(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContent * SOAP_FMAC4 soap_in_ns3__XmlSchemaComplexContent(struct soap *soap, const char *tag, ns3__XmlSchemaComplexContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaComplexContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaComplexContent, sizeof(ns3__XmlSchemaComplexContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaComplexContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaComplexContent *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "mixed", 1), &((ns3__XmlSchemaComplexContent*)a)->mixed))
		return NULL;
	size_t soap_flag_restriction1 = 1;
	size_t soap_flag_extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_restriction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexContentRestriction(soap, "ns3:restriction", &(a->ns3__XmlSchemaComplexContent::restriction), "xsd:XmlSchemaComplexContentRestriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexContentExtension(soap, "ns3:extension", &(a->ns3__XmlSchemaComplexContent::extension), "xsd:XmlSchemaComplexContentExtension"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaComplexContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaComplexContent, 0, sizeof(ns3__XmlSchemaComplexContent), 0, soap_copy_ns3__XmlSchemaComplexContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaComplexContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaComplexContent);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaComplexContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaComplexContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaComplexContent(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexContent * SOAP_FMAC4 soap_get_ns3__XmlSchemaComplexContent(struct soap *soap, ns3__XmlSchemaComplexContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaComplexContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaComplexContent * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaComplexContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaComplexContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaComplexContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaComplexContent);
		if (size)
			*size = sizeof(ns3__XmlSchemaComplexContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaComplexContent, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaComplexContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaComplexContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaComplexContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaComplexContent %p -> %p\n", q, p));
	*(ns3__XmlSchemaComplexContent*)p = *(ns3__XmlSchemaComplexContent*)q;
}

void ns3__XmlSchemaContentModel::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void ns3__XmlSchemaContentModel::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaContentModel::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaContentModel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaContentModel(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaContentModel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaContentModel), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaContentModel::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaContentModel(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaContentModel * SOAP_FMAC4 soap_in_ns3__XmlSchemaContentModel(struct soap *soap, const char *tag, ns3__XmlSchemaContentModel *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaContentModel *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaContentModel, sizeof(ns3__XmlSchemaContentModel), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaContentModel)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaContentModel *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaContentModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaContentModel, 0, sizeof(ns3__XmlSchemaContentModel), 0, soap_copy_ns3__XmlSchemaContentModel);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaContentModel::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaContentModel);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaContentModel", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaContentModel::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaContentModel(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaContentModel * SOAP_FMAC4 soap_get_ns3__XmlSchemaContentModel(struct soap *soap, ns3__XmlSchemaContentModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaContentModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaContentModel * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaContentModel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaContentModel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaContentModel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaContentModel);
		if (size)
			*size = sizeof(ns3__XmlSchemaContentModel);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaContentModel, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaContentModel);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaContentModel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaContentModel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaContentModel %p -> %p\n", q, p));
	*(ns3__XmlSchemaContentModel*)p = *(ns3__XmlSchemaContentModel*)q;
}

void ns3__XmlSchemaSimpleContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleContent::restriction = NULL;
	this->ns3__XmlSchemaSimpleContent::extension = NULL;
}

void ns3__XmlSchemaSimpleContent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, &this->ns3__XmlSchemaSimpleContent::restriction);
	soap_serialize_PointerToxsd__XmlSchemaSimpleContentExtension(soap, &this->ns3__XmlSchemaSimpleContent::extension);
#endif
}

int ns3__XmlSchemaSimpleContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleContent(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContent), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, "ns3:restriction", -1, &(a->ns3__XmlSchemaSimpleContent::restriction), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleContentExtension(soap, "ns3:extension", -1, &(a->ns3__XmlSchemaSimpleContent::extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleContent(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContent * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleContent(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleContent, sizeof(ns3__XmlSchemaSimpleContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_restriction1 = 1;
	size_t soap_flag_extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_restriction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, "ns3:restriction", &(a->ns3__XmlSchemaSimpleContent::restriction), "xsd:XmlSchemaSimpleContentRestriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleContentExtension(soap, "ns3:extension", &(a->ns3__XmlSchemaSimpleContent::extension), "xsd:XmlSchemaSimpleContentExtension"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleContent, 0, sizeof(ns3__XmlSchemaSimpleContent), 0, soap_copy_ns3__XmlSchemaSimpleContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleContent);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleContent(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleContent * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleContent(struct soap *soap, ns3__XmlSchemaSimpleContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleContent * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleContent);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleContent, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleContent %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleContent*)p = *(ns3__XmlSchemaSimpleContent*)q;
}

void ns3__XmlSchemaComplexType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaComplexType::simpleContent = NULL;
	this->ns3__XmlSchemaComplexType::complexContent = NULL;
	this->ns3__XmlSchemaComplexType::group = NULL;
	this->ns3__XmlSchemaComplexType::sequence = NULL;
	this->ns3__XmlSchemaComplexType::choice = NULL;
	this->ns3__XmlSchemaComplexType::all = NULL;
	this->ns3__XmlSchemaComplexType::__size_XmlSchemaComplexType__ = 0;
	this->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ = NULL;
	this->ns3__XmlSchemaComplexType::anyAttribute = NULL;
	this->ns3__XmlSchemaComplexType::abstract = (bool)0;
	this->ns3__XmlSchemaComplexType::block = NULL;
	this->ns3__XmlSchemaComplexType::mixed = (bool)0;
}

void ns3__XmlSchemaComplexType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleContent(soap, &this->ns3__XmlSchemaComplexType::simpleContent);
	soap_serialize_PointerToxsd__XmlSchemaComplexContent(soap, &this->ns3__XmlSchemaComplexType::complexContent);
	soap_serialize_PointerToxsd__XmlSchemaGroupRef(soap, &this->ns3__XmlSchemaComplexType::group);
	soap_serialize_PointerToxsd__XmlSchemaSequence(soap, &this->ns3__XmlSchemaComplexType::sequence);
	soap_serialize_PointerToxsd__XmlSchemaChoice(soap, &this->ns3__XmlSchemaComplexType::choice);
	soap_serialize_PointerToxsd__XmlSchemaAll(soap, &this->ns3__XmlSchemaComplexType::all);
	if (this->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaComplexType::__size_XmlSchemaComplexType__; i++)
		{
			this->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaComplexType::anyAttribute);
#endif
}

int ns3__XmlSchemaComplexType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaComplexType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaComplexType(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaComplexType *a, const char *type)
{
	soap_set_attr(soap, "abstract", soap_bool2s(soap, ((ns3__XmlSchemaComplexType*)a)->abstract), 1);
	if (((ns3__XmlSchemaComplexType*)a)->block)
		soap_set_attr(soap, "block", ((ns3__XmlSchemaComplexType*)a)->block->c_str(), 1);
	soap_set_attr(soap, "mixed", soap_bool2s(soap, ((ns3__XmlSchemaComplexType*)a)->mixed), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaComplexType), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleContent(soap, "ns3:simpleContent", -1, &(a->ns3__XmlSchemaComplexType::simpleContent), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaComplexContent(soap, "ns3:complexContent", -1, &(a->ns3__XmlSchemaComplexType::complexContent), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", -1, &(a->ns3__XmlSchemaComplexType::group), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", -1, &(a->ns3__XmlSchemaComplexType::sequence), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", -1, &(a->ns3__XmlSchemaComplexType::choice), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAll(soap, "ns3:all", -1, &(a->ns3__XmlSchemaComplexType::all), ""))
		return soap->error;
	if (a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaComplexType::__size_XmlSchemaComplexType__; i++)
			if (a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__[i].soap_out(soap, "-union-XmlSchemaComplexType", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaComplexType::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaComplexType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaComplexType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexType * SOAP_FMAC4 soap_in_ns3__XmlSchemaComplexType(struct soap *soap, const char *tag, ns3__XmlSchemaComplexType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaComplexType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaComplexType, sizeof(ns3__XmlSchemaComplexType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaComplexType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaComplexType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "abstract", 0), &((ns3__XmlSchemaComplexType*)a)->abstract))
		return NULL;
	{	const char *t = soap_attr_value(soap, "block", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaComplexType*)a)->block = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaComplexType*)a)->block->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "mixed", 0), &((ns3__XmlSchemaComplexType*)a)->mixed))
		return NULL;
	size_t soap_flag_simpleContent1 = 1;
	size_t soap_flag_complexContent1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_all1 = 1;
	struct soap_blist *soap_blist___union_XmlSchemaComplexType__1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleContent(soap, "ns3:simpleContent", &(a->ns3__XmlSchemaComplexType::simpleContent), "xsd:XmlSchemaSimpleContent"))
				{	soap_flag_simpleContent1--;
					continue;
				}
			if (soap_flag_complexContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaComplexContent(soap, "ns3:complexContent", &(a->ns3__XmlSchemaComplexType::complexContent), "xsd:XmlSchemaComplexContent"))
				{	soap_flag_complexContent1--;
					continue;
				}
			if (soap_flag_group1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaGroupRef(soap, "ns3:group", &(a->ns3__XmlSchemaComplexType::group), "xsd:XmlSchemaGroupRef"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSequence(soap, "ns3:sequence", &(a->ns3__XmlSchemaComplexType::sequence), "xsd:XmlSchemaSequence"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_choice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaChoice(soap, "ns3:choice", &(a->ns3__XmlSchemaComplexType::choice), "xsd:XmlSchemaChoice"))
				{	soap_flag_choice1--;
					continue;
				}
			if (soap_flag_all1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAll(soap, "ns3:all", &(a->ns3__XmlSchemaComplexType::all), "xsd:XmlSchemaAll"))
				{	soap_flag_all1--;
					continue;
				}
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaComplexType::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ == NULL)
				{	if (soap_blist___union_XmlSchemaComplexType__1 == NULL)
						soap_blist___union_XmlSchemaComplexType__1 = soap_new_block(soap);
					a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ = (__ns3__union_XmlSchemaComplexType__ *)soap_push_block(soap, soap_blist___union_XmlSchemaComplexType__1, sizeof(__ns3__union_XmlSchemaComplexType__));
					if (a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__, __ns3__union_XmlSchemaComplexType__);
					a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaComplexType__(soap, "-union-XmlSchemaComplexType", a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__, "-ns3:union-XmlSchemaComplexType"))
				{	a->ns3__XmlSchemaComplexType::__size_XmlSchemaComplexType__++;
					a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__)
			soap_pop_block(soap, soap_blist___union_XmlSchemaComplexType__1);
		if (a->ns3__XmlSchemaComplexType::__size_XmlSchemaComplexType__)
			a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ = (__ns3__union_XmlSchemaComplexType__ *)soap_save_block(soap, soap_blist___union_XmlSchemaComplexType__1, NULL, 1);
		else
		{	a->ns3__XmlSchemaComplexType::__union_XmlSchemaComplexType__ = NULL;
			if (soap_blist___union_XmlSchemaComplexType__1)
				soap_end_block(soap, soap_blist___union_XmlSchemaComplexType__1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaComplexType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaComplexType, 0, sizeof(ns3__XmlSchemaComplexType), 0, soap_copy_ns3__XmlSchemaComplexType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaComplexType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaComplexType);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaComplexType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaComplexType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaComplexType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaComplexType * SOAP_FMAC4 soap_get_ns3__XmlSchemaComplexType(struct soap *soap, ns3__XmlSchemaComplexType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaComplexType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaComplexType * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaComplexType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaComplexType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaComplexType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaComplexType);
		if (size)
			*size = sizeof(ns3__XmlSchemaComplexType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaComplexType, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaComplexType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaComplexType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaComplexType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaComplexType %p -> %p\n", q, p));
	*(ns3__XmlSchemaComplexType*)p = *(ns3__XmlSchemaComplexType*)q;
}

void ns3__XmlSchemaType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaType::name = NULL;
	this->ns3__XmlSchemaType::final = NULL;
}

void ns3__XmlSchemaType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaType(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaType *a, const char *type)
{
	if (((ns3__XmlSchemaType*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaType*)a)->name->c_str(), 1);
	if (((ns3__XmlSchemaType*)a)->final)
		soap_set_attr(soap, "final", ((ns3__XmlSchemaType*)a)->final->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaType * SOAP_FMAC4 soap_in_ns3__XmlSchemaType(struct soap *soap, const char *tag, ns3__XmlSchemaType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaType, sizeof(ns3__XmlSchemaType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaType*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "final", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaType*)a)->final = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaType*)a)->final->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaType, 0, sizeof(ns3__XmlSchemaType), 0, soap_copy_ns3__XmlSchemaType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaType);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaType * SOAP_FMAC4 soap_get_ns3__XmlSchemaType(struct soap *soap, ns3__XmlSchemaType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaType * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaType);
		if (size)
			*size = sizeof(ns3__XmlSchemaType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaType, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaType %p -> %p\n", q, p));
	*(ns3__XmlSchemaType*)p = *(ns3__XmlSchemaType*)q;
}

void ns3__XmlSchemaSimpleType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaSimpleType::union_ = NULL;
	this->ns3__XmlSchemaSimpleType::list = NULL;
	this->ns3__XmlSchemaSimpleType::restriction = NULL;
}

void ns3__XmlSchemaSimpleType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, &this->ns3__XmlSchemaSimpleType::union_);
	soap_serialize_PointerToxsd__XmlSchemaSimpleTypeList(soap, &this->ns3__XmlSchemaSimpleType::list);
	soap_serialize_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, &this->ns3__XmlSchemaSimpleType::restriction);
#endif
}

int ns3__XmlSchemaSimpleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaSimpleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaSimpleType(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaSimpleType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaSimpleType), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, "ns3:union", -1, &(a->ns3__XmlSchemaSimpleType::union_), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeList(soap, "ns3:list", -1, &(a->ns3__XmlSchemaSimpleType::list), ""))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, "ns3:restriction", -1, &(a->ns3__XmlSchemaSimpleType::restriction), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaSimpleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaSimpleType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleType * SOAP_FMAC4 soap_in_ns3__XmlSchemaSimpleType(struct soap *soap, const char *tag, ns3__XmlSchemaSimpleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaSimpleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaSimpleType, sizeof(ns3__XmlSchemaSimpleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaSimpleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaSimpleType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_union_1 = 1;
	size_t soap_flag_list1 = 1;
	size_t soap_flag_restriction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, "ns3:union", &(a->ns3__XmlSchemaSimpleType::union_), "xsd:XmlSchemaSimpleTypeUnion"))
				{	soap_flag_union_1--;
					continue;
				}
			if (soap_flag_list1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleTypeList(soap, "ns3:list", &(a->ns3__XmlSchemaSimpleType::list), "xsd:XmlSchemaSimpleTypeList"))
				{	soap_flag_list1--;
					continue;
				}
			if (soap_flag_restriction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, "ns3:restriction", &(a->ns3__XmlSchemaSimpleType::restriction), "xsd:XmlSchemaSimpleTypeRestriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaSimpleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaSimpleType, 0, sizeof(ns3__XmlSchemaSimpleType), 0, soap_copy_ns3__XmlSchemaSimpleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaSimpleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaSimpleType);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaSimpleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaSimpleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaSimpleType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaSimpleType * SOAP_FMAC4 soap_get_ns3__XmlSchemaSimpleType(struct soap *soap, ns3__XmlSchemaSimpleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaSimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaSimpleType * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaSimpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaSimpleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaSimpleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaSimpleType);
		if (size)
			*size = sizeof(ns3__XmlSchemaSimpleType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaSimpleType, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaSimpleType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaSimpleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaSimpleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaSimpleType %p -> %p\n", q, p));
	*(ns3__XmlSchemaSimpleType*)p = *(ns3__XmlSchemaSimpleType*)q;
}

void ns3__XmlSchemaAttribute::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAttribute::simpleType = NULL;
	this->ns3__XmlSchemaAttribute::default_ = NULL;
	this->ns3__XmlSchemaAttribute::fixed = NULL;
	this->ns3__XmlSchemaAttribute::form = NULL;
	this->ns3__XmlSchemaAttribute::name = NULL;
	this->ns3__XmlSchemaAttribute::ref = NULL;
	this->ns3__XmlSchemaAttribute::type = NULL;
	this->ns3__XmlSchemaAttribute::use = NULL;
}

void ns3__XmlSchemaAttribute::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaSimpleType(soap, &this->ns3__XmlSchemaAttribute::simpleType);
#endif
}

int ns3__XmlSchemaAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAttribute(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAttribute *a, const char *type)
{
	if (((ns3__XmlSchemaAttribute*)a)->default_)
		soap_set_attr(soap, "default", ((ns3__XmlSchemaAttribute*)a)->default_->c_str(), 1);
	if (((ns3__XmlSchemaAttribute*)a)->fixed)
		soap_set_attr(soap, "fixed", ((ns3__XmlSchemaAttribute*)a)->fixed->c_str(), 1);
	if (((ns3__XmlSchemaAttribute*)a)->form)
		soap_set_attr(soap, "form", ((ns3__XmlSchemaAttribute*)a)->form->c_str(), 1);
	if (((ns3__XmlSchemaAttribute*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaAttribute*)a)->name->c_str(), 1);
	if (((ns3__XmlSchemaAttribute*)a)->ref)
		soap_set_attr(soap, "ref", soap_QName2s(soap, ((ns3__XmlSchemaAttribute*)a)->ref->c_str()), 1);
	if (((ns3__XmlSchemaAttribute*)a)->type)
		soap_set_attr(soap, "type", soap_QName2s(soap, ((ns3__XmlSchemaAttribute*)a)->type->c_str()), 1);
	if (((ns3__XmlSchemaAttribute*)a)->use)
		soap_set_attr(soap, "use", ((ns3__XmlSchemaAttribute*)a)->use->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAttribute), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", -1, &(a->ns3__XmlSchemaAttribute::simpleType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAttribute(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttribute * SOAP_FMAC4 soap_in_ns3__XmlSchemaAttribute(struct soap *soap, const char *tag, ns3__XmlSchemaAttribute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAttribute, sizeof(ns3__XmlSchemaAttribute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAttribute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAttribute *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "default", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->default_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->default_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->fixed = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->fixed->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "form", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->form = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->form->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ref", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->ref = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->ref->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "type", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->type = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->type->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "use", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttribute*)a)->use = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttribute*)a)->use->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_simpleType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaSimpleType(soap, "ns3:simpleType", &(a->ns3__XmlSchemaAttribute::simpleType), "xsd:XmlSchemaSimpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAttribute, 0, sizeof(ns3__XmlSchemaAttribute), 0, soap_copy_ns3__XmlSchemaAttribute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAttribute);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAttribute", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAttribute(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttribute * SOAP_FMAC4 soap_get_ns3__XmlSchemaAttribute(struct soap *soap, ns3__XmlSchemaAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAttribute * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAttribute);
		if (size)
			*size = sizeof(ns3__XmlSchemaAttribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAttribute, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAttribute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAttribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAttribute %p -> %p\n", q, p));
	*(ns3__XmlSchemaAttribute*)p = *(ns3__XmlSchemaAttribute*)q;
}

void ns3__XmlSchemaAttributeGroupRef::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAttributeGroupRef::ref = NULL;
}

void ns3__XmlSchemaAttributeGroupRef::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaAttributeGroupRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAttributeGroupRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAttributeGroupRef *a, const char *type)
{
	if (((ns3__XmlSchemaAttributeGroupRef*)a)->ref)
		soap_set_attr(soap, "ref", soap_QName2s(soap, ((ns3__XmlSchemaAttributeGroupRef*)a)->ref->c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAttributeGroupRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAttributeGroupRef(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttributeGroupRef * SOAP_FMAC4 soap_in_ns3__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, ns3__XmlSchemaAttributeGroupRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAttributeGroupRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef, sizeof(ns3__XmlSchemaAttributeGroupRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAttributeGroupRef *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ref", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttributeGroupRef*)a)->ref = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttributeGroupRef*)a)->ref->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAttributeGroupRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef, 0, sizeof(ns3__XmlSchemaAttributeGroupRef), 0, soap_copy_ns3__XmlSchemaAttributeGroupRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAttributeGroupRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAttributeGroupRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAttributeGroupRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAttributeGroupRef(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttributeGroupRef * SOAP_FMAC4 soap_get_ns3__XmlSchemaAttributeGroupRef(struct soap *soap, ns3__XmlSchemaAttributeGroupRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAttributeGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAttributeGroupRef * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAttributeGroupRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAttributeGroupRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAttributeGroupRef);
		if (size)
			*size = sizeof(ns3__XmlSchemaAttributeGroupRef);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAttributeGroupRef, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAttributeGroupRef);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAttributeGroupRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAttributeGroupRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAttributeGroupRef %p -> %p\n", q, p));
	*(ns3__XmlSchemaAttributeGroupRef*)p = *(ns3__XmlSchemaAttributeGroupRef*)q;
}

void ns3__XmlSchemaAttributeGroup::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAttributeGroup::__size_XmlSchemaAttributeGroup = 0;
	this->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup = NULL;
	this->ns3__XmlSchemaAttributeGroup::anyAttribute = NULL;
	this->ns3__XmlSchemaAttributeGroup::name = NULL;
}

void ns3__XmlSchemaAttributeGroup::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaAttributeGroup::__size_XmlSchemaAttributeGroup; i++)
		{
			this->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(soap, &this->ns3__XmlSchemaAttributeGroup::anyAttribute);
#endif
}

int ns3__XmlSchemaAttributeGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAttributeGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAttributeGroup *a, const char *type)
{
	if (((ns3__XmlSchemaAttributeGroup*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaAttributeGroup*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAttributeGroup), type))
		return soap->error;
	if (a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaAttributeGroup::__size_XmlSchemaAttributeGroup; i++)
			if (a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup[i].soap_out(soap, "-union-XmlSchemaAttributeGroup", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", -1, &(a->ns3__XmlSchemaAttributeGroup::anyAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAttributeGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAttributeGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttributeGroup * SOAP_FMAC4 soap_in_ns3__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, ns3__XmlSchemaAttributeGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAttributeGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAttributeGroup, sizeof(ns3__XmlSchemaAttributeGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAttributeGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAttributeGroup *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAttributeGroup*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAttributeGroup*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_XmlSchemaAttributeGroup1 = NULL;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_anyAttribute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, "ns3:anyAttribute", &(a->ns3__XmlSchemaAttributeGroup::anyAttribute), "xsd:XmlSchemaAnyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup == NULL)
				{	if (soap_blist___union_XmlSchemaAttributeGroup1 == NULL)
						soap_blist___union_XmlSchemaAttributeGroup1 = soap_new_block(soap);
					a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup = (__ns3__union_XmlSchemaAttributeGroup *)soap_push_block(soap, soap_blist___union_XmlSchemaAttributeGroup1, sizeof(__ns3__union_XmlSchemaAttributeGroup));
					if (a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup, __ns3__union_XmlSchemaAttributeGroup);
					a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaAttributeGroup(soap, "-union-XmlSchemaAttributeGroup", a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup, "-ns3:union-XmlSchemaAttributeGroup"))
				{	a->ns3__XmlSchemaAttributeGroup::__size_XmlSchemaAttributeGroup++;
					a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup)
			soap_pop_block(soap, soap_blist___union_XmlSchemaAttributeGroup1);
		if (a->ns3__XmlSchemaAttributeGroup::__size_XmlSchemaAttributeGroup)
			a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup = (__ns3__union_XmlSchemaAttributeGroup *)soap_save_block(soap, soap_blist___union_XmlSchemaAttributeGroup1, NULL, 1);
		else
		{	a->ns3__XmlSchemaAttributeGroup::__union_XmlSchemaAttributeGroup = NULL;
			if (soap_blist___union_XmlSchemaAttributeGroup1)
				soap_end_block(soap, soap_blist___union_XmlSchemaAttributeGroup1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAttributeGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAttributeGroup, 0, sizeof(ns3__XmlSchemaAttributeGroup), 0, soap_copy_ns3__XmlSchemaAttributeGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAttributeGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAttributeGroup);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAttributeGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAttributeGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAttributeGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAttributeGroup * SOAP_FMAC4 soap_get_ns3__XmlSchemaAttributeGroup(struct soap *soap, ns3__XmlSchemaAttributeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAttributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAttributeGroup * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAttributeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAttributeGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAttributeGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAttributeGroup);
		if (size)
			*size = sizeof(ns3__XmlSchemaAttributeGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAttributeGroup, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAttributeGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAttributeGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAttributeGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAttributeGroup %p -> %p\n", q, p));
	*(ns3__XmlSchemaAttributeGroup*)p = *(ns3__XmlSchemaAttributeGroup*)q;
}

void ns3__XmlSchemaNotation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaNotation::name = NULL;
	this->ns3__XmlSchemaNotation::public_ = NULL;
	this->ns3__XmlSchemaNotation::system = NULL;
}

void ns3__XmlSchemaNotation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int ns3__XmlSchemaNotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaNotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaNotation(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaNotation *a, const char *type)
{
	if (((ns3__XmlSchemaNotation*)a)->name)
		soap_set_attr(soap, "name", ((ns3__XmlSchemaNotation*)a)->name->c_str(), 1);
	if (((ns3__XmlSchemaNotation*)a)->public_)
		soap_set_attr(soap, "public", ((ns3__XmlSchemaNotation*)a)->public_->c_str(), 1);
	if (((ns3__XmlSchemaNotation*)a)->system)
		soap_set_attr(soap, "system", ((ns3__XmlSchemaNotation*)a)->system->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaNotation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaNotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaNotation(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaNotation * SOAP_FMAC4 soap_in_ns3__XmlSchemaNotation(struct soap *soap, const char *tag, ns3__XmlSchemaNotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaNotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaNotation, sizeof(ns3__XmlSchemaNotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaNotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaNotation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaNotation*)a)->name = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaNotation*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "public", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaNotation*)a)->public_ = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaNotation*)a)->public_->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "system", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaNotation*)a)->system = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaNotation*)a)->system->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaNotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaNotation, 0, sizeof(ns3__XmlSchemaNotation), 0, soap_copy_ns3__XmlSchemaNotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaNotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaNotation);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaNotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaNotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaNotation(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaNotation * SOAP_FMAC4 soap_get_ns3__XmlSchemaNotation(struct soap *soap, ns3__XmlSchemaNotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaNotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaNotation * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaNotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaNotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaNotation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaNotation);
		if (size)
			*size = sizeof(ns3__XmlSchemaNotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaNotation, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaNotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaNotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaNotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaNotation %p -> %p\n", q, p));
	*(ns3__XmlSchemaNotation*)p = *(ns3__XmlSchemaNotation*)q;
}

void ns3__XmlSchemaAppInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns3__XmlSchemaAppInfo::__any);
	this->ns3__XmlSchemaAppInfo::source = NULL;
	this->ns3__XmlSchemaAppInfo::__mixed = NULL;
}

void ns3__XmlSchemaAppInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns3__XmlSchemaAppInfo::__any);
#endif
}

int ns3__XmlSchemaAppInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAppInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAppInfo(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAppInfo *a, const char *type)
{
	if (((ns3__XmlSchemaAppInfo*)a)->source)
		soap_set_attr(soap, "source", ((ns3__XmlSchemaAppInfo*)a)->source->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAppInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns3__XmlSchemaAppInfo::__any), ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &(a->ns3__XmlSchemaAppInfo::__mixed), NULL);
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAppInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAppInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAppInfo * SOAP_FMAC4 soap_in_ns3__XmlSchemaAppInfo(struct soap *soap, const char *tag, ns3__XmlSchemaAppInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAppInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAppInfo, sizeof(ns3__XmlSchemaAppInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAppInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAppInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "source", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAppInfo*)a)->source = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAppInfo*)a)->source->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns3__XmlSchemaAppInfo::__any), ""))
					continue;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->ns3__XmlSchemaAppInfo::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAppInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAppInfo, 0, sizeof(ns3__XmlSchemaAppInfo), 0, soap_copy_ns3__XmlSchemaAppInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAppInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAppInfo);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAppInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAppInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAppInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAppInfo * SOAP_FMAC4 soap_get_ns3__XmlSchemaAppInfo(struct soap *soap, ns3__XmlSchemaAppInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAppInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAppInfo * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAppInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAppInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAppInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAppInfo);
		if (size)
			*size = sizeof(ns3__XmlSchemaAppInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAppInfo, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAppInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAppInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAppInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAppInfo %p -> %p\n", q, p));
	*(ns3__XmlSchemaAppInfo*)p = *(ns3__XmlSchemaAppInfo*)q;
}

void ns3__XmlSchemaDocumentation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns3__XmlSchemaDocumentation::__any);
	this->ns3__XmlSchemaDocumentation::source = NULL;
	this->ns3__XmlSchemaDocumentation::xml__lang = NULL;
	this->ns3__XmlSchemaDocumentation::__mixed = NULL;
}

void ns3__XmlSchemaDocumentation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns3__XmlSchemaDocumentation::__any);
#endif
}

int ns3__XmlSchemaDocumentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaDocumentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaDocumentation(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaDocumentation *a, const char *type)
{
	if (((ns3__XmlSchemaDocumentation*)a)->source)
		soap_set_attr(soap, "source", ((ns3__XmlSchemaDocumentation*)a)->source->c_str(), 1);
	if (((ns3__XmlSchemaDocumentation*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", ((ns3__XmlSchemaDocumentation*)a)->xml__lang->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaDocumentation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns3__XmlSchemaDocumentation::__any), ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &(a->ns3__XmlSchemaDocumentation::__mixed), NULL);
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaDocumentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaDocumentation(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaDocumentation * SOAP_FMAC4 soap_in_ns3__XmlSchemaDocumentation(struct soap *soap, const char *tag, ns3__XmlSchemaDocumentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaDocumentation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaDocumentation, sizeof(ns3__XmlSchemaDocumentation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaDocumentation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaDocumentation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "source", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaDocumentation*)a)->source = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaDocumentation*)a)->source->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaDocumentation*)a)->xml__lang = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaDocumentation*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns3__XmlSchemaDocumentation::__any), ""))
					continue;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->ns3__XmlSchemaDocumentation::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaDocumentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaDocumentation, 0, sizeof(ns3__XmlSchemaDocumentation), 0, soap_copy_ns3__XmlSchemaDocumentation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaDocumentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaDocumentation);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaDocumentation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaDocumentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaDocumentation(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaDocumentation * SOAP_FMAC4 soap_get_ns3__XmlSchemaDocumentation(struct soap *soap, ns3__XmlSchemaDocumentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaDocumentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaDocumentation * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaDocumentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaDocumentation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaDocumentation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaDocumentation);
		if (size)
			*size = sizeof(ns3__XmlSchemaDocumentation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaDocumentation, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaDocumentation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaDocumentation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaDocumentation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaDocumentation %p -> %p\n", q, p));
	*(ns3__XmlSchemaDocumentation*)p = *(ns3__XmlSchemaDocumentation*)q;
}

void ns3__XmlSchemaAnnotation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAnnotation::__size_XmlSchemaAnnotation = 0;
	this->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation = NULL;
	this->ns3__XmlSchemaAnnotation::id = NULL;
	this->ns3__XmlSchemaAnnotation::__anyAttribute = NULL;
}

void ns3__XmlSchemaAnnotation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchemaAnnotation::__size_XmlSchemaAnnotation; i++)
		{
			this->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchemaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAnnotation(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAnnotation *a, const char *type)
{
	if (((ns3__XmlSchemaAnnotation*)a)->id)
		soap_set_attr(soap, "id", ((ns3__XmlSchemaAnnotation*)a)->id->c_str(), 1);
	if (((ns3__XmlSchemaAnnotation*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__XmlSchemaAnnotation*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAnnotation), type))
		return soap->error;
	if (a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchemaAnnotation::__size_XmlSchemaAnnotation; i++)
			if (a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation[i].soap_out(soap, "-union-XmlSchemaAnnotation", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnnotation * SOAP_FMAC4 soap_in_ns3__XmlSchemaAnnotation(struct soap *soap, const char *tag, ns3__XmlSchemaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAnnotation, sizeof(ns3__XmlSchemaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAnnotation*)a)->id = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAnnotation*)a)->id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns3__XmlSchemaAnnotation*)a)->__anyAttribute, 0, -1))
		return NULL;
	struct soap_blist *soap_blist___union_XmlSchemaAnnotation1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation == NULL)
				{	if (soap_blist___union_XmlSchemaAnnotation1 == NULL)
						soap_blist___union_XmlSchemaAnnotation1 = soap_new_block(soap);
					a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation = (__ns3__union_XmlSchemaAnnotation *)soap_push_block(soap, soap_blist___union_XmlSchemaAnnotation1, sizeof(__ns3__union_XmlSchemaAnnotation));
					if (a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation, __ns3__union_XmlSchemaAnnotation);
					a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchemaAnnotation(soap, "-union-XmlSchemaAnnotation", a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation, "-ns3:union-XmlSchemaAnnotation"))
				{	a->ns3__XmlSchemaAnnotation::__size_XmlSchemaAnnotation++;
					a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation)
			soap_pop_block(soap, soap_blist___union_XmlSchemaAnnotation1);
		if (a->ns3__XmlSchemaAnnotation::__size_XmlSchemaAnnotation)
			a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation = (__ns3__union_XmlSchemaAnnotation *)soap_save_block(soap, soap_blist___union_XmlSchemaAnnotation1, NULL, 1);
		else
		{	a->ns3__XmlSchemaAnnotation::__union_XmlSchemaAnnotation = NULL;
			if (soap_blist___union_XmlSchemaAnnotation1)
				soap_end_block(soap, soap_blist___union_XmlSchemaAnnotation1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAnnotation, 0, sizeof(ns3__XmlSchemaAnnotation), 0, soap_copy_ns3__XmlSchemaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAnnotation);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnnotation * SOAP_FMAC4 soap_get_ns3__XmlSchemaAnnotation(struct soap *soap, ns3__XmlSchemaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAnnotation * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAnnotation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAnnotation);
		if (size)
			*size = sizeof(ns3__XmlSchemaAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAnnotation, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAnnotation %p -> %p\n", q, p));
	*(ns3__XmlSchemaAnnotation*)p = *(ns3__XmlSchemaAnnotation*)q;
}

void ns3__XmlSchemaAnnotated::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchemaAnnotated::annotation = NULL;
	this->ns3__XmlSchemaAnnotated::id = NULL;
	this->ns3__XmlSchemaAnnotated::__anyAttribute = NULL;
}

void ns3__XmlSchemaAnnotated::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__XmlSchemaAnnotation(soap, &this->ns3__XmlSchemaAnnotated::annotation);
#endif
}

int ns3__XmlSchemaAnnotated::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaAnnotated(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaAnnotated(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaAnnotated *a, const char *type)
{
	if (((ns3__XmlSchemaAnnotated*)a)->id)
		soap_set_attr(soap, "id", ((ns3__XmlSchemaAnnotated*)a)->id->c_str(), 1);
	if (((ns3__XmlSchemaAnnotated*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__XmlSchemaAnnotated*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaAnnotated), type))
		return soap->error;
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", -1, &(a->ns3__XmlSchemaAnnotated::annotation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaAnnotated::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaAnnotated(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnnotated * SOAP_FMAC4 soap_in_ns3__XmlSchemaAnnotated(struct soap *soap, const char *tag, ns3__XmlSchemaAnnotated *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaAnnotated *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaAnnotated, sizeof(ns3__XmlSchemaAnnotated), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaAnnotated)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaAnnotated *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchemaAnnotated*)a)->id = soap_new_std__string(soap, -1);
				((ns3__XmlSchemaAnnotated*)a)->id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns3__XmlSchemaAnnotated*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__XmlSchemaAnnotation(soap, "ns3:annotation", &(a->ns3__XmlSchemaAnnotated::annotation), "xsd:XmlSchemaAnnotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaAnnotated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaAnnotated, 0, sizeof(ns3__XmlSchemaAnnotated), 0, soap_copy_ns3__XmlSchemaAnnotated);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaAnnotated::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaAnnotated);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaAnnotated", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaAnnotated::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaAnnotated(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaAnnotated * SOAP_FMAC4 soap_get_ns3__XmlSchemaAnnotated(struct soap *soap, ns3__XmlSchemaAnnotated *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaAnnotated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaAnnotated * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaAnnotated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaAnnotated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaAnnotated, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaAnnotated);
		if (size)
			*size = sizeof(ns3__XmlSchemaAnnotated);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaAnnotated, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaAnnotated);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaAnnotated*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaAnnotated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaAnnotated %p -> %p\n", q, p));
	*(ns3__XmlSchemaAnnotated*)p = *(ns3__XmlSchemaAnnotated*)q;
}

void ns3__XmlSchemaObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns3__XmlSchemaObject::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns3__XmlSchemaObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchemaObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchemaObject(struct soap *soap, const char *tag, int id, const ns3__XmlSchemaObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchemaObject), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchemaObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchemaObject(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchemaObject * SOAP_FMAC4 soap_in_ns3__XmlSchemaObject(struct soap *soap, const char *tag, ns3__XmlSchemaObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchemaObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchemaObject, sizeof(ns3__XmlSchemaObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchemaObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchemaObject *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchemaObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchemaObject, 0, sizeof(ns3__XmlSchemaObject), 0, soap_copy_ns3__XmlSchemaObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchemaObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchemaObject);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchemaObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchemaObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchemaObject(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchemaObject * SOAP_FMAC4 soap_get_ns3__XmlSchemaObject(struct soap *soap, ns3__XmlSchemaObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchemaObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchemaObject * SOAP_FMAC2 soap_instantiate_ns3__XmlSchemaObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchemaObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchemaObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchemaObject);
		if (size)
			*size = sizeof(ns3__XmlSchemaObject);
		((ns3__XmlSchemaObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchemaObject, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchemaObject);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__XmlSchemaObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchemaObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchemaObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchemaObject %p -> %p\n", q, p));
	*(ns3__XmlSchemaObject*)p = *(ns3__XmlSchemaObject*)q;
}

void ns3__XmlSchema::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__XmlSchema::__size_XmlSchema = 0;
	this->ns3__XmlSchema::__union_XmlSchema = NULL;
	this->ns3__XmlSchema::__size_XmlSchema_ = 0;
	this->ns3__XmlSchema::__union_XmlSchema_ = NULL;
	this->ns3__XmlSchema::attributeFormDefault = NULL;
	this->ns3__XmlSchema::blockDefault = NULL;
	this->ns3__XmlSchema::finalDefault = NULL;
	this->ns3__XmlSchema::elementFormDefault = NULL;
	this->ns3__XmlSchema::targetNamespace = NULL;
	this->ns3__XmlSchema::version = NULL;
	this->ns3__XmlSchema::id = NULL;
	this->ns3__XmlSchema::__anyAttribute = NULL;
}

void ns3__XmlSchema::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__XmlSchema::__union_XmlSchema)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchema::__size_XmlSchema; i++)
		{
			this->ns3__XmlSchema::__union_XmlSchema[i].soap_serialize(soap);
		}
	}
	if (this->ns3__XmlSchema::__union_XmlSchema_)
	{	int i;
		for (i = 0; i < this->ns3__XmlSchema::__size_XmlSchema_; i++)
		{
			this->ns3__XmlSchema::__union_XmlSchema_[i].soap_serialize(soap);
		}
	}
#endif
}

int ns3__XmlSchema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__XmlSchema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__XmlSchema(struct soap *soap, const char *tag, int id, const ns3__XmlSchema *a, const char *type)
{
	if (((ns3__XmlSchema*)a)->attributeFormDefault)
		soap_set_attr(soap, "attributeFormDefault", ((ns3__XmlSchema*)a)->attributeFormDefault->c_str(), 1);
	if (((ns3__XmlSchema*)a)->blockDefault)
		soap_set_attr(soap, "blockDefault", ((ns3__XmlSchema*)a)->blockDefault->c_str(), 1);
	if (((ns3__XmlSchema*)a)->finalDefault)
		soap_set_attr(soap, "finalDefault", ((ns3__XmlSchema*)a)->finalDefault->c_str(), 1);
	if (((ns3__XmlSchema*)a)->elementFormDefault)
		soap_set_attr(soap, "elementFormDefault", ((ns3__XmlSchema*)a)->elementFormDefault->c_str(), 1);
	if (((ns3__XmlSchema*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", ((ns3__XmlSchema*)a)->targetNamespace->c_str(), 1);
	if (((ns3__XmlSchema*)a)->version)
		soap_set_attr(soap, "version", ((ns3__XmlSchema*)a)->version->c_str(), 1);
	if (((ns3__XmlSchema*)a)->id)
		soap_set_attr(soap, "id", ((ns3__XmlSchema*)a)->id->c_str(), 1);
	if (((ns3__XmlSchema*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__XmlSchema*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__XmlSchema), type))
		return soap->error;
	if (a->ns3__XmlSchema::__union_XmlSchema)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchema::__size_XmlSchema; i++)
			if (a->ns3__XmlSchema::__union_XmlSchema[i].soap_out(soap, "-union-XmlSchema", -1, ""))
				return soap->error;
	}
	if (a->ns3__XmlSchema::__union_XmlSchema_)
	{	int i;
		for (i = 0; i < a->ns3__XmlSchema::__size_XmlSchema_; i++)
			if (a->ns3__XmlSchema::__union_XmlSchema_[i].soap_out(soap, "-union-XmlSchema", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns3__XmlSchema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__XmlSchema(soap, tag, this, type);
}

SOAP_FMAC3 ns3__XmlSchema * SOAP_FMAC4 soap_in_ns3__XmlSchema(struct soap *soap, const char *tag, ns3__XmlSchema *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__XmlSchema *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__XmlSchema, sizeof(ns3__XmlSchema), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__XmlSchema)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__XmlSchema *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "attributeFormDefault", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->attributeFormDefault = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->attributeFormDefault->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "blockDefault", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->blockDefault = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->blockDefault->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "finalDefault", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->finalDefault = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->finalDefault->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "elementFormDefault", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->elementFormDefault = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->elementFormDefault->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "targetNamespace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->targetNamespace = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->targetNamespace->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->version = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->version->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns3__XmlSchema*)a)->id = soap_new_std__string(soap, -1);
				((ns3__XmlSchema*)a)->id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns3__XmlSchema*)a)->__anyAttribute, 0, -1))
		return NULL;
	struct soap_blist *soap_blist___union_XmlSchema1 = NULL;
	struct soap_blist *soap_blist___union_XmlSchema_1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchema::__union_XmlSchema == NULL)
				{	if (soap_blist___union_XmlSchema1 == NULL)
						soap_blist___union_XmlSchema1 = soap_new_block(soap);
					a->ns3__XmlSchema::__union_XmlSchema = (__ns3__union_XmlSchema *)soap_push_block(soap, soap_blist___union_XmlSchema1, sizeof(__ns3__union_XmlSchema));
					if (a->ns3__XmlSchema::__union_XmlSchema == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchema::__union_XmlSchema, __ns3__union_XmlSchema);
					a->ns3__XmlSchema::__union_XmlSchema->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchema(soap, "-union-XmlSchema", a->ns3__XmlSchema::__union_XmlSchema, "-ns3:union-XmlSchema"))
				{	a->ns3__XmlSchema::__size_XmlSchema++;
					a->ns3__XmlSchema::__union_XmlSchema = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns3__XmlSchema::__union_XmlSchema_ == NULL)
				{	if (soap_blist___union_XmlSchema_1 == NULL)
						soap_blist___union_XmlSchema_1 = soap_new_block(soap);
					a->ns3__XmlSchema::__union_XmlSchema_ = (__ns3__union_XmlSchema_ *)soap_push_block(soap, soap_blist___union_XmlSchema_1, sizeof(__ns3__union_XmlSchema_));
					if (a->ns3__XmlSchema::__union_XmlSchema_ == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns3__XmlSchema::__union_XmlSchema_, __ns3__union_XmlSchema_);
					a->ns3__XmlSchema::__union_XmlSchema_->soap_default(soap);
				}
				if (soap_in___ns3__union_XmlSchema_(soap, "-union-XmlSchema", a->ns3__XmlSchema::__union_XmlSchema_, "-ns3:union-XmlSchema"))
				{	a->ns3__XmlSchema::__size_XmlSchema_++;
					a->ns3__XmlSchema::__union_XmlSchema_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__XmlSchema::__union_XmlSchema)
			soap_pop_block(soap, soap_blist___union_XmlSchema1);
		if (a->ns3__XmlSchema::__size_XmlSchema)
			a->ns3__XmlSchema::__union_XmlSchema = (__ns3__union_XmlSchema *)soap_save_block(soap, soap_blist___union_XmlSchema1, NULL, 1);
		else
		{	a->ns3__XmlSchema::__union_XmlSchema = NULL;
			if (soap_blist___union_XmlSchema1)
				soap_end_block(soap, soap_blist___union_XmlSchema1);
		}
		if (a->ns3__XmlSchema::__union_XmlSchema_)
			soap_pop_block(soap, soap_blist___union_XmlSchema_1);
		if (a->ns3__XmlSchema::__size_XmlSchema_)
			a->ns3__XmlSchema::__union_XmlSchema_ = (__ns3__union_XmlSchema_ *)soap_save_block(soap, soap_blist___union_XmlSchema_1, NULL, 1);
		else
		{	a->ns3__XmlSchema::__union_XmlSchema_ = NULL;
			if (soap_blist___union_XmlSchema_1)
				soap_end_block(soap, soap_blist___union_XmlSchema_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__XmlSchema *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__XmlSchema, 0, sizeof(ns3__XmlSchema), 0, soap_copy_ns3__XmlSchema);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__XmlSchema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__XmlSchema);
	if (this->soap_out(soap, tag?tag:"ns3:XmlSchema", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__XmlSchema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__XmlSchema(soap, this, tag, type);
}

SOAP_FMAC3 ns3__XmlSchema * SOAP_FMAC4 soap_get_ns3__XmlSchema(struct soap *soap, ns3__XmlSchema *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__XmlSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__XmlSchema * SOAP_FMAC2 soap_instantiate_ns3__XmlSchema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__XmlSchema(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__XmlSchema, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__XmlSchema);
		if (size)
			*size = sizeof(ns3__XmlSchema);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__XmlSchema, n);
		if (size)
			*size = n * sizeof(ns3__XmlSchema);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__XmlSchema*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__XmlSchema(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__XmlSchema %p -> %p\n", q, p));
	*(ns3__XmlSchema*)p = *(ns3__XmlSchema*)q;
}

void ns2__CellInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__CellInfo::__any);
	/* transient soap skipped */
}

void ns2__CellInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__CellInfo::__any);
	/* transient soap skipped */
#endif
}

int ns2__CellInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CellInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CellInfo(struct soap *soap, const char *tag, int id, const ns2__CellInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CellInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__CellInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CellInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CellInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CellInfo * SOAP_FMAC4 soap_in_ns2__CellInfo(struct soap *soap, const char *tag, ns2__CellInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CellInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CellInfo, sizeof(ns2__CellInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CellInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CellInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__CellInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CellInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CellInfo, 0, sizeof(ns2__CellInfo), 0, soap_copy_ns2__CellInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CellInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CellInfo);
	if (this->soap_out(soap, tag?tag:"ns2:CellInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CellInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CellInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CellInfo * SOAP_FMAC4 soap_get_ns2__CellInfo(struct soap *soap, ns2__CellInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CellInfo * SOAP_FMAC2 soap_instantiate_ns2__CellInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CellInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CellInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CellInfo);
		if (size)
			*size = sizeof(ns2__CellInfo);
		((ns2__CellInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CellInfo, n);
		if (size)
			*size = n * sizeof(ns2__CellInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__CellInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__CellInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CellInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CellInfo %p -> %p\n", q, p));
	*(ns2__CellInfo*)p = *(ns2__CellInfo*)q;
}

void ns2__HierarchyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__HierarchyInfo::__any);
	this->ns2__HierarchyInfo::name = NULL;
	/* transient soap skipped */
}

void ns2__HierarchyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__HierarchyInfo::__any);
	/* transient soap skipped */
#endif
}

int ns2__HierarchyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HierarchyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HierarchyInfo(struct soap *soap, const char *tag, int id, const ns2__HierarchyInfo *a, const char *type)
{
	if (((ns2__HierarchyInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns2__HierarchyInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HierarchyInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__HierarchyInfo::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HierarchyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HierarchyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HierarchyInfo * SOAP_FMAC4 soap_in_ns2__HierarchyInfo(struct soap *soap, const char *tag, ns2__HierarchyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HierarchyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HierarchyInfo, sizeof(ns2__HierarchyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HierarchyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HierarchyInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__HierarchyInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns2__HierarchyInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__HierarchyInfo::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HierarchyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HierarchyInfo, 0, sizeof(ns2__HierarchyInfo), 0, soap_copy_ns2__HierarchyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__HierarchyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HierarchyInfo);
	if (this->soap_out(soap, tag?tag:"ns2:HierarchyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HierarchyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HierarchyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HierarchyInfo * SOAP_FMAC4 soap_get_ns2__HierarchyInfo(struct soap *soap, ns2__HierarchyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HierarchyInfo * SOAP_FMAC2 soap_instantiate_ns2__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HierarchyInfo);
		if (size)
			*size = sizeof(ns2__HierarchyInfo);
		((ns2__HierarchyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__HierarchyInfo, n);
		if (size)
			*size = n * sizeof(ns2__HierarchyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__HierarchyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__HierarchyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HierarchyInfo %p -> %p\n", q, p));
	*(ns2__HierarchyInfo*)p = *(ns2__HierarchyInfo*)q;
}

void ns2__AxisInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, &this->ns2__AxisInfo::HierarchyInfo);
	this->ns2__AxisInfo::name = NULL;
	/* transient soap skipped */
}

void ns2__AxisInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, &this->ns2__AxisInfo::HierarchyInfo);
	/* transient soap skipped */
#endif
}

int ns2__AxisInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AxisInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AxisInfo(struct soap *soap, const char *tag, int id, const ns2__AxisInfo *a, const char *type)
{
	if (((ns2__AxisInfo*)a)->name)
		soap_set_attr(soap, "name", ((ns2__AxisInfo*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AxisInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, "ns2:HierarchyInfo", -1, &(a->ns2__AxisInfo::HierarchyInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AxisInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AxisInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AxisInfo * SOAP_FMAC4 soap_in_ns2__AxisInfo(struct soap *soap, const char *tag, ns2__AxisInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AxisInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AxisInfo, sizeof(ns2__AxisInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AxisInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AxisInfo *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AxisInfo*)a)->name = soap_new_std__string(soap, -1);
				((ns2__AxisInfo*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, "ns2:HierarchyInfo", &(a->ns2__AxisInfo::HierarchyInfo), "ns2:HierarchyInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AxisInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AxisInfo, 0, sizeof(ns2__AxisInfo), 0, soap_copy_ns2__AxisInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AxisInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AxisInfo);
	if (this->soap_out(soap, tag?tag:"ns2:AxisInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AxisInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AxisInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AxisInfo * SOAP_FMAC4 soap_get_ns2__AxisInfo(struct soap *soap, ns2__AxisInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AxisInfo * SOAP_FMAC2 soap_instantiate_ns2__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AxisInfo);
		if (size)
			*size = sizeof(ns2__AxisInfo);
		((ns2__AxisInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__AxisInfo, n);
		if (size)
			*size = n * sizeof(ns2__AxisInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__AxisInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__AxisInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AxisInfo %p -> %p\n", q, p));
	*(ns2__AxisInfo*)p = *(ns2__AxisInfo*)q;
}

void ns2__AxesInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__AxisInfo(soap, &this->ns2__AxesInfo::AxisInfo);
	/* transient soap skipped */
}

void ns2__AxesInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__AxisInfo(soap, &this->ns2__AxesInfo::AxisInfo);
	/* transient soap skipped */
#endif
}

int ns2__AxesInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AxesInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AxesInfo(struct soap *soap, const char *tag, int id, const ns2__AxesInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AxesInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__AxisInfo(soap, "ns2:AxisInfo", -1, &(a->ns2__AxesInfo::AxisInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AxesInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AxesInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AxesInfo * SOAP_FMAC4 soap_in_ns2__AxesInfo(struct soap *soap, const char *tag, ns2__AxesInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AxesInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AxesInfo, sizeof(ns2__AxesInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AxesInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AxesInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__AxisInfo(soap, "ns2:AxisInfo", &(a->ns2__AxesInfo::AxisInfo), "ns2:AxisInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AxesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AxesInfo, 0, sizeof(ns2__AxesInfo), 0, soap_copy_ns2__AxesInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AxesInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AxesInfo);
	if (this->soap_out(soap, tag?tag:"ns2:AxesInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AxesInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AxesInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AxesInfo * SOAP_FMAC4 soap_get_ns2__AxesInfo(struct soap *soap, ns2__AxesInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AxesInfo * SOAP_FMAC2 soap_instantiate_ns2__AxesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AxesInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AxesInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AxesInfo);
		if (size)
			*size = sizeof(ns2__AxesInfo);
		((ns2__AxesInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__AxesInfo, n);
		if (size)
			*size = n * sizeof(ns2__AxesInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__AxesInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__AxesInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AxesInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AxesInfo %p -> %p\n", q, p));
	*(ns2__AxesInfo*)p = *(ns2__AxesInfo*)q;
}

void ns2__Cube::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Cube::CubeName = NULL;
	/* transient soap skipped */
}

void ns2__Cube::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__Cube::CubeName);
	/* transient soap skipped */
#endif
}

int ns2__Cube::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Cube(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Cube(struct soap *soap, const char *tag, int id, const ns2__Cube *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Cube), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:CubeName", -1, &(a->ns2__Cube::CubeName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Cube::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Cube(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Cube * SOAP_FMAC4 soap_in_ns2__Cube(struct soap *soap, const char *tag, ns2__Cube *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Cube *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Cube, sizeof(ns2__Cube), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Cube)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Cube *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:CubeName", &(a->ns2__Cube::CubeName), "xsd:string"))
				{	soap_flag_CubeName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Cube *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Cube, 0, sizeof(ns2__Cube), 0, soap_copy_ns2__Cube);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Cube::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Cube);
	if (this->soap_out(soap, tag?tag:"ns2:Cube", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Cube::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Cube(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Cube * SOAP_FMAC4 soap_get_ns2__Cube(struct soap *soap, ns2__Cube *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Cube * SOAP_FMAC2 soap_instantiate_ns2__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Cube);
		if (size)
			*size = sizeof(ns2__Cube);
		((ns2__Cube*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Cube, n);
		if (size)
			*size = n * sizeof(ns2__Cube);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Cube*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Cube*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Cube %p -> %p\n", q, p));
	*(ns2__Cube*)p = *(ns2__Cube*)q;
}

void ns2__CubeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Cube(soap, &this->ns2__CubeInfo::Cube);
	/* transient soap skipped */
}

void ns2__CubeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Cube(soap, &this->ns2__CubeInfo::Cube);
	/* transient soap skipped */
#endif
}

int ns2__CubeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CubeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CubeInfo(struct soap *soap, const char *tag, int id, const ns2__CubeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CubeInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Cube(soap, "ns2:Cube", -1, &(a->ns2__CubeInfo::Cube), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CubeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CubeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CubeInfo * SOAP_FMAC4 soap_in_ns2__CubeInfo(struct soap *soap, const char *tag, ns2__CubeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CubeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CubeInfo, sizeof(ns2__CubeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CubeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CubeInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Cube(soap, "ns2:Cube", &(a->ns2__CubeInfo::Cube), "ns2:Cube"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CubeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CubeInfo, 0, sizeof(ns2__CubeInfo), 0, soap_copy_ns2__CubeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CubeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CubeInfo);
	if (this->soap_out(soap, tag?tag:"ns2:CubeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CubeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CubeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CubeInfo * SOAP_FMAC4 soap_get_ns2__CubeInfo(struct soap *soap, ns2__CubeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CubeInfo * SOAP_FMAC2 soap_instantiate_ns2__CubeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CubeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CubeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CubeInfo);
		if (size)
			*size = sizeof(ns2__CubeInfo);
		((ns2__CubeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CubeInfo, n);
		if (size)
			*size = n * sizeof(ns2__CubeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__CubeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__CubeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CubeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CubeInfo %p -> %p\n", q, p));
	*(ns2__CubeInfo*)p = *(ns2__CubeInfo*)q;
}

void ns2__OlapInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OlapInfo::CubeInfo = NULL;
	this->ns2__OlapInfo::AxesInfo = NULL;
	this->ns2__OlapInfo::CellInfo = NULL;
	/* transient soap skipped */
}

void ns2__OlapInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CubeInfo(soap, &this->ns2__OlapInfo::CubeInfo);
	soap_serialize_PointerTons2__AxesInfo(soap, &this->ns2__OlapInfo::AxesInfo);
	soap_serialize_PointerTons2__CellInfo(soap, &this->ns2__OlapInfo::CellInfo);
	/* transient soap skipped */
#endif
}

int ns2__OlapInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OlapInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OlapInfo(struct soap *soap, const char *tag, int id, const ns2__OlapInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OlapInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__CubeInfo(soap, "ns2:CubeInfo", -1, &(a->ns2__OlapInfo::CubeInfo), ""))
		return soap->error;
	if (soap_out_PointerTons2__AxesInfo(soap, "ns2:AxesInfo", -1, &(a->ns2__OlapInfo::AxesInfo), ""))
		return soap->error;
	if (soap_out_PointerTons2__CellInfo(soap, "ns2:CellInfo", -1, &(a->ns2__OlapInfo::CellInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OlapInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OlapInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OlapInfo * SOAP_FMAC4 soap_in_ns2__OlapInfo(struct soap *soap, const char *tag, ns2__OlapInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OlapInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OlapInfo, sizeof(ns2__OlapInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OlapInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OlapInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CubeInfo1 = 1;
	size_t soap_flag_AxesInfo1 = 1;
	size_t soap_flag_CellInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CubeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CubeInfo(soap, "ns2:CubeInfo", &(a->ns2__OlapInfo::CubeInfo), "ns2:CubeInfo"))
				{	soap_flag_CubeInfo1--;
					continue;
				}
			if (soap_flag_AxesInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AxesInfo(soap, "ns2:AxesInfo", &(a->ns2__OlapInfo::AxesInfo), "ns2:AxesInfo"))
				{	soap_flag_AxesInfo1--;
					continue;
				}
			if (soap_flag_CellInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CellInfo(soap, "ns2:CellInfo", &(a->ns2__OlapInfo::CellInfo), "ns2:CellInfo"))
				{	soap_flag_CellInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OlapInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OlapInfo, 0, sizeof(ns2__OlapInfo), 0, soap_copy_ns2__OlapInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OlapInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OlapInfo);
	if (this->soap_out(soap, tag?tag:"ns2:OlapInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OlapInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OlapInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OlapInfo * SOAP_FMAC4 soap_get_ns2__OlapInfo(struct soap *soap, ns2__OlapInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OlapInfo * SOAP_FMAC2 soap_instantiate_ns2__OlapInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OlapInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OlapInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OlapInfo);
		if (size)
			*size = sizeof(ns2__OlapInfo);
		((ns2__OlapInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OlapInfo, n);
		if (size)
			*size = n * sizeof(ns2__OlapInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OlapInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OlapInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OlapInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OlapInfo %p -> %p\n", q, p));
	*(ns2__OlapInfo*)p = *(ns2__OlapInfo*)q;
}

void ns2__Row::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__Row::__any);
	/* transient soap skipped */
}

void ns2__Row::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__Row::__any);
	/* transient soap skipped */
#endif
}

int ns2__Row::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Row(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Row(struct soap *soap, const char *tag, int id, const ns2__Row *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Row), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__Row::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Row::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Row(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Row * SOAP_FMAC4 soap_in_ns2__Row(struct soap *soap, const char *tag, ns2__Row *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Row *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Row, sizeof(ns2__Row), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Row)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Row *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__Row::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Row *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Row, 0, sizeof(ns2__Row), 0, soap_copy_ns2__Row);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Row::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Row);
	if (this->soap_out(soap, tag?tag:"ns2:Row", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Row::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Row(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Row * SOAP_FMAC4 soap_get_ns2__Row(struct soap *soap, ns2__Row *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Row(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Row * SOAP_FMAC2 soap_instantiate_ns2__Row(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Row(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Row, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Row);
		if (size)
			*size = sizeof(ns2__Row);
		((ns2__Row*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Row, n);
		if (size)
			*size = n * sizeof(ns2__Row);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Row*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Row*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Row(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Row %p -> %p\n", q, p));
	*(ns2__Row*)p = *(ns2__Row*)q;
}

void ns2__Members::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Member(soap, &this->ns2__Members::Member);
	this->ns2__Members::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns2__Members::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Member(soap, &this->ns2__Members::Member);
	/* transient soap skipped */
#endif
}

int ns2__Members::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Members(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Members(struct soap *soap, const char *tag, int id, const ns2__Members *a, const char *type)
{
	if (((ns2__Members*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns2__Members*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Members), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Member(soap, "ns2:Member", -1, &(a->ns2__Members::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Members::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Members(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Members * SOAP_FMAC4 soap_in_ns2__Members(struct soap *soap, const char *tag, ns2__Members *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Members *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Members, sizeof(ns2__Members), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Members)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Members *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__Members*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns2__Members*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Member(soap, "ns2:Member", &(a->ns2__Members::Member), "ns2:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Members *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Members, 0, sizeof(ns2__Members), 0, soap_copy_ns2__Members);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Members::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Members);
	if (this->soap_out(soap, tag?tag:"ns2:Members", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Members::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Members(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Members * SOAP_FMAC4 soap_get_ns2__Members(struct soap *soap, ns2__Members *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Members * SOAP_FMAC2 soap_instantiate_ns2__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Members);
		if (size)
			*size = sizeof(ns2__Members);
		((ns2__Members*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Members, n);
		if (size)
			*size = n * sizeof(ns2__Members);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Members*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Members*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Members %p -> %p\n", q, p));
	*(ns2__Members*)p = *(ns2__Members*)q;
}

void ns2__CrossProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Members(soap, &this->ns2__CrossProduct::Members);
	soap_default_int(soap, &this->ns2__CrossProduct::Size);
	/* transient soap skipped */
}

void ns2__CrossProduct::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Members(soap, &this->ns2__CrossProduct::Members);
	/* transient soap skipped */
#endif
}

int ns2__CrossProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CrossProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CrossProduct(struct soap *soap, const char *tag, int id, const ns2__CrossProduct *a, const char *type)
{
	soap_set_attr(soap, "Size", soap_int2s(soap, ((ns2__CrossProduct*)a)->Size), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CrossProduct), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Members(soap, "ns2:Members", -1, &(a->ns2__CrossProduct::Members), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CrossProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CrossProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CrossProduct * SOAP_FMAC4 soap_in_ns2__CrossProduct(struct soap *soap, const char *tag, ns2__CrossProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CrossProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CrossProduct, sizeof(ns2__CrossProduct), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CrossProduct)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CrossProduct *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Size", 1), &((ns2__CrossProduct*)a)->Size))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Members(soap, "ns2:Members", &(a->ns2__CrossProduct::Members), "ns2:Members"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CrossProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CrossProduct, 0, sizeof(ns2__CrossProduct), 0, soap_copy_ns2__CrossProduct);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CrossProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CrossProduct);
	if (this->soap_out(soap, tag?tag:"ns2:CrossProduct", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CrossProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CrossProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CrossProduct * SOAP_FMAC4 soap_get_ns2__CrossProduct(struct soap *soap, ns2__CrossProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CrossProduct * SOAP_FMAC2 soap_instantiate_ns2__CrossProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CrossProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CrossProduct, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CrossProduct);
		if (size)
			*size = sizeof(ns2__CrossProduct);
		((ns2__CrossProduct*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CrossProduct, n);
		if (size)
			*size = n * sizeof(ns2__CrossProduct);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__CrossProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__CrossProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CrossProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CrossProduct %p -> %p\n", q, p));
	*(ns2__CrossProduct*)p = *(ns2__CrossProduct*)q;
}

void ns2__Member::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Member::UName = NULL;
	this->ns2__Member::Caption = NULL;
	this->ns2__Member::LName = NULL;
	this->ns2__Member::LNum = NULL;
	this->ns2__Member::DisplayInfo = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__Member::__any);
	this->ns2__Member::Hierarchy = NULL;
	/* transient soap skipped */
}

void ns2__Member::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__Member::UName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__Member::Caption);
	soap_serialize_PointerTostd__string(soap, &this->ns2__Member::LName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__Member::LNum);
	soap_serialize_PointerTostd__string(soap, &this->ns2__Member::DisplayInfo);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__Member::__any);
	/* transient soap skipped */
#endif
}

int ns2__Member::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Member(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Member(struct soap *soap, const char *tag, int id, const ns2__Member *a, const char *type)
{
	if (((ns2__Member*)a)->Hierarchy)
		soap_set_attr(soap, "Hierarchy", ((ns2__Member*)a)->Hierarchy->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Member), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:UName", -1, &(a->ns2__Member::UName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Caption", -1, &(a->ns2__Member::Caption), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:LName", -1, &(a->ns2__Member::LName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:LNum", -1, &(a->ns2__Member::LNum), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:DisplayInfo", -1, &(a->ns2__Member::DisplayInfo), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__Member::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Member::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Member(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Member * SOAP_FMAC4 soap_in_ns2__Member(struct soap *soap, const char *tag, ns2__Member *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Member *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Member, sizeof(ns2__Member), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Member)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Member *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Hierarchy", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__Member*)a)->Hierarchy = soap_new_std__string(soap, -1);
				((ns2__Member*)a)->Hierarchy->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_UName1 = 1;
	size_t soap_flag_Caption1 = 1;
	size_t soap_flag_LName1 = 1;
	size_t soap_flag_LNum1 = 1;
	size_t soap_flag_DisplayInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:UName", &(a->ns2__Member::UName), "xsd:string"))
				{	soap_flag_UName1--;
					continue;
				}
			if (soap_flag_Caption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Caption", &(a->ns2__Member::Caption), "xsd:string"))
				{	soap_flag_Caption1--;
					continue;
				}
			if (soap_flag_LName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:LName", &(a->ns2__Member::LName), "xsd:string"))
				{	soap_flag_LName1--;
					continue;
				}
			if (soap_flag_LNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:LNum", &(a->ns2__Member::LNum), "xsd:string"))
				{	soap_flag_LNum1--;
					continue;
				}
			if (soap_flag_DisplayInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:DisplayInfo", &(a->ns2__Member::DisplayInfo), "xsd:string"))
				{	soap_flag_DisplayInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__Member::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Member *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Member, 0, sizeof(ns2__Member), 0, soap_copy_ns2__Member);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Member::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Member);
	if (this->soap_out(soap, tag?tag:"ns2:Member", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Member::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Member(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Member * SOAP_FMAC4 soap_get_ns2__Member(struct soap *soap, ns2__Member *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Member * SOAP_FMAC2 soap_instantiate_ns2__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Member);
		if (size)
			*size = sizeof(ns2__Member);
		((ns2__Member*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Member, n);
		if (size)
			*size = n * sizeof(ns2__Member);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Member*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Member*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Member %p -> %p\n", q, p));
	*(ns2__Member*)p = *(ns2__Member*)q;
}

void ns2__Tuple::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Member(soap, &this->ns2__Tuple::Member);
	/* transient soap skipped */
}

void ns2__Tuple::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Member(soap, &this->ns2__Tuple::Member);
	/* transient soap skipped */
#endif
}

int ns2__Tuple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Tuple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Tuple(struct soap *soap, const char *tag, int id, const ns2__Tuple *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Tuple), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Member(soap, "ns2:Member", -1, &(a->ns2__Tuple::Member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Tuple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Tuple(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Tuple * SOAP_FMAC4 soap_in_ns2__Tuple(struct soap *soap, const char *tag, ns2__Tuple *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Tuple *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Tuple, sizeof(ns2__Tuple), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Tuple)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Tuple *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Member(soap, "ns2:Member", &(a->ns2__Tuple::Member), "ns2:Member"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Tuple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Tuple, 0, sizeof(ns2__Tuple), 0, soap_copy_ns2__Tuple);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Tuple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Tuple);
	if (this->soap_out(soap, tag?tag:"ns2:Tuple", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Tuple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Tuple(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Tuple * SOAP_FMAC4 soap_get_ns2__Tuple(struct soap *soap, ns2__Tuple *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Tuple * SOAP_FMAC2 soap_instantiate_ns2__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Tuple);
		if (size)
			*size = sizeof(ns2__Tuple);
		((ns2__Tuple*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Tuple, n);
		if (size)
			*size = n * sizeof(ns2__Tuple);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Tuple*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Tuple*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Tuple %p -> %p\n", q, p));
	*(ns2__Tuple*)p = *(ns2__Tuple*)q;
}

void ns2__Tuples::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Tuple(soap, &this->ns2__Tuples::Tuple);
	/* transient soap skipped */
}

void ns2__Tuples::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Tuple(soap, &this->ns2__Tuples::Tuple);
	/* transient soap skipped */
#endif
}

int ns2__Tuples::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Tuples(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Tuples(struct soap *soap, const char *tag, int id, const ns2__Tuples *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Tuples), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Tuple(soap, "ns2:Tuple", -1, &(a->ns2__Tuples::Tuple), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Tuples::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Tuples(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Tuples * SOAP_FMAC4 soap_in_ns2__Tuples(struct soap *soap, const char *tag, ns2__Tuples *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Tuples *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Tuples, sizeof(ns2__Tuples), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Tuples)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Tuples *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Tuple(soap, "ns2:Tuple", &(a->ns2__Tuples::Tuple), "ns2:Tuple"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Tuples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Tuples, 0, sizeof(ns2__Tuples), 0, soap_copy_ns2__Tuples);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Tuples::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Tuples);
	if (this->soap_out(soap, tag?tag:"ns2:Tuples", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Tuples::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Tuples(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Tuples * SOAP_FMAC4 soap_get_ns2__Tuples(struct soap *soap, ns2__Tuples *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Tuples * SOAP_FMAC2 soap_instantiate_ns2__Tuples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Tuples(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Tuples, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Tuples);
		if (size)
			*size = sizeof(ns2__Tuples);
		((ns2__Tuples*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Tuples, n);
		if (size)
			*size = n * sizeof(ns2__Tuples);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Tuples*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Tuples*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Tuples(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Tuples %p -> %p\n", q, p));
	*(ns2__Tuples*)p = *(ns2__Tuples*)q;
}

void ns2__Axis::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Axis::__size_Axis = 0;
	this->ns2__Axis::__union_Axis = NULL;
	this->ns2__Axis::name = NULL;
	/* transient soap skipped */
}

void ns2__Axis::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < this->ns2__Axis::__size_Axis; i++)
		{
			this->ns2__Axis::__union_Axis[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns2__Axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Axis(struct soap *soap, const char *tag, int id, const ns2__Axis *a, const char *type)
{
	if (((ns2__Axis*)a)->name)
		soap_set_attr(soap, "name", ((ns2__Axis*)a)->name->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Axis), type))
		return soap->error;
	if (a->ns2__Axis::__union_Axis)
	{	int i;
		for (i = 0; i < a->ns2__Axis::__size_Axis; i++)
			if (a->ns2__Axis::__union_Axis[i].soap_out(soap, "-union-Axis", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Axis(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Axis * SOAP_FMAC4 soap_in_ns2__Axis(struct soap *soap, const char *tag, ns2__Axis *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Axis *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Axis, sizeof(ns2__Axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Axis)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Axis *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__Axis*)a)->name = soap_new_std__string(soap, -1);
				((ns2__Axis*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_Axis1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__Axis::__union_Axis == NULL)
				{	if (soap_blist___union_Axis1 == NULL)
						soap_blist___union_Axis1 = soap_new_block(soap);
					a->ns2__Axis::__union_Axis = (__ns2__union_Axis *)soap_push_block(soap, soap_blist___union_Axis1, sizeof(__ns2__union_Axis));
					if (a->ns2__Axis::__union_Axis == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns2__Axis::__union_Axis, __ns2__union_Axis);
					a->ns2__Axis::__union_Axis->soap_default(soap);
				}
				if (soap_in___ns2__union_Axis(soap, "-union-Axis", a->ns2__Axis::__union_Axis, "-ns2:union-Axis"))
				{	a->ns2__Axis::__size_Axis++;
					a->ns2__Axis::__union_Axis = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__Axis::__union_Axis)
			soap_pop_block(soap, soap_blist___union_Axis1);
		if (a->ns2__Axis::__size_Axis)
			a->ns2__Axis::__union_Axis = (__ns2__union_Axis *)soap_save_block(soap, soap_blist___union_Axis1, NULL, 1);
		else
		{	a->ns2__Axis::__union_Axis = NULL;
			if (soap_blist___union_Axis1)
				soap_end_block(soap, soap_blist___union_Axis1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Axis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Axis, 0, sizeof(ns2__Axis), 0, soap_copy_ns2__Axis);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Axis);
	if (this->soap_out(soap, tag?tag:"ns2:Axis", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Axis(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Axis * SOAP_FMAC4 soap_get_ns2__Axis(struct soap *soap, ns2__Axis *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Axis * SOAP_FMAC2 soap_instantiate_ns2__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Axis);
		if (size)
			*size = sizeof(ns2__Axis);
		((ns2__Axis*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Axis, n);
		if (size)
			*size = n * sizeof(ns2__Axis);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Axis*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Axis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Axis %p -> %p\n", q, p));
	*(ns2__Axis*)p = *(ns2__Axis*)q;
}

void ns2__Axes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Axis(soap, &this->ns2__Axes::Axis);
	/* transient soap skipped */
}

void ns2__Axes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Axis(soap, &this->ns2__Axes::Axis);
	/* transient soap skipped */
#endif
}

int ns2__Axes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Axes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Axes(struct soap *soap, const char *tag, int id, const ns2__Axes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Axes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Axis(soap, "ns2:Axis", -1, &(a->ns2__Axes::Axis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Axes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Axes(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Axes * SOAP_FMAC4 soap_in_ns2__Axes(struct soap *soap, const char *tag, ns2__Axes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Axes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Axes, sizeof(ns2__Axes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Axes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Axes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Axis(soap, "ns2:Axis", &(a->ns2__Axes::Axis), "ns2:Axis"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Axes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Axes, 0, sizeof(ns2__Axes), 0, soap_copy_ns2__Axes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Axes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Axes);
	if (this->soap_out(soap, tag?tag:"ns2:Axes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Axes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Axes(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Axes * SOAP_FMAC4 soap_get_ns2__Axes(struct soap *soap, ns2__Axes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Axes * SOAP_FMAC2 soap_instantiate_ns2__Axes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Axes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Axes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Axes);
		if (size)
			*size = sizeof(ns2__Axes);
		((ns2__Axes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Axes, n);
		if (size)
			*size = n * sizeof(ns2__Axes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Axes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Axes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Axes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Axes %p -> %p\n", q, p));
	*(ns2__Axes*)p = *(ns2__Axes*)q;
}

void ns2__Cell::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Cell::Value = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__Cell::__any);
	soap_default_int(soap, &this->ns2__Cell::CellOrdinal);
	/* transient soap skipped */
}

void ns2__Cell::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns2__Cell::Value);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__Cell::__any);
	/* transient soap skipped */
#endif
}

int ns2__Cell::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Cell(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Cell(struct soap *soap, const char *tag, int id, const ns2__Cell *a, const char *type)
{
	soap_set_attr(soap, "CellOrdinal", soap_int2s(soap, ((ns2__Cell*)a)->CellOrdinal), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Cell), type))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns2:Value", -1, &(a->ns2__Cell::Value), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__Cell::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Cell::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Cell(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Cell * SOAP_FMAC4 soap_in_ns2__Cell(struct soap *soap, const char *tag, ns2__Cell *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Cell *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Cell, sizeof(ns2__Cell), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Cell)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Cell *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "CellOrdinal", 1), &((ns2__Cell*)a)->CellOrdinal))
		return NULL;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns2:Value", &(a->ns2__Cell::Value), "xsd:double"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__Cell::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Cell *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Cell, 0, sizeof(ns2__Cell), 0, soap_copy_ns2__Cell);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Cell::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Cell);
	if (this->soap_out(soap, tag?tag:"ns2:Cell", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Cell::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Cell(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Cell * SOAP_FMAC4 soap_get_ns2__Cell(struct soap *soap, ns2__Cell *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Cell * SOAP_FMAC2 soap_instantiate_ns2__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Cell);
		if (size)
			*size = sizeof(ns2__Cell);
		((ns2__Cell*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Cell, n);
		if (size)
			*size = n * sizeof(ns2__Cell);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Cell*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Cell*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Cell %p -> %p\n", q, p));
	*(ns2__Cell*)p = *(ns2__Cell*)q;
}

void ns2__CellData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Cell(soap, &this->ns2__CellData::Cell);
	/* transient soap skipped */
}

void ns2__CellData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Cell(soap, &this->ns2__CellData::Cell);
	/* transient soap skipped */
#endif
}

int ns2__CellData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CellData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CellData(struct soap *soap, const char *tag, int id, const ns2__CellData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CellData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Cell(soap, "ns2:Cell", -1, &(a->ns2__CellData::Cell), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CellData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CellData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CellData * SOAP_FMAC4 soap_in_ns2__CellData(struct soap *soap, const char *tag, ns2__CellData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CellData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CellData, sizeof(ns2__CellData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CellData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CellData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Cell(soap, "ns2:Cell", &(a->ns2__CellData::Cell), "ns2:Cell"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CellData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CellData, 0, sizeof(ns2__CellData), 0, soap_copy_ns2__CellData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CellData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CellData);
	if (this->soap_out(soap, tag?tag:"ns2:CellData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CellData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CellData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CellData * SOAP_FMAC4 soap_get_ns2__CellData(struct soap *soap, ns2__CellData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CellData * SOAP_FMAC2 soap_instantiate_ns2__CellData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CellData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CellData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CellData);
		if (size)
			*size = sizeof(ns2__CellData);
		((ns2__CellData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CellData, n);
		if (size)
			*size = n * sizeof(ns2__CellData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__CellData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__CellData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CellData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CellData %p -> %p\n", q, p));
	*(ns2__CellData*)p = *(ns2__CellData*)q;
}

void ns2__ResultXmlRoot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xsd__schema(soap, &this->ns2__ResultXmlRoot::xsd__schema);
	this->ns2__ResultXmlRoot::__size_ResultXmlRoot = 0;
	this->ns2__ResultXmlRoot::__union_ResultXmlRoot = NULL;
	/* transient soap skipped */
}

void ns2__ResultXmlRoot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__xsd__schema(soap, &this->ns2__ResultXmlRoot::xsd__schema);
	if (this->ns2__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < this->ns2__ResultXmlRoot::__size_ResultXmlRoot; i++)
		{
			this->ns2__ResultXmlRoot::__union_ResultXmlRoot[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
#endif
}

int ns2__ResultXmlRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResultXmlRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResultXmlRoot(struct soap *soap, const char *tag, int id, const ns2__ResultXmlRoot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResultXmlRoot), type))
		return soap->error;
	if (soap_out__xsd__schema(soap, "xsd:schema", -1, &(a->ns2__ResultXmlRoot::xsd__schema), ""))
		return soap->error;
	if (a->ns2__ResultXmlRoot::__union_ResultXmlRoot)
	{	int i;
		for (i = 0; i < a->ns2__ResultXmlRoot::__size_ResultXmlRoot; i++)
			if (a->ns2__ResultXmlRoot::__union_ResultXmlRoot[i].soap_out(soap, "-union-ResultXmlRoot", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ResultXmlRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResultXmlRoot(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResultXmlRoot * SOAP_FMAC4 soap_in_ns2__ResultXmlRoot(struct soap *soap, const char *tag, ns2__ResultXmlRoot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResultXmlRoot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResultXmlRoot, sizeof(ns2__ResultXmlRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ResultXmlRoot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ResultXmlRoot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xsd__schema1 = 1;
	struct soap_blist *soap_blist___union_ResultXmlRoot1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__xsd__schema(soap, "xsd:schema", &(a->ns2__ResultXmlRoot::xsd__schema), ""))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__ResultXmlRoot::__union_ResultXmlRoot == NULL)
				{	if (soap_blist___union_ResultXmlRoot1 == NULL)
						soap_blist___union_ResultXmlRoot1 = soap_new_block(soap);
					a->ns2__ResultXmlRoot::__union_ResultXmlRoot = (__ns2__union_ResultXmlRoot *)soap_push_block(soap, soap_blist___union_ResultXmlRoot1, sizeof(__ns2__union_ResultXmlRoot));
					if (a->ns2__ResultXmlRoot::__union_ResultXmlRoot == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns2__ResultXmlRoot::__union_ResultXmlRoot, __ns2__union_ResultXmlRoot);
					a->ns2__ResultXmlRoot::__union_ResultXmlRoot->soap_default(soap);
				}
				if (soap_in___ns2__union_ResultXmlRoot(soap, "-union-ResultXmlRoot", a->ns2__ResultXmlRoot::__union_ResultXmlRoot, "-ns2:union-ResultXmlRoot"))
				{	a->ns2__ResultXmlRoot::__size_ResultXmlRoot++;
					a->ns2__ResultXmlRoot::__union_ResultXmlRoot = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__ResultXmlRoot::__union_ResultXmlRoot)
			soap_pop_block(soap, soap_blist___union_ResultXmlRoot1);
		if (a->ns2__ResultXmlRoot::__size_ResultXmlRoot)
			a->ns2__ResultXmlRoot::__union_ResultXmlRoot = (__ns2__union_ResultXmlRoot *)soap_save_block(soap, soap_blist___union_ResultXmlRoot1, NULL, 1);
		else
		{	a->ns2__ResultXmlRoot::__union_ResultXmlRoot = NULL;
			if (soap_blist___union_ResultXmlRoot1)
				soap_end_block(soap, soap_blist___union_ResultXmlRoot1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ResultXmlRoot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResultXmlRoot, 0, sizeof(ns2__ResultXmlRoot), 0, soap_copy_ns2__ResultXmlRoot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ResultXmlRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ResultXmlRoot);
	if (this->soap_out(soap, tag?tag:"ns2:ResultXmlRoot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResultXmlRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResultXmlRoot(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResultXmlRoot * SOAP_FMAC4 soap_get_ns2__ResultXmlRoot(struct soap *soap, ns2__ResultXmlRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ResultXmlRoot * SOAP_FMAC2 soap_instantiate_ns2__ResultXmlRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ResultXmlRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ResultXmlRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ResultXmlRoot);
		if (size)
			*size = sizeof(ns2__ResultXmlRoot);
		((ns2__ResultXmlRoot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ResultXmlRoot, n);
		if (size)
			*size = n * sizeof(ns2__ResultXmlRoot);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ResultXmlRoot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ResultXmlRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ResultXmlRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ResultXmlRoot %p -> %p\n", q, p));
	*(ns2__ResultXmlRoot*)p = *(ns2__ResultXmlRoot*)q;
}

void _ns1__DiscoverResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DiscoverResponse::return_ = NULL;
	this->_ns1__DiscoverResponse::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _ns1__DiscoverResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ResultSet(soap, &this->_ns1__DiscoverResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1__DiscoverResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DiscoverResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DiscoverResponse(struct soap *soap, const char *tag, int id, const _ns1__DiscoverResponse *a, const char *type)
{
	if (((_ns1__DiscoverResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_ns1__DiscoverResponse*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DiscoverResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (a->_ns1__DiscoverResponse::return_)
	{	if (soap_out_PointerTons1__ResultSet(soap, "ns1:return", -1, &a->_ns1__DiscoverResponse::return_, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:return"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DiscoverResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DiscoverResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DiscoverResponse * SOAP_FMAC4 soap_in__ns1__DiscoverResponse(struct soap *soap, const char *tag, _ns1__DiscoverResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DiscoverResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DiscoverResponse, sizeof(_ns1__DiscoverResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DiscoverResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DiscoverResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((_ns1__DiscoverResponse*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ResultSet(soap, "ns1:return", &(a->_ns1__DiscoverResponse::return_), "ns1:ResultSet"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DiscoverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DiscoverResponse, 0, sizeof(_ns1__DiscoverResponse), 0, soap_copy__ns1__DiscoverResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__DiscoverResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DiscoverResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DiscoverResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DiscoverResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DiscoverResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DiscoverResponse * SOAP_FMAC4 soap_get__ns1__DiscoverResponse(struct soap *soap, _ns1__DiscoverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DiscoverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DiscoverResponse * SOAP_FMAC2 soap_instantiate__ns1__DiscoverResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DiscoverResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DiscoverResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DiscoverResponse);
		if (size)
			*size = sizeof(_ns1__DiscoverResponse);
		((_ns1__DiscoverResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__DiscoverResponse, n);
		if (size)
			*size = n * sizeof(_ns1__DiscoverResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__DiscoverResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__DiscoverResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DiscoverResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DiscoverResponse %p -> %p\n", q, p));
	*(_ns1__DiscoverResponse*)p = *(_ns1__DiscoverResponse*)q;
}

void _ns1__Discover::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Discover::RequestType = NULL;
	this->_ns1__Discover::Restrictions = NULL;
	this->_ns1__Discover::Properties = NULL;
	this->_ns1__Discover::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _ns1__Discover::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Discover::RequestType);
	soap_serialize_PointerTons1__Restrictions(soap, &this->_ns1__Discover::Restrictions);
	soap_serialize_PointerTons1__Properties(soap, &this->_ns1__Discover::Properties);
	/* transient soap skipped */
#endif
}

int _ns1__Discover::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Discover(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Discover(struct soap *soap, const char *tag, int id, const _ns1__Discover *a, const char *type)
{
	if (((_ns1__Discover*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_ns1__Discover*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Discover), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:RequestType", -1, &(a->_ns1__Discover::RequestType), ""))
		return soap->error;
	if (a->_ns1__Discover::Restrictions)
	{	if (soap_out_PointerTons1__Restrictions(soap, "ns1:Restrictions", -1, &a->_ns1__Discover::Restrictions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Restrictions"))
		return soap->error;
	if (a->_ns1__Discover::Properties)
	{	if (soap_out_PointerTons1__Properties(soap, "ns1:Properties", -1, &a->_ns1__Discover::Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Properties"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Discover::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Discover(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Discover * SOAP_FMAC4 soap_in__ns1__Discover(struct soap *soap, const char *tag, _ns1__Discover *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Discover *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Discover, sizeof(_ns1__Discover), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Discover)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Discover *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((_ns1__Discover*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_RequestType1 = 1;
	size_t soap_flag_Restrictions1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:RequestType", &(a->_ns1__Discover::RequestType), "xsd:string"))
				{	soap_flag_RequestType1--;
					continue;
				}
			if (soap_flag_Restrictions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Restrictions(soap, "ns1:Restrictions", &(a->_ns1__Discover::Restrictions), "ns1:Restrictions"))
				{	soap_flag_Restrictions1--;
					continue;
				}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Properties(soap, "ns1:Properties", &(a->_ns1__Discover::Properties), "ns1:Properties"))
				{	soap_flag_Properties1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Discover *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Discover, 0, sizeof(_ns1__Discover), 0, soap_copy__ns1__Discover);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Restrictions1 > 0 || soap_flag_Properties1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__Discover::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Discover);
	if (this->soap_out(soap, tag?tag:"ns1:Discover", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Discover::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Discover(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Discover * SOAP_FMAC4 soap_get__ns1__Discover(struct soap *soap, _ns1__Discover *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Discover(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__Discover * SOAP_FMAC2 soap_instantiate__ns1__Discover(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Discover(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Discover, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__Discover);
		if (size)
			*size = sizeof(_ns1__Discover);
		((_ns1__Discover*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__Discover, n);
		if (size)
			*size = n * sizeof(_ns1__Discover);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__Discover*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__Discover*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Discover(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Discover %p -> %p\n", q, p));
	*(_ns1__Discover*)p = *(_ns1__Discover*)q;
}

void _ns1__ExecuteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExecuteResponse::return_ = NULL;
	this->_ns1__ExecuteResponse::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _ns1__ExecuteResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ResultSet(soap, &this->_ns1__ExecuteResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1__ExecuteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteResponse *a, const char *type)
{
	if (((_ns1__ExecuteResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_ns1__ExecuteResponse*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (a->_ns1__ExecuteResponse::return_)
	{	if (soap_out_PointerTons1__ResultSet(soap, "ns1:return", -1, &a->_ns1__ExecuteResponse::return_, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:return"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteResponse * SOAP_FMAC4 soap_in__ns1__ExecuteResponse(struct soap *soap, const char *tag, _ns1__ExecuteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteResponse, sizeof(_ns1__ExecuteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ExecuteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ExecuteResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((_ns1__ExecuteResponse*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ResultSet(soap, "ns1:return", &(a->_ns1__ExecuteResponse::return_), "ns1:ResultSet"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExecuteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteResponse, 0, sizeof(_ns1__ExecuteResponse), 0, soap_copy__ns1__ExecuteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__ExecuteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ExecuteResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ExecuteResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteResponse * SOAP_FMAC4 soap_get__ns1__ExecuteResponse(struct soap *soap, _ns1__ExecuteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__ExecuteResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ExecuteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ExecuteResponse);
		if (size)
			*size = sizeof(_ns1__ExecuteResponse);
		((_ns1__ExecuteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__ExecuteResponse, n);
		if (size)
			*size = n * sizeof(_ns1__ExecuteResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__ExecuteResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__ExecuteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ExecuteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ExecuteResponse %p -> %p\n", q, p));
	*(_ns1__ExecuteResponse*)p = *(_ns1__ExecuteResponse*)q;
}

void _ns1__Execute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Execute::Command = NULL;
	this->_ns1__Execute::Properties = NULL;
	this->_ns1__Execute::Parameters = NULL;
	this->_ns1__Execute::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _ns1__Execute::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CommandStatement(soap, &this->_ns1__Execute::Command);
	soap_serialize_PointerTons1__Properties(soap, &this->_ns1__Execute::Properties);
	soap_serialize_PointerTons1__Parameters(soap, &this->_ns1__Execute::Parameters);
	/* transient soap skipped */
#endif
}

int _ns1__Execute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Execute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Execute(struct soap *soap, const char *tag, int id, const _ns1__Execute *a, const char *type)
{
	if (((_ns1__Execute*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_ns1__Execute*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Execute), type))
		return soap->error;
	if (a->_ns1__Execute::Command)
	{	if (soap_out_PointerTons1__CommandStatement(soap, "ns1:Command", -1, &a->_ns1__Execute::Command, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Command"))
		return soap->error;
	if (a->_ns1__Execute::Properties)
	{	if (soap_out_PointerTons1__Properties(soap, "ns1:Properties", -1, &a->_ns1__Execute::Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Properties"))
		return soap->error;
	if (soap_out_PointerTons1__Parameters(soap, "ns1:Parameters", -1, &(a->_ns1__Execute::Parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Execute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Execute(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Execute * SOAP_FMAC4 soap_in__ns1__Execute(struct soap *soap, const char *tag, _ns1__Execute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Execute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Execute, sizeof(_ns1__Execute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Execute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Execute *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((_ns1__Execute*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_Command1 = 1;
	size_t soap_flag_Properties1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Command1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CommandStatement(soap, "ns1:Command", &(a->_ns1__Execute::Command), "ns1:CommandStatement"))
				{	soap_flag_Command1--;
					continue;
				}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Properties(soap, "ns1:Properties", &(a->_ns1__Execute::Properties), "ns1:Properties"))
				{	soap_flag_Properties1--;
					continue;
				}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Parameters(soap, "ns1:Parameters", &(a->_ns1__Execute::Parameters), "ns1:Parameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Execute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Execute, 0, sizeof(_ns1__Execute), 0, soap_copy__ns1__Execute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Command1 > 0 || soap_flag_Properties1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__Execute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Execute);
	if (this->soap_out(soap, tag?tag:"ns1:Execute", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Execute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Execute(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Execute * SOAP_FMAC4 soap_get__ns1__Execute(struct soap *soap, _ns1__Execute *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__Execute * SOAP_FMAC2 soap_instantiate__ns1__Execute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Execute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Execute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__Execute);
		if (size)
			*size = sizeof(_ns1__Execute);
		((_ns1__Execute*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__Execute, n);
		if (size)
			*size = n * sizeof(_ns1__Execute);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__Execute*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__Execute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Execute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Execute %p -> %p\n", q, p));
	*(_ns1__Execute*)p = *(_ns1__Execute*)q;
}

void ns1__RestrictionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__RestrictionList::__any);
	/* transient soap skipped */
}

void ns1__RestrictionList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__RestrictionList::__any);
	/* transient soap skipped */
#endif
}

int ns1__RestrictionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RestrictionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RestrictionList(struct soap *soap, const char *tag, int id, const ns1__RestrictionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RestrictionList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns1__RestrictionList::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__RestrictionList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RestrictionList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RestrictionList * SOAP_FMAC4 soap_in_ns1__RestrictionList(struct soap *soap, const char *tag, ns1__RestrictionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RestrictionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RestrictionList, sizeof(ns1__RestrictionList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RestrictionList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RestrictionList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns1__RestrictionList::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RestrictionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RestrictionList, 0, sizeof(ns1__RestrictionList), 0, soap_copy_ns1__RestrictionList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__RestrictionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RestrictionList);
	if (this->soap_out(soap, tag?tag:"ns1:RestrictionList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RestrictionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RestrictionList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RestrictionList * SOAP_FMAC4 soap_get_ns1__RestrictionList(struct soap *soap, ns1__RestrictionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RestrictionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__RestrictionList * SOAP_FMAC2 soap_instantiate_ns1__RestrictionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RestrictionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RestrictionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__RestrictionList);
		if (size)
			*size = sizeof(ns1__RestrictionList);
		((ns1__RestrictionList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__RestrictionList, n);
		if (size)
			*size = n * sizeof(ns1__RestrictionList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__RestrictionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__RestrictionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RestrictionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RestrictionList %p -> %p\n", q, p));
	*(ns1__RestrictionList*)p = *(ns1__RestrictionList*)q;
}

void ns1__Restrictions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Restrictions::RestrictionList = NULL;
	/* transient soap skipped */
}

void ns1__Restrictions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RestrictionList(soap, &this->ns1__Restrictions::RestrictionList);
	/* transient soap skipped */
#endif
}

int ns1__Restrictions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Restrictions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Restrictions(struct soap *soap, const char *tag, int id, const ns1__Restrictions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Restrictions), type))
		return soap->error;
	if (soap_out_PointerTons1__RestrictionList(soap, "ns1:RestrictionList", -1, &(a->ns1__Restrictions::RestrictionList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Restrictions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Restrictions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Restrictions * SOAP_FMAC4 soap_in_ns1__Restrictions(struct soap *soap, const char *tag, ns1__Restrictions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Restrictions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Restrictions, sizeof(ns1__Restrictions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Restrictions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Restrictions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RestrictionList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RestrictionList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RestrictionList(soap, "ns1:RestrictionList", &(a->ns1__Restrictions::RestrictionList), "ns1:RestrictionList"))
				{	soap_flag_RestrictionList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Restrictions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Restrictions, 0, sizeof(ns1__Restrictions), 0, soap_copy_ns1__Restrictions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Restrictions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Restrictions);
	if (this->soap_out(soap, tag?tag:"ns1:Restrictions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Restrictions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Restrictions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Restrictions * SOAP_FMAC4 soap_get_ns1__Restrictions(struct soap *soap, ns1__Restrictions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Restrictions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Restrictions * SOAP_FMAC2 soap_instantiate_ns1__Restrictions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Restrictions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Restrictions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Restrictions);
		if (size)
			*size = sizeof(ns1__Restrictions);
		((ns1__Restrictions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Restrictions, n);
		if (size)
			*size = n * sizeof(ns1__Restrictions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Restrictions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Restrictions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Restrictions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Restrictions %p -> %p\n", q, p));
	*(ns1__Restrictions*)p = *(ns1__Restrictions*)q;
}

void ns1__EndSession::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__EndSession::SessionId = NULL;
	this->ns1__EndSession::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns1__EndSession::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__EndSession::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EndSession(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EndSession(struct soap *soap, const char *tag, int id, const ns1__EndSession *a, const char *type)
{
	if (((ns1__EndSession*)a)->SessionId)
		soap_set_attr(soap, "SessionId", ((ns1__EndSession*)a)->SessionId->c_str(), 1);
	if (((ns1__EndSession*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns1__EndSession*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EndSession), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__EndSession::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EndSession(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EndSession * SOAP_FMAC4 soap_in_ns1__EndSession(struct soap *soap, const char *tag, ns1__EndSession *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EndSession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EndSession, sizeof(ns1__EndSession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EndSession)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EndSession *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "SessionId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns1__EndSession*)a)->SessionId = soap_new_std__string(soap, -1);
				((ns1__EndSession*)a)->SessionId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns1__EndSession*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EndSession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EndSession, 0, sizeof(ns1__EndSession), 0, soap_copy_ns1__EndSession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__EndSession::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EndSession);
	if (this->soap_out(soap, tag?tag:"ns1:EndSession", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EndSession::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EndSession(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EndSession * SOAP_FMAC4 soap_get_ns1__EndSession(struct soap *soap, ns1__EndSession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EndSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__EndSession * SOAP_FMAC2 soap_instantiate_ns1__EndSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EndSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EndSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__EndSession);
		if (size)
			*size = sizeof(ns1__EndSession);
		((ns1__EndSession*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__EndSession, n);
		if (size)
			*size = n * sizeof(ns1__EndSession);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__EndSession*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__EndSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EndSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EndSession %p -> %p\n", q, p));
	*(ns1__EndSession*)p = *(ns1__EndSession*)q;
}

void ns1__Session::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Session::SessionId = NULL;
	this->ns1__Session::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns1__Session::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__Session::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Session(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Session(struct soap *soap, const char *tag, int id, const ns1__Session *a, const char *type)
{
	if (((ns1__Session*)a)->SessionId)
		soap_set_attr(soap, "SessionId", ((ns1__Session*)a)->SessionId->c_str(), 1);
	if (((ns1__Session*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns1__Session*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Session), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Session::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Session(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Session * SOAP_FMAC4 soap_in_ns1__Session(struct soap *soap, const char *tag, ns1__Session *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Session *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Session, sizeof(ns1__Session), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Session)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Session *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "SessionId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns1__Session*)a)->SessionId = soap_new_std__string(soap, -1);
				((ns1__Session*)a)->SessionId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns1__Session*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Session *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Session, 0, sizeof(ns1__Session), 0, soap_copy_ns1__Session);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Session::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Session);
	if (this->soap_out(soap, tag?tag:"ns1:Session", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Session::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Session(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Session * SOAP_FMAC4 soap_get_ns1__Session(struct soap *soap, ns1__Session *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Session(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Session * SOAP_FMAC2 soap_instantiate_ns1__Session(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Session(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Session, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Session);
		if (size)
			*size = sizeof(ns1__Session);
		((ns1__Session*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Session, n);
		if (size)
			*size = n * sizeof(ns1__Session);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Session*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Session*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Session(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Session %p -> %p\n", q, p));
	*(ns1__Session*)p = *(ns1__Session*)q;
}

void ns1__BeginSession::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BeginSession::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns1__BeginSession::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__BeginSession::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BeginSession(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BeginSession(struct soap *soap, const char *tag, int id, const ns1__BeginSession *a, const char *type)
{
	if (((ns1__BeginSession*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns1__BeginSession*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BeginSession), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BeginSession::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BeginSession(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BeginSession * SOAP_FMAC4 soap_in_ns1__BeginSession(struct soap *soap, const char *tag, ns1__BeginSession *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BeginSession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BeginSession, sizeof(ns1__BeginSession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BeginSession)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BeginSession *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns1__BeginSession*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BeginSession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BeginSession, 0, sizeof(ns1__BeginSession), 0, soap_copy_ns1__BeginSession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__BeginSession::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BeginSession);
	if (this->soap_out(soap, tag?tag:"ns1:BeginSession", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BeginSession::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BeginSession(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BeginSession * SOAP_FMAC4 soap_get_ns1__BeginSession(struct soap *soap, ns1__BeginSession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BeginSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__BeginSession * SOAP_FMAC2 soap_instantiate_ns1__BeginSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BeginSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BeginSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__BeginSession);
		if (size)
			*size = sizeof(ns1__BeginSession);
		((ns1__BeginSession*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__BeginSession, n);
		if (size)
			*size = n * sizeof(ns1__BeginSession);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__BeginSession*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__BeginSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BeginSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BeginSession %p -> %p\n", q, p));
	*(ns1__BeginSession*)p = *(ns1__BeginSession*)q;
}

void ns1__ResultSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ResultSet::ns2__root = NULL;
	this->ns1__ResultSet::ns4__root = NULL;
	this->ns1__ResultSet::ns5__root = NULL;
	/* transient soap skipped */
}

void ns1__ResultSet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ResultXmlRoot(soap, &this->ns1__ResultSet::ns2__root);
	soap_serialize_PointerTons4__ResultXmlRoot(soap, &this->ns1__ResultSet::ns4__root);
	soap_serialize_PointerTons5__ResultXmlRoot(soap, &this->ns1__ResultSet::ns5__root);
	/* transient soap skipped */
#endif
}

int ns1__ResultSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResultSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResultSet(struct soap *soap, const char *tag, int id, const ns1__ResultSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResultSet), type))
		return soap->error;
	if (soap_out_PointerTons2__ResultXmlRoot(soap, "ns2:root", -1, &(a->ns1__ResultSet::ns2__root), ""))
		return soap->error;
	if (soap_out_PointerTons4__ResultXmlRoot(soap, "ns4:root", -1, &(a->ns1__ResultSet::ns4__root), ""))
		return soap->error;
	if (soap_out_PointerTons5__ResultXmlRoot(soap, "ns5:root", -1, &(a->ns1__ResultSet::ns5__root), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ResultSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ResultSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResultSet * SOAP_FMAC4 soap_in_ns1__ResultSet(struct soap *soap, const char *tag, ns1__ResultSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResultSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResultSet, sizeof(ns1__ResultSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ResultSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ResultSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns2__root1 = 1;
	size_t soap_flag_ns4__root1 = 1;
	size_t soap_flag_ns5__root1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__root1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResultXmlRoot(soap, "ns2:root", &(a->ns1__ResultSet::ns2__root), "ns2:ResultXmlRoot"))
				{	soap_flag_ns2__root1--;
					continue;
				}
			if (soap_flag_ns4__root1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResultXmlRoot(soap, "ns4:root", &(a->ns1__ResultSet::ns4__root), "ns4:ResultXmlRoot"))
				{	soap_flag_ns4__root1--;
					continue;
				}
			if (soap_flag_ns5__root1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ResultXmlRoot(soap, "ns5:root", &(a->ns1__ResultSet::ns5__root), "ns5:ResultXmlRoot"))
				{	soap_flag_ns5__root1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ResultSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResultSet, 0, sizeof(ns1__ResultSet), 0, soap_copy_ns1__ResultSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ResultSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ResultSet);
	if (this->soap_out(soap, tag?tag:"ns1:ResultSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ResultSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResultSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResultSet * SOAP_FMAC4 soap_get_ns1__ResultSet(struct soap *soap, ns1__ResultSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ResultSet * SOAP_FMAC2 soap_instantiate_ns1__ResultSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResultSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ResultSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ResultSet);
		if (size)
			*size = sizeof(ns1__ResultSet);
		((ns1__ResultSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ResultSet, n);
		if (size)
			*size = n * sizeof(ns1__ResultSet);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ResultSet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ResultSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ResultSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ResultSet %p -> %p\n", q, p));
	*(ns1__ResultSet*)p = *(ns1__ResultSet*)q;
}

void ns1__Parameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Parameters::__any = NULL;
	/* transient soap skipped */
}

void ns1__Parameters::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameters(struct soap *soap, const char *tag, int id, const ns1__Parameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameters), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns1__Parameters::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_in_ns1__Parameters(struct soap *soap, const char *tag, ns1__Parameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Parameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Parameters *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->ns1__Parameters::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameters, 0, sizeof(ns1__Parameters), 0, soap_copy_ns1__Parameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Parameters);
	if (this->soap_out(soap, tag?tag:"ns1:Parameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_get_ns1__Parameters(struct soap *soap, ns1__Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Parameters * SOAP_FMAC2 soap_instantiate_ns1__Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Parameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Parameters);
		if (size)
			*size = sizeof(ns1__Parameters);
		((ns1__Parameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Parameters, n);
		if (size)
			*size = n * sizeof(ns1__Parameters);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Parameters*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Parameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Parameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Parameters %p -> %p\n", q, p));
	*(ns1__Parameters*)p = *(ns1__Parameters*)q;
}

void ns1__PropertyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__PropertyList::__any);
	/* transient soap skipped */
}

void ns1__PropertyList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__PropertyList::__any);
	/* transient soap skipped */
#endif
}

int ns1__PropertyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PropertyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PropertyList(struct soap *soap, const char *tag, int id, const ns1__PropertyList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PropertyList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns1__PropertyList::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PropertyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PropertyList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PropertyList * SOAP_FMAC4 soap_in_ns1__PropertyList(struct soap *soap, const char *tag, ns1__PropertyList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PropertyList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PropertyList, sizeof(ns1__PropertyList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PropertyList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PropertyList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns1__PropertyList::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PropertyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PropertyList, 0, sizeof(ns1__PropertyList), 0, soap_copy_ns1__PropertyList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__PropertyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PropertyList);
	if (this->soap_out(soap, tag?tag:"ns1:PropertyList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PropertyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PropertyList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PropertyList * SOAP_FMAC4 soap_get_ns1__PropertyList(struct soap *soap, ns1__PropertyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PropertyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PropertyList * SOAP_FMAC2 soap_instantiate_ns1__PropertyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PropertyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PropertyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PropertyList);
		if (size)
			*size = sizeof(ns1__PropertyList);
		((ns1__PropertyList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__PropertyList, n);
		if (size)
			*size = n * sizeof(ns1__PropertyList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__PropertyList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__PropertyList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PropertyList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PropertyList %p -> %p\n", q, p));
	*(ns1__PropertyList*)p = *(ns1__PropertyList*)q;
}

void ns1__Properties::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Properties::PropertyList = NULL;
	/* transient soap skipped */
}

void ns1__Properties::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PropertyList(soap, &this->ns1__Properties::PropertyList);
	/* transient soap skipped */
#endif
}

int ns1__Properties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Properties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Properties(struct soap *soap, const char *tag, int id, const ns1__Properties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Properties), type))
		return soap->error;
	if (soap_out_PointerTons1__PropertyList(soap, "ns1:PropertyList", -1, &(a->ns1__Properties::PropertyList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Properties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Properties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Properties * SOAP_FMAC4 soap_in_ns1__Properties(struct soap *soap, const char *tag, ns1__Properties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Properties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Properties, sizeof(ns1__Properties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Properties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Properties *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PropertyList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PropertyList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PropertyList(soap, "ns1:PropertyList", &(a->ns1__Properties::PropertyList), "ns1:PropertyList"))
				{	soap_flag_PropertyList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Properties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Properties, 0, sizeof(ns1__Properties), 0, soap_copy_ns1__Properties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Properties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Properties);
	if (this->soap_out(soap, tag?tag:"ns1:Properties", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Properties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Properties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Properties * SOAP_FMAC4 soap_get_ns1__Properties(struct soap *soap, ns1__Properties *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Properties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Properties * SOAP_FMAC2 soap_instantiate_ns1__Properties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Properties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Properties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Properties);
		if (size)
			*size = sizeof(ns1__Properties);
		((ns1__Properties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Properties, n);
		if (size)
			*size = n * sizeof(ns1__Properties);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Properties*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Properties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Properties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Properties %p -> %p\n", q, p));
	*(ns1__Properties*)p = *(ns1__Properties*)q;
}

void ns1__CommandStatement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CommandStatement::Statement = NULL;
	/* transient soap skipped */
}

void ns1__CommandStatement::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__CommandStatement::Statement);
	/* transient soap skipped */
#endif
}

int ns1__CommandStatement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CommandStatement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CommandStatement(struct soap *soap, const char *tag, int id, const ns1__CommandStatement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CommandStatement), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Statement", -1, &(a->ns1__CommandStatement::Statement), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CommandStatement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CommandStatement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CommandStatement * SOAP_FMAC4 soap_in_ns1__CommandStatement(struct soap *soap, const char *tag, ns1__CommandStatement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CommandStatement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CommandStatement, sizeof(ns1__CommandStatement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CommandStatement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CommandStatement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Statement1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Statement1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Statement", &(a->ns1__CommandStatement::Statement), "xsd:string"))
				{	soap_flag_Statement1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CommandStatement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CommandStatement, 0, sizeof(ns1__CommandStatement), 0, soap_copy_ns1__CommandStatement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CommandStatement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CommandStatement);
	if (this->soap_out(soap, tag?tag:"ns1:CommandStatement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CommandStatement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CommandStatement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CommandStatement * SOAP_FMAC4 soap_get_ns1__CommandStatement(struct soap *soap, ns1__CommandStatement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CommandStatement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CommandStatement * SOAP_FMAC2 soap_instantiate_ns1__CommandStatement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CommandStatement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CommandStatement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CommandStatement);
		if (size)
			*size = sizeof(ns1__CommandStatement);
		((ns1__CommandStatement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CommandStatement, n);
		if (size)
			*size = n * sizeof(ns1__CommandStatement);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CommandStatement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CommandStatement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CommandStatement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CommandStatement %p -> %p\n", q, p));
	*(ns1__CommandStatement*)p = *(ns1__CommandStatement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__token, 0, sizeof(std::string), 0, soap_copy_xsd__token);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaXPath(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaXPath(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaXPath), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaXPath(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaXPath, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaXPath, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaXPath, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaXPath);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaXPath(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaXPath);
	if (soap_out_xsd__XmlSchemaXPath(soap, tag?tag:"xsd:XmlSchemaXPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaXPath(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaXPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaWhiteSpaceFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet);
	if (soap_out_xsd__XmlSchemaWhiteSpaceFacet(soap, tag?tag:"xsd:XmlSchemaWhiteSpaceFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaWhiteSpaceFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaUse(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaUse(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaUse), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaUse(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaUse, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaUse, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaUse, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaUse);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaUse(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaUse);
	if (soap_out_xsd__XmlSchemaUse(soap, tag?tag:"xsd:XmlSchemaUse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaUse(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaUse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaUnique(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaUnique(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaUnique), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaUnique(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaUnique, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaUnique, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaUnique, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaUnique);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaUnique(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaUnique);
	if (soap_out_xsd__XmlSchemaUnique(soap, tag?tag:"xsd:XmlSchemaUnique", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaUnique(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaType, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaType);
	if (soap_out_xsd__XmlSchemaType(soap, tag?tag:"xsd:XmlSchemaType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaTotalDigitsFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet);
	if (soap_out_xsd__XmlSchemaTotalDigitsFacet(soap, tag?tag:"xsd:XmlSchemaTotalDigitsFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaTotalDigitsFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaTotalDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleTypeUnion);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion);
	if (soap_out_xsd__XmlSchemaSimpleTypeUnion(soap, tag?tag:"xsd:XmlSchemaSimpleTypeUnion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleTypeUnion(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleTypeUnion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleTypeRestriction);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction);
	if (soap_out_xsd__XmlSchemaSimpleTypeRestriction(soap, tag?tag:"xsd:XmlSchemaSimpleTypeRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleTypeRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleTypeList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleTypeList);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleTypeList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList);
	if (soap_out_xsd__XmlSchemaSimpleTypeList(soap, tag?tag:"xsd:XmlSchemaSimpleTypeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleTypeList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleTypeContent(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleTypeContent(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleTypeContent(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleTypeContent);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleTypeContent(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent);
	if (soap_out_xsd__XmlSchemaSimpleTypeContent(soap, tag?tag:"xsd:XmlSchemaSimpleTypeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleTypeContent(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleTypeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleType, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleType);
	if (soap_out_xsd__XmlSchemaSimpleType(soap, tag?tag:"xsd:XmlSchemaSimpleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleContentRestriction);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction);
	if (soap_out_xsd__XmlSchemaSimpleContentRestriction(soap, tag?tag:"xsd:XmlSchemaSimpleContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleContentRestriction(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleContentExtension(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleContentExtension);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleContentExtension(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension);
	if (soap_out_xsd__XmlSchemaSimpleContentExtension(soap, tag?tag:"xsd:XmlSchemaSimpleContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleContentExtension(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSimpleContent(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSimpleContent(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContent), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSimpleContent(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContent, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSimpleContent, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSimpleContent, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSimpleContent);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSimpleContent(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSimpleContent);
	if (soap_out_xsd__XmlSchemaSimpleContent(soap, tag?tag:"xsd:XmlSchemaSimpleContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSimpleContent(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSimpleContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaSequence(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaSequence(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaSequence), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaSequence(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSequence, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaSequence, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaSequence, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaSequence);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaSequence(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaSequence);
	if (soap_out_xsd__XmlSchemaSequence(soap, tag?tag:"xsd:XmlSchemaSequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaSequence(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaRedefine(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaRedefine(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaRedefine), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaRedefine(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaRedefine, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaRedefine, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaRedefine, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaRedefine);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaRedefine(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaRedefine);
	if (soap_out_xsd__XmlSchemaRedefine(soap, tag?tag:"xsd:XmlSchemaRedefine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaRedefine(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaRedefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaPatternFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaPatternFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaPatternFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaPatternFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaPatternFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaPatternFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaPatternFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaPatternFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaPatternFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaPatternFacet);
	if (soap_out_xsd__XmlSchemaPatternFacet(soap, tag?tag:"xsd:XmlSchemaPatternFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaPatternFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaPatternFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaParticle(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaParticle(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaParticle), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaParticle(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaParticle, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaParticle, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaParticle, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaParticle);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaParticle(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaParticle);
	if (soap_out_xsd__XmlSchemaParticle(soap, tag?tag:"xsd:XmlSchemaParticle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaParticle(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaParticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaObject(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaObject(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaObject), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaObject(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaObject, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaObject, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaObject, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaObject);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaObject(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaObject);
	if (soap_out_xsd__XmlSchemaObject(soap, tag?tag:"xsd:XmlSchemaObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaObject(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaNumericFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaNumericFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaNumericFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaNumericFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaNumericFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaNumericFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaNumericFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaNumericFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaNumericFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaNumericFacet);
	if (soap_out_xsd__XmlSchemaNumericFacet(soap, tag?tag:"xsd:XmlSchemaNumericFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaNumericFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaNumericFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaNotation(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaNotation(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaNotation), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaNotation(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaNotation, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaNotation, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaNotation, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaNotation);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaNotation(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaNotation);
	if (soap_out_xsd__XmlSchemaNotation(soap, tag?tag:"xsd:XmlSchemaNotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaNotation(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaNotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMinLengthFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMinLengthFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMinLengthFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet);
	if (soap_out_xsd__XmlSchemaMinLengthFacet(soap, tag?tag:"xsd:XmlSchemaMinLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMinLengthFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMinLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMinInclusiveFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet);
	if (soap_out_xsd__XmlSchemaMinInclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMinInclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMinInclusiveFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMinInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMinExclusiveFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet);
	if (soap_out_xsd__XmlSchemaMinExclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMinExclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMinExclusiveFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMinExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMaxLengthFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMaxLengthFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMaxLengthFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet);
	if (soap_out_xsd__XmlSchemaMaxLengthFacet(soap, tag?tag:"xsd:XmlSchemaMaxLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMaxLengthFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMaxLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMaxInclusiveFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet);
	if (soap_out_xsd__XmlSchemaMaxInclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMaxInclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMaxInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaMaxExclusiveFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet);
	if (soap_out_xsd__XmlSchemaMaxExclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMaxExclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaMaxExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaLengthFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaLengthFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaLengthFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaLengthFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaLengthFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaLengthFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaLengthFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaLengthFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaLengthFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaLengthFacet);
	if (soap_out_xsd__XmlSchemaLengthFacet(soap, tag?tag:"xsd:XmlSchemaLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaLengthFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaKeyref(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaKeyref(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaKeyref), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaKeyref(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaKeyref, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaKeyref, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaKeyref, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaKeyref);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaKeyref(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaKeyref);
	if (soap_out_xsd__XmlSchemaKeyref(soap, tag?tag:"xsd:XmlSchemaKeyref", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaKeyref(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaKeyref(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaKey(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaKey(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaKey), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaKey(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaKey, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaKey, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaKey, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaKey);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaKey(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaKey);
	if (soap_out_xsd__XmlSchemaKey(soap, tag?tag:"xsd:XmlSchemaKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaKey(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaInclude(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaInclude(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaInclude), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaInclude(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaInclude, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaInclude, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaInclude, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaInclude);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaInclude(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaInclude);
	if (soap_out_xsd__XmlSchemaInclude(soap, tag?tag:"xsd:XmlSchemaInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaInclude(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaImport(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaImport(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaImport), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaImport(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaImport, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaImport, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaImport, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaImport);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaImport(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaImport);
	if (soap_out_xsd__XmlSchemaImport(soap, tag?tag:"xsd:XmlSchemaImport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaImport(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaImport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaIdentityConstraint(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaIdentityConstraint(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaIdentityConstraint), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaIdentityConstraint(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaIdentityConstraint, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaIdentityConstraint, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaIdentityConstraint, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaIdentityConstraint);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaIdentityConstraint(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaIdentityConstraint);
	if (soap_out_xsd__XmlSchemaIdentityConstraint(soap, tag?tag:"xsd:XmlSchemaIdentityConstraint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaIdentityConstraint(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaIdentityConstraint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaGroupRef(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaGroupRef(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaGroupRef), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaGroupRef(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroupRef, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroupRef, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaGroupRef, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaGroupRef);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaGroupRef(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaGroupRef);
	if (soap_out_xsd__XmlSchemaGroupRef(soap, tag?tag:"xsd:XmlSchemaGroupRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaGroupRef(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaGroupBase(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaGroupBase(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaGroupBase), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaGroupBase(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroupBase, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroupBase, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaGroupBase, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaGroupBase);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaGroupBase(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaGroupBase);
	if (soap_out_xsd__XmlSchemaGroupBase(soap, tag?tag:"xsd:XmlSchemaGroupBase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaGroupBase(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaGroupBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaGroup(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaGroup(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaGroup), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaGroup(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroup, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaGroup, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaGroup, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaGroup);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaGroup(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaGroup);
	if (soap_out_xsd__XmlSchemaGroup(soap, tag?tag:"xsd:XmlSchemaGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaGroup(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaFractionDigitsFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet);
	if (soap_out_xsd__XmlSchemaFractionDigitsFacet(soap, tag?tag:"xsd:XmlSchemaFractionDigitsFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaFractionDigitsFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaFractionDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaForm(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaForm(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaForm), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaForm(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaForm, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaForm, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaForm, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaForm);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaForm(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaForm);
	if (soap_out_xsd__XmlSchemaForm(soap, tag?tag:"xsd:XmlSchemaForm", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaForm(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaForm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaFacet);
	if (soap_out_xsd__XmlSchemaFacet(soap, tag?tag:"xsd:XmlSchemaFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaExternal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaExternal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaExternal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaExternal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaExternal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaExternal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaExternal, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaExternal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaExternal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaExternal);
	if (soap_out_xsd__XmlSchemaExternal(soap, tag?tag:"xsd:XmlSchemaExternal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaExternal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaExternal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaEnumerationFacet(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaEnumerationFacet);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaEnumerationFacet(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet);
	if (soap_out_xsd__XmlSchemaEnumerationFacet(soap, tag?tag:"xsd:XmlSchemaEnumerationFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaEnumerationFacet(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaEnumerationFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaElement(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaElement(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaElement), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaElement(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaElement, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaElement, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaElement, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaElement);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaElement(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaElement);
	if (soap_out_xsd__XmlSchemaElement(soap, tag?tag:"xsd:XmlSchemaElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaElement(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaDocumentation(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaDocumentation(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaDocumentation), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaDocumentation(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaDocumentation, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaDocumentation, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaDocumentation, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaDocumentation);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaDocumentation(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaDocumentation);
	if (soap_out_xsd__XmlSchemaDocumentation(soap, tag?tag:"xsd:XmlSchemaDocumentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaDocumentation(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaDocumentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaDerivationMethod(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaDerivationMethod), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaDerivationMethod, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaDerivationMethod, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaDerivationMethod, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaDerivationMethod);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaDerivationMethod(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaDerivationMethod);
	if (soap_out_xsd__XmlSchemaDerivationMethod(soap, tag?tag:"xsd:XmlSchemaDerivationMethod", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaDerivationMethod(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaDerivationMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaContentProcessing(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaContentProcessing(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaContentProcessing), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaContentProcessing(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContentProcessing, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContentProcessing, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaContentProcessing, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaContentProcessing);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaContentProcessing(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaContentProcessing);
	if (soap_out_xsd__XmlSchemaContentProcessing(soap, tag?tag:"xsd:XmlSchemaContentProcessing", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaContentProcessing(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaContentProcessing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaContentModel(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaContentModel(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaContentModel), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaContentModel(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContentModel, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContentModel, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaContentModel, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaContentModel);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaContentModel(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaContentModel);
	if (soap_out_xsd__XmlSchemaContentModel(soap, tag?tag:"xsd:XmlSchemaContentModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaContentModel(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaContentModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaContent(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaContent(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaContent), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaContent(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContent, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaContent, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaContent, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaContent);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaContent(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaContent);
	if (soap_out_xsd__XmlSchemaContent(soap, tag?tag:"xsd:XmlSchemaContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaContent(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaComplexType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaComplexType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaComplexType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaComplexType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaComplexType, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaComplexType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaComplexType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaComplexType);
	if (soap_out_xsd__XmlSchemaComplexType(soap, tag?tag:"xsd:XmlSchemaComplexType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaComplexType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaComplexType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaComplexContentRestriction(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaComplexContentRestriction);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaComplexContentRestriction(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction);
	if (soap_out_xsd__XmlSchemaComplexContentRestriction(soap, tag?tag:"xsd:XmlSchemaComplexContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaComplexContentRestriction(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaComplexContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaComplexContentExtension(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaComplexContentExtension);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaComplexContentExtension(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension);
	if (soap_out_xsd__XmlSchemaComplexContentExtension(soap, tag?tag:"xsd:XmlSchemaComplexContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaComplexContentExtension(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaComplexContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaComplexContent(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaComplexContent(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaComplexContent), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaComplexContent(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContent, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaComplexContent, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaComplexContent, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaComplexContent);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaComplexContent(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaComplexContent);
	if (soap_out_xsd__XmlSchemaComplexContent(soap, tag?tag:"xsd:XmlSchemaComplexContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaComplexContent(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaComplexContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaChoice(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaChoice(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaChoice), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaChoice(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaChoice, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaChoice, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaChoice, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaChoice);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaChoice(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaChoice);
	if (soap_out_xsd__XmlSchemaChoice(soap, tag?tag:"xsd:XmlSchemaChoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaChoice(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAttributeGroupRef(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAttributeGroupRef);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAttributeGroupRef(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef);
	if (soap_out_xsd__XmlSchemaAttributeGroupRef(soap, tag?tag:"xsd:XmlSchemaAttributeGroupRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAttributeGroupRef(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAttributeGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAttributeGroup(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroup), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroup, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttributeGroup, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAttributeGroup, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAttributeGroup);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAttributeGroup(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAttributeGroup);
	if (soap_out_xsd__XmlSchemaAttributeGroup(soap, tag?tag:"xsd:XmlSchemaAttributeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAttributeGroup(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAttributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAttribute(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAttribute(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAttribute), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAttribute(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttribute, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAttribute, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAttribute, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAttribute);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAttribute(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAttribute);
	if (soap_out_xsd__XmlSchemaAttribute(soap, tag?tag:"xsd:XmlSchemaAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAttribute(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAppInfo(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAppInfo(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAppInfo), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAppInfo(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAppInfo, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAppInfo, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAppInfo, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAppInfo);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAppInfo(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAppInfo);
	if (soap_out_xsd__XmlSchemaAppInfo(soap, tag?tag:"xsd:XmlSchemaAppInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAppInfo(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAppInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAnyAttribute(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAnyAttribute), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnyAttribute, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnyAttribute, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAnyAttribute, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAnyAttribute);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAnyAttribute(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAnyAttribute);
	if (soap_out_xsd__XmlSchemaAnyAttribute(soap, tag?tag:"xsd:XmlSchemaAnyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAnyAttribute(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAnyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAny(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAny(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAny), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAny(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAny, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAny, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAny, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAny);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAny(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAny);
	if (soap_out_xsd__XmlSchemaAny(soap, tag?tag:"xsd:XmlSchemaAny", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAny(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAnnotation(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAnnotation(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAnnotation), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAnnotation(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnnotation, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnnotation, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAnnotation, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAnnotation);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAnnotation(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAnnotation);
	if (soap_out_xsd__XmlSchemaAnnotation(soap, tag?tag:"xsd:XmlSchemaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAnnotation(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAnnotated(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAnnotated(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAnnotated), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAnnotated(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnnotated, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAnnotated, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAnnotated, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAnnotated);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAnnotated(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAnnotated);
	if (soap_out_xsd__XmlSchemaAnnotated(soap, tag?tag:"xsd:XmlSchemaAnnotated", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAnnotated(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAnnotated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchemaAll(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchemaAll(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchemaAll), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchemaAll(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAll, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchemaAll, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchemaAll, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchemaAll);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchemaAll(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchemaAll);
	if (soap_out_xsd__XmlSchemaAll(soap, tag?tag:"xsd:XmlSchemaAll", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchemaAll(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchemaAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__XmlSchema(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__XmlSchema(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__XmlSchema), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__XmlSchema(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchema, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__XmlSchema, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__XmlSchema, 0, sizeof(std::string), 0, soap_copy_xsd__XmlSchema);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__XmlSchema(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__XmlSchema);
	if (soap_out_xsd__XmlSchema(soap, tag?tag:"xsd:XmlSchema", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__XmlSchema(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__XmlSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Discover_(struct soap *soap, struct __ns1__Discover_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Discover = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Discover_(struct soap *soap, const struct __ns1__Discover_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Discover(soap, &a->ns1__Discover);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Discover_(struct soap *soap, const char *tag, int id, const struct __ns1__Discover_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Discover(soap, "ns1:Discover", -1, &a->ns1__Discover, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Discover_ * SOAP_FMAC4 soap_in___ns1__Discover_(struct soap *soap, const char *tag, struct __ns1__Discover_ *a, const char *type)
{
	size_t soap_flag_ns1__Discover = 1;
	short soap_flag;
	a = (struct __ns1__Discover_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Discover_, sizeof(struct __ns1__Discover_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Discover_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Discover && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Discover(soap, "ns1:Discover", &a->ns1__Discover, ""))
				{	soap_flag_ns1__Discover--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Discover_(struct soap *soap, const struct __ns1__Discover_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Discover_(soap, tag?tag:"-ns1:Discover", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Discover_ * SOAP_FMAC4 soap_get___ns1__Discover_(struct soap *soap, struct __ns1__Discover_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Discover_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Discover_ * SOAP_FMAC2 soap_instantiate___ns1__Discover_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Discover_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Discover_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Discover_);
		if (size)
			*size = sizeof(struct __ns1__Discover_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Discover_, n);
		if (size)
			*size = n * sizeof(struct __ns1__Discover_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Discover_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Discover_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Discover_ %p -> %p\n", q, p));
	*(struct __ns1__Discover_*)p = *(struct __ns1__Discover_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Execute_(struct soap *soap, struct __ns1__Execute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Execute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Execute_(struct soap *soap, const struct __ns1__Execute_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Execute(soap, &a->ns1__Execute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Execute_(struct soap *soap, const char *tag, int id, const struct __ns1__Execute_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Execute(soap, "ns1:Execute", -1, &a->ns1__Execute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute_ * SOAP_FMAC4 soap_in___ns1__Execute_(struct soap *soap, const char *tag, struct __ns1__Execute_ *a, const char *type)
{
	size_t soap_flag_ns1__Execute = 1;
	short soap_flag;
	a = (struct __ns1__Execute_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Execute_, sizeof(struct __ns1__Execute_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Execute_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Execute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Execute(soap, "ns1:Execute", &a->ns1__Execute, ""))
				{	soap_flag_ns1__Execute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Execute_(struct soap *soap, const struct __ns1__Execute_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Execute_(soap, tag?tag:"-ns1:Execute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute_ * SOAP_FMAC4 soap_get___ns1__Execute_(struct soap *soap, struct __ns1__Execute_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Execute_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Execute_ * SOAP_FMAC2 soap_instantiate___ns1__Execute_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Execute_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Execute_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Execute_);
		if (size)
			*size = sizeof(struct __ns1__Execute_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Execute_, n);
		if (size)
			*size = n * sizeof(struct __ns1__Execute_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Execute_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Execute_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Execute_ %p -> %p\n", q, p));
	*(struct __ns1__Execute_*)p = *(struct __ns1__Execute_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Discover(struct soap *soap, struct __ns1__Discover *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Discover = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Discover(struct soap *soap, const struct __ns1__Discover *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Discover(soap, &a->ns1__Discover);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Discover(struct soap *soap, const char *tag, int id, const struct __ns1__Discover *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Discover(soap, "ns1:Discover", -1, &a->ns1__Discover, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Discover * SOAP_FMAC4 soap_in___ns1__Discover(struct soap *soap, const char *tag, struct __ns1__Discover *a, const char *type)
{
	size_t soap_flag_ns1__Discover = 1;
	short soap_flag;
	a = (struct __ns1__Discover *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Discover, sizeof(struct __ns1__Discover), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Discover(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Discover && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Discover(soap, "ns1:Discover", &a->ns1__Discover, ""))
				{	soap_flag_ns1__Discover--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Discover(struct soap *soap, const struct __ns1__Discover *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Discover(soap, tag?tag:"-ns1:Discover", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Discover * SOAP_FMAC4 soap_get___ns1__Discover(struct soap *soap, struct __ns1__Discover *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Discover(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Discover * SOAP_FMAC2 soap_instantiate___ns1__Discover(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Discover(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Discover, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Discover);
		if (size)
			*size = sizeof(struct __ns1__Discover);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Discover, n);
		if (size)
			*size = n * sizeof(struct __ns1__Discover);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Discover*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Discover(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Discover %p -> %p\n", q, p));
	*(struct __ns1__Discover*)p = *(struct __ns1__Discover*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Execute(struct soap *soap, struct __ns1__Execute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Execute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Execute(struct soap *soap, const struct __ns1__Execute *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Execute(soap, &a->ns1__Execute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Execute(struct soap *soap, const char *tag, int id, const struct __ns1__Execute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Execute(soap, "ns1:Execute", -1, &a->ns1__Execute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute * SOAP_FMAC4 soap_in___ns1__Execute(struct soap *soap, const char *tag, struct __ns1__Execute *a, const char *type)
{
	size_t soap_flag_ns1__Execute = 1;
	short soap_flag;
	a = (struct __ns1__Execute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Execute, sizeof(struct __ns1__Execute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Execute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Execute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Execute(soap, "ns1:Execute", &a->ns1__Execute, ""))
				{	soap_flag_ns1__Execute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Execute(struct soap *soap, const struct __ns1__Execute *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Execute(soap, tag?tag:"-ns1:Execute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute * SOAP_FMAC4 soap_get___ns1__Execute(struct soap *soap, struct __ns1__Execute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Execute * SOAP_FMAC2 soap_instantiate___ns1__Execute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Execute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Execute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Execute);
		if (size)
			*size = sizeof(struct __ns1__Execute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Execute, n);
		if (size)
			*size = n * sizeof(struct __ns1__Execute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Execute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Execute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Execute %p -> %p\n", q, p));
	*(struct __ns1__Execute*)p = *(struct __ns1__Execute*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginSession_ = NULL;
	a->ns1__EndSession_ = NULL;
	a->ns1__Session_ = NULL;
	a->ns6__Security_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BeginSession(soap, &a->ns1__BeginSession_);
	soap_serialize_PointerTons1__EndSession(soap, &a->ns1__EndSession_);
	soap_serialize_PointerTons1__Session(soap, &a->ns1__Session_);
	soap_serialize_PointerTons6__Security(soap, &a->ns6__Security_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__BeginSession(soap, "ns1:BeginSession", -1, &a->ns1__BeginSession_, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__EndSession(soap, "ns1:EndSession", -1, &a->ns1__EndSession_, ""))
		return soap->error;
	if (soap_out_PointerTons1__Session(soap, "ns1:Session", -1, &a->ns1__Session_, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons6__Security(soap, "ns6:Security", -1, &a->ns6__Security_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__BeginSession_ = 1;
	size_t soap_flag_ns1__EndSession_ = 1;
	size_t soap_flag_ns1__Session_ = 1;
	size_t soap_flag_ns6__Security_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginSession_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BeginSession(soap, "ns1:BeginSession", &a->ns1__BeginSession_, "ns1:BeginSession"))
				{	soap_flag_ns1__BeginSession_--;
					continue;
				}
			if (soap_flag_ns1__EndSession_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EndSession(soap, "ns1:EndSession", &a->ns1__EndSession_, "ns1:EndSession"))
				{	soap_flag_ns1__EndSession_--;
					continue;
				}
			if (soap_flag_ns1__Session_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Session(soap, "ns1:Session", &a->ns1__Session_, "ns1:Session"))
				{	soap_flag_ns1__Session_--;
					continue;
				}
			if (soap_flag_ns6__Security_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Security(soap, "ns6:Security", &a->ns6__Security_, "ns6:Security"))
				{	soap_flag_ns6__Security_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DiscoverResponse(struct soap *soap, _ns1__DiscoverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DiscoverResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DiscoverResponse(struct soap *soap, const char *tag, int id, _ns1__DiscoverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DiscoverResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DiscoverResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DiscoverResponse(struct soap *soap, const char *tag, _ns1__DiscoverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DiscoverResponse **)soap_malloc(soap, sizeof(_ns1__DiscoverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DiscoverResponse *)soap_instantiate__ns1__DiscoverResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DiscoverResponse ** p = (_ns1__DiscoverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DiscoverResponse, sizeof(_ns1__DiscoverResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DiscoverResponse(struct soap *soap, _ns1__DiscoverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DiscoverResponse);
	if (soap_out_PointerTo_ns1__DiscoverResponse(soap, tag?tag:"ns1:DiscoverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DiscoverResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DiscoverResponse(struct soap *soap, _ns1__DiscoverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DiscoverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Discover(struct soap *soap, _ns1__Discover *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Discover))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Discover(struct soap *soap, const char *tag, int id, _ns1__Discover *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Discover);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Discover ** SOAP_FMAC4 soap_in_PointerTo_ns1__Discover(struct soap *soap, const char *tag, _ns1__Discover **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Discover **)soap_malloc(soap, sizeof(_ns1__Discover *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Discover *)soap_instantiate__ns1__Discover(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Discover ** p = (_ns1__Discover **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Discover, sizeof(_ns1__Discover), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Discover(struct soap *soap, _ns1__Discover *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Discover);
	if (soap_out_PointerTo_ns1__Discover(soap, tag?tag:"ns1:Discover", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Discover ** SOAP_FMAC4 soap_get_PointerTo_ns1__Discover(struct soap *soap, _ns1__Discover **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Discover(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteResponse(struct soap *soap, _ns1__ExecuteResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteResponse(struct soap *soap, const char *tag, int id, _ns1__ExecuteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ExecuteResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteResponse(struct soap *soap, const char *tag, _ns1__ExecuteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExecuteResponse **)soap_malloc(soap, sizeof(_ns1__ExecuteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExecuteResponse *)soap_instantiate__ns1__ExecuteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ExecuteResponse ** p = (_ns1__ExecuteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteResponse, sizeof(_ns1__ExecuteResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteResponse(struct soap *soap, _ns1__ExecuteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ExecuteResponse);
	if (soap_out_PointerTo_ns1__ExecuteResponse(soap, tag?tag:"ns1:ExecuteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExecuteResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteResponse(struct soap *soap, _ns1__ExecuteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Execute))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Execute(struct soap *soap, const char *tag, int id, _ns1__Execute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Execute);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Execute ** SOAP_FMAC4 soap_in_PointerTo_ns1__Execute(struct soap *soap, const char *tag, _ns1__Execute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Execute **)soap_malloc(soap, sizeof(_ns1__Execute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Execute *)soap_instantiate__ns1__Execute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Execute ** p = (_ns1__Execute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Execute, sizeof(_ns1__Execute), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Execute);
	if (soap_out_PointerTo_ns1__Execute(soap, tag?tag:"ns1:Execute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Execute ** SOAP_FMAC4 soap_get_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Security(struct soap *soap, ns6__Security *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Security))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Security(struct soap *soap, const char *tag, int id, ns6__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Security);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Security ** SOAP_FMAC4 soap_in_PointerTons6__Security(struct soap *soap, const char *tag, ns6__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Security **)soap_malloc(soap, sizeof(ns6__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Security *)soap_instantiate_ns6__Security(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Security ** p = (ns6__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Security, sizeof(ns6__Security), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Security(struct soap *soap, ns6__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Security);
	if (soap_out_PointerTons6__Security(soap, tag?tag:"ns6:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Security ** SOAP_FMAC4 soap_get_PointerTons6__Security(struct soap *soap, ns6__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Session(struct soap *soap, ns1__Session *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Session))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Session(struct soap *soap, const char *tag, int id, ns1__Session *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Session);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Session ** SOAP_FMAC4 soap_in_PointerTons1__Session(struct soap *soap, const char *tag, ns1__Session **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Session **)soap_malloc(soap, sizeof(ns1__Session *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Session *)soap_instantiate_ns1__Session(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Session ** p = (ns1__Session **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Session, sizeof(ns1__Session), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Session(struct soap *soap, ns1__Session *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Session);
	if (soap_out_PointerTons1__Session(soap, tag?tag:"ns1:Session", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Session ** SOAP_FMAC4 soap_get_PointerTons1__Session(struct soap *soap, ns1__Session **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Session(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EndSession(struct soap *soap, ns1__EndSession *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EndSession))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EndSession(struct soap *soap, const char *tag, int id, ns1__EndSession *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EndSession);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EndSession ** SOAP_FMAC4 soap_in_PointerTons1__EndSession(struct soap *soap, const char *tag, ns1__EndSession **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EndSession **)soap_malloc(soap, sizeof(ns1__EndSession *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EndSession *)soap_instantiate_ns1__EndSession(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EndSession ** p = (ns1__EndSession **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EndSession, sizeof(ns1__EndSession), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EndSession(struct soap *soap, ns1__EndSession *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EndSession);
	if (soap_out_PointerTons1__EndSession(soap, tag?tag:"ns1:EndSession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EndSession ** SOAP_FMAC4 soap_get_PointerTons1__EndSession(struct soap *soap, ns1__EndSession **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EndSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BeginSession(struct soap *soap, ns1__BeginSession *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BeginSession))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BeginSession(struct soap *soap, const char *tag, int id, ns1__BeginSession *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BeginSession);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BeginSession ** SOAP_FMAC4 soap_in_PointerTons1__BeginSession(struct soap *soap, const char *tag, ns1__BeginSession **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BeginSession **)soap_malloc(soap, sizeof(ns1__BeginSession *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BeginSession *)soap_instantiate_ns1__BeginSession(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BeginSession ** p = (ns1__BeginSession **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BeginSession, sizeof(ns1__BeginSession), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BeginSession(struct soap *soap, ns1__BeginSession *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BeginSession);
	if (soap_out_PointerTons1__BeginSession(soap, tag?tag:"ns1:BeginSession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BeginSession ** SOAP_FMAC4 soap_get_PointerTons1__BeginSession(struct soap *soap, ns1__BeginSession **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BeginSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaRedefine(struct soap *soap, __ns3__union_XmlSchemaRedefine *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaRedefine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaRedefine(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaRedefine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaRedefine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaRedefine ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaRedefine(struct soap *soap, const char *tag, __ns3__union_XmlSchemaRedefine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaRedefine **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaRedefine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaRedefine *)soap_instantiate___ns3__union_XmlSchemaRedefine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaRedefine ** p = (__ns3__union_XmlSchemaRedefine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaRedefine, sizeof(__ns3__union_XmlSchemaRedefine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaRedefine(struct soap *soap, __ns3__union_XmlSchemaRedefine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaRedefine);
	if (soap_out_PointerTo__ns3__union_XmlSchemaRedefine(soap, tag?tag:"-ns3:union-XmlSchemaRedefine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaRedefine ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaRedefine(struct soap *soap, __ns3__union_XmlSchemaRedefine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaRedefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleTypeRestriction *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaSimpleTypeRestriction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleTypeRestriction ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleTypeRestriction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaSimpleTypeRestriction **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaSimpleTypeRestriction *)soap_instantiate___ns3__union_XmlSchemaSimpleTypeRestriction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaSimpleTypeRestriction ** p = (__ns3__union_XmlSchemaSimpleTypeRestriction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction, sizeof(__ns3__union_XmlSchemaSimpleTypeRestriction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleTypeRestriction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction);
	if (soap_out_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(soap, tag?tag:"-ns3:union-XmlSchemaSimpleTypeRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleTypeRestriction ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleTypeRestriction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaSimpleTypeRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction_ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaSimpleContentRestriction_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction_ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentRestriction_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaSimpleContentRestriction_ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaSimpleContentRestriction_ *)soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction_(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaSimpleContentRestriction_ ** p = (__ns3__union_XmlSchemaSimpleContentRestriction_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction_), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_);
	if (soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction_ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaSimpleContentRestriction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentRestriction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaSimpleContentRestriction **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaSimpleContentRestriction *)soap_instantiate___ns3__union_XmlSchemaSimpleContentRestriction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaSimpleContentRestriction ** p = (__ns3__union_XmlSchemaSimpleContentRestriction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction, sizeof(__ns3__union_XmlSchemaSimpleContentRestriction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction);
	if (soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentRestriction ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(struct soap *soap, __ns3__union_XmlSchemaSimpleContentRestriction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaFractionDigitsFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet))
		soap_serialize_xsd__XmlSchemaFractionDigitsFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaFractionDigitsFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaFractionDigitsFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaFractionDigitsFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaFractionDigitsFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaFractionDigitsFacet);
	if (soap_out_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, tag?tag:"xsd:XmlSchemaFractionDigitsFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaFractionDigitsFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaFractionDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaTotalDigitsFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet))
		soap_serialize_xsd__XmlSchemaTotalDigitsFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaTotalDigitsFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaTotalDigitsFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaTotalDigitsFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaTotalDigitsFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaTotalDigitsFacet);
	if (soap_out_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, tag?tag:"xsd:XmlSchemaTotalDigitsFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaTotalDigitsFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaTotalDigitsFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet))
		soap_serialize_xsd__XmlSchemaWhiteSpaceFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaWhiteSpaceFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaWhiteSpaceFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaWhiteSpaceFacet);
	if (soap_out_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, tag?tag:"xsd:XmlSchemaWhiteSpaceFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaWhiteSpaceFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaWhiteSpaceFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMinInclusiveFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet))
		soap_serialize_xsd__XmlSchemaMinInclusiveFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMinInclusiveFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMinInclusiveFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMinInclusiveFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMinInclusiveFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMinInclusiveFacet);
	if (soap_out_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMinInclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMinInclusiveFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMinInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet))
		soap_serialize_xsd__XmlSchemaMaxExclusiveFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMaxExclusiveFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMaxExclusiveFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMaxExclusiveFacet);
	if (soap_out_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMaxExclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMaxExclusiveFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMaxExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaPatternFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaPatternFacet))
		soap_serialize_xsd__XmlSchemaPatternFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaPatternFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaPatternFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaPatternFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaPatternFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaPatternFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaPatternFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaPatternFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaPatternFacet);
	if (soap_out_PointerToxsd__XmlSchemaPatternFacet(soap, tag?tag:"xsd:XmlSchemaPatternFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaPatternFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaPatternFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMaxLengthFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet))
		soap_serialize_xsd__XmlSchemaMaxLengthFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMaxLengthFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMaxLengthFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMaxLengthFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMaxLengthFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMaxLengthFacet);
	if (soap_out_PointerToxsd__XmlSchemaMaxLengthFacet(soap, tag?tag:"xsd:XmlSchemaMaxLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMaxLengthFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMaxLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMinLengthFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet))
		soap_serialize_xsd__XmlSchemaMinLengthFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMinLengthFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMinLengthFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMinLengthFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMinLengthFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMinLengthFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMinLengthFacet);
	if (soap_out_PointerToxsd__XmlSchemaMinLengthFacet(soap, tag?tag:"xsd:XmlSchemaMinLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMinLengthFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMinLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaLengthFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaLengthFacet))
		soap_serialize_xsd__XmlSchemaLengthFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaLengthFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaLengthFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaLengthFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaLengthFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaLengthFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaLengthFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaLengthFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaLengthFacet);
	if (soap_out_PointerToxsd__XmlSchemaLengthFacet(soap, tag?tag:"xsd:XmlSchemaLengthFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaLengthFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaLengthFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet))
		soap_serialize_xsd__XmlSchemaMaxInclusiveFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMaxInclusiveFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMaxInclusiveFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMaxInclusiveFacet);
	if (soap_out_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMaxInclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMaxInclusiveFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMaxInclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaEnumerationFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet))
		soap_serialize_xsd__XmlSchemaEnumerationFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaEnumerationFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaEnumerationFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaEnumerationFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaEnumerationFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaEnumerationFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaEnumerationFacet);
	if (soap_out_PointerToxsd__XmlSchemaEnumerationFacet(soap, tag?tag:"xsd:XmlSchemaEnumerationFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaEnumerationFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaEnumerationFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaMinExclusiveFacet(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet))
		soap_serialize_xsd__XmlSchemaMinExclusiveFacet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaMinExclusiveFacet(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaMinExclusiveFacet(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaMinExclusiveFacet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaMinExclusiveFacet(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaMinExclusiveFacet);
	if (soap_out_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, tag?tag:"xsd:XmlSchemaMinExclusiveFacet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaMinExclusiveFacet(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaMinExclusiveFacet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, __ns3__union_XmlSchemaSimpleContentExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaSimpleContentExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentExtension ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSimpleContentExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaSimpleContentExtension **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaSimpleContentExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaSimpleContentExtension *)soap_instantiate___ns3__union_XmlSchemaSimpleContentExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaSimpleContentExtension ** p = (__ns3__union_XmlSchemaSimpleContentExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension, sizeof(__ns3__union_XmlSchemaSimpleContentExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, __ns3__union_XmlSchemaSimpleContentExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSimpleContentExtension);
	if (soap_out_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(soap, tag?tag:"-ns3:union-XmlSchemaSimpleContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSimpleContentExtension ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(struct soap *soap, __ns3__union_XmlSchemaSimpleContentExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaSimpleContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaSequence(struct soap *soap, __ns3__union_XmlSchemaSequence *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaSequence))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaSequence(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaSequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaSequence);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSequence ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaSequence(struct soap *soap, const char *tag, __ns3__union_XmlSchemaSequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaSequence **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaSequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaSequence *)soap_instantiate___ns3__union_XmlSchemaSequence(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaSequence ** p = (__ns3__union_XmlSchemaSequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaSequence, sizeof(__ns3__union_XmlSchemaSequence), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaSequence(struct soap *soap, __ns3__union_XmlSchemaSequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaSequence);
	if (soap_out_PointerTo__ns3__union_XmlSchemaSequence(soap, tag?tag:"-ns3:union-XmlSchemaSequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaSequence ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaSequence(struct soap *soap, __ns3__union_XmlSchemaSequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaChoice(struct soap *soap, __ns3__union_XmlSchemaChoice *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaChoice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaChoice(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaChoice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaChoice);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaChoice ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaChoice(struct soap *soap, const char *tag, __ns3__union_XmlSchemaChoice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaChoice **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaChoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaChoice *)soap_instantiate___ns3__union_XmlSchemaChoice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaChoice ** p = (__ns3__union_XmlSchemaChoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaChoice, sizeof(__ns3__union_XmlSchemaChoice), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaChoice(struct soap *soap, __ns3__union_XmlSchemaChoice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaChoice);
	if (soap_out_PointerTo__ns3__union_XmlSchemaChoice(soap, tag?tag:"-ns3:union-XmlSchemaChoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaChoice ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaChoice(struct soap *soap, __ns3__union_XmlSchemaChoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAny(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAny))
		soap_serialize_xsd__XmlSchemaAny(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAny(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAny);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAny(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAny(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAny(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAny, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAny(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAny);
	if (soap_out_PointerToxsd__XmlSchemaAny(soap, tag?tag:"xsd:XmlSchemaAny", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAny(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaContentProcessing(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaContentProcessing))
		soap_serialize_xsd__XmlSchemaContentProcessing(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaContentProcessing(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaContentProcessing);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaContentProcessing(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaContentProcessing(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaContentProcessing(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaContentProcessing, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaContentProcessing(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaContentProcessing);
	if (soap_out_PointerToxsd__XmlSchemaContentProcessing(soap, tag?tag:"xsd:XmlSchemaContentProcessing", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaContentProcessing(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaContentProcessing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaXPath(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaXPath))
		soap_serialize_xsd__XmlSchemaXPath(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaXPath(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaXPath);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaXPath(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaXPath(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaXPath(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaXPath, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaXPath(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaXPath);
	if (soap_out_PointerToxsd__XmlSchemaXPath(soap, tag?tag:"xsd:XmlSchemaXPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaXPath(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaXPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaElement_(struct soap *soap, __ns3__union_XmlSchemaElement_ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaElement_))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaElement_(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaElement_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaElement_);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaElement_ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaElement_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaElement_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaElement_ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaElement_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaElement_ *)soap_instantiate___ns3__union_XmlSchemaElement_(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaElement_ ** p = (__ns3__union_XmlSchemaElement_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaElement_, sizeof(__ns3__union_XmlSchemaElement_), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaElement_(struct soap *soap, __ns3__union_XmlSchemaElement_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaElement_);
	if (soap_out_PointerTo__ns3__union_XmlSchemaElement_(soap, tag?tag:"-ns3:union-XmlSchemaElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaElement_ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaElement_(struct soap *soap, __ns3__union_XmlSchemaElement_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaElement_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaKeyref(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaKeyref))
		soap_serialize_xsd__XmlSchemaKeyref(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaKeyref(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaKeyref);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaKeyref(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaKeyref(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaKeyref(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaKeyref, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaKeyref(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaKeyref);
	if (soap_out_PointerToxsd__XmlSchemaKeyref(soap, tag?tag:"xsd:XmlSchemaKeyref", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaKeyref(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaKeyref(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaKey(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaKey))
		soap_serialize_xsd__XmlSchemaKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaKey(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaKey);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaKey(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaKey, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaKey(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaKey);
	if (soap_out_PointerToxsd__XmlSchemaKey(soap, tag?tag:"xsd:XmlSchemaKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaKey(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaUnique(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaUnique))
		soap_serialize_xsd__XmlSchemaUnique(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaUnique(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaUnique);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaUnique(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaUnique(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaUnique(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaUnique, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaUnique(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaUnique);
	if (soap_out_PointerToxsd__XmlSchemaUnique(soap, tag?tag:"xsd:XmlSchemaUnique", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaUnique(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, __ns3__union_XmlSchemaComplexContentExtension_ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaComplexContentExtension_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentExtension_ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexContentExtension_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaComplexContentExtension_ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaComplexContentExtension_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaComplexContentExtension_ *)soap_instantiate___ns3__union_XmlSchemaComplexContentExtension_(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaComplexContentExtension_ ** p = (__ns3__union_XmlSchemaComplexContentExtension_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_, sizeof(__ns3__union_XmlSchemaComplexContentExtension_), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, __ns3__union_XmlSchemaComplexContentExtension_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexContentExtension_);
	if (soap_out_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(soap, tag?tag:"-ns3:union-XmlSchemaComplexContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentExtension_ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(struct soap *soap, __ns3__union_XmlSchemaComplexContentExtension_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaComplexContentExtension_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaComplexContentRestriction_ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaComplexContentRestriction_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentRestriction_ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexContentRestriction_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaComplexContentRestriction_ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaComplexContentRestriction_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaComplexContentRestriction_ *)soap_instantiate___ns3__union_XmlSchemaComplexContentRestriction_(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaComplexContentRestriction_ ** p = (__ns3__union_XmlSchemaComplexContentRestriction_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_, sizeof(__ns3__union_XmlSchemaComplexContentRestriction_), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaComplexContentRestriction_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_);
	if (soap_out_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(soap, tag?tag:"-ns3:union-XmlSchemaComplexContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexContentRestriction_ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(struct soap *soap, __ns3__union_XmlSchemaComplexContentRestriction_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaComplexContentRestriction_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaComplexContentExtension(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension))
		soap_serialize_xsd__XmlSchemaComplexContentExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaComplexContentExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaComplexContentExtension(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaComplexContentExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaComplexContentExtension, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaComplexContentExtension(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentExtension);
	if (soap_out_PointerToxsd__XmlSchemaComplexContentExtension(soap, tag?tag:"xsd:XmlSchemaComplexContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaComplexContentExtension(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaComplexContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaComplexContentRestriction(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction))
		soap_serialize_xsd__XmlSchemaComplexContentRestriction(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaComplexContentRestriction(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaComplexContentRestriction(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaComplexContentRestriction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaComplexContentRestriction(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaComplexContentRestriction);
	if (soap_out_PointerToxsd__XmlSchemaComplexContentRestriction(soap, tag?tag:"xsd:XmlSchemaComplexContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaComplexContentRestriction(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaComplexContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleContentExtension(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension))
		soap_serialize_xsd__XmlSchemaSimpleContentExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleContentExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleContentExtension(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleContentExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleContentExtension(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentExtension);
	if (soap_out_PointerToxsd__XmlSchemaSimpleContentExtension(soap, tag?tag:"xsd:XmlSchemaSimpleContentExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleContentExtension(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleContentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleContentRestriction(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction))
		soap_serialize_xsd__XmlSchemaSimpleContentRestriction(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleContentRestriction(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleContentRestriction(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleContentRestriction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleContentRestriction(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContentRestriction);
	if (soap_out_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, tag?tag:"xsd:XmlSchemaSimpleContentRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleContentRestriction(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleContentRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaComplexType__(struct soap *soap, __ns3__union_XmlSchemaComplexType__ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaComplexType__))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaComplexType__(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaComplexType__ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaComplexType__);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexType__ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaComplexType__(struct soap *soap, const char *tag, __ns3__union_XmlSchemaComplexType__ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaComplexType__ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaComplexType__ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaComplexType__ *)soap_instantiate___ns3__union_XmlSchemaComplexType__(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaComplexType__ ** p = (__ns3__union_XmlSchemaComplexType__ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaComplexType__, sizeof(__ns3__union_XmlSchemaComplexType__), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaComplexType__(struct soap *soap, __ns3__union_XmlSchemaComplexType__ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaComplexType__);
	if (soap_out_PointerTo__ns3__union_XmlSchemaComplexType__(soap, tag?tag:"-ns3:union-XmlSchemaComplexType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaComplexType__ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaComplexType__(struct soap *soap, __ns3__union_XmlSchemaComplexType__ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaComplexType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAll(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAll))
		soap_serialize_xsd__XmlSchemaAll(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAll(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAll);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAll(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAll(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAll(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAll, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAll(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAll);
	if (soap_out_PointerToxsd__XmlSchemaAll(soap, tag?tag:"xsd:XmlSchemaAll", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAll(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaChoice(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaChoice))
		soap_serialize_xsd__XmlSchemaChoice(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaChoice(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaChoice);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaChoice(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaChoice(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaChoice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaChoice, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaChoice(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaChoice);
	if (soap_out_PointerToxsd__XmlSchemaChoice(soap, tag?tag:"xsd:XmlSchemaChoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaChoice(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSequence(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSequence))
		soap_serialize_xsd__XmlSchemaSequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSequence(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSequence);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSequence(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSequence, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSequence(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSequence);
	if (soap_out_PointerToxsd__XmlSchemaSequence(soap, tag?tag:"xsd:XmlSchemaSequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSequence(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaGroupRef(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaGroupRef))
		soap_serialize_xsd__XmlSchemaGroupRef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaGroupRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaGroupRef);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaGroupRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaGroupRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaGroupRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaGroupRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaGroupRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaGroupRef);
	if (soap_out_PointerToxsd__XmlSchemaGroupRef(soap, tag?tag:"xsd:XmlSchemaGroupRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaGroupRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaComplexContent(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaComplexContent))
		soap_serialize_xsd__XmlSchemaComplexContent(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaComplexContent(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaComplexContent);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaComplexContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaComplexContent(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaComplexContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaComplexContent, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaComplexContent(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaComplexContent);
	if (soap_out_PointerToxsd__XmlSchemaComplexContent(soap, tag?tag:"xsd:XmlSchemaComplexContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaComplexContent(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaComplexContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleContent(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleContent))
		soap_serialize_xsd__XmlSchemaSimpleContent(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleContent(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleContent);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleContent(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleContent, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleContent(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleContent);
	if (soap_out_PointerToxsd__XmlSchemaSimpleContent(soap, tag?tag:"xsd:XmlSchemaSimpleContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleContent(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction))
		soap_serialize_xsd__XmlSchemaSimpleTypeRestriction(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleTypeRestriction(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleTypeRestriction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeRestriction);
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, tag?tag:"xsd:XmlSchemaSimpleTypeRestriction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleTypeRestriction(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleTypeRestriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleTypeList(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList))
		soap_serialize_xsd__XmlSchemaSimpleTypeList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleTypeList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleTypeList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleTypeList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeList, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleTypeList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeList);
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeList(soap, tag?tag:"xsd:XmlSchemaSimpleTypeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleTypeList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleTypeUnion(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion))
		soap_serialize_xsd__XmlSchemaSimpleTypeUnion(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleTypeUnion(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleTypeUnion(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleTypeUnion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleTypeUnion(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleTypeUnion);
	if (soap_out_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, tag?tag:"xsd:XmlSchemaSimpleTypeUnion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleTypeUnion(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleTypeUnion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaUse(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaUse))
		soap_serialize_xsd__XmlSchemaUse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaUse(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaUse);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaUse(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaUse(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaUse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaUse, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaUse(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaUse);
	if (soap_out_PointerToxsd__XmlSchemaUse(soap, tag?tag:"xsd:XmlSchemaUse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaUse(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaUse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
	if (soap_out_PointerToxsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAnyAttribute(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAnyAttribute))
		soap_serialize_xsd__XmlSchemaAnyAttribute(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAnyAttribute);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAnyAttribute(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAnyAttribute(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAnyAttribute(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAnyAttribute, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAnyAttribute(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAnyAttribute);
	if (soap_out_PointerToxsd__XmlSchemaAnyAttribute(soap, tag?tag:"xsd:XmlSchemaAnyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAnyAttribute(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAnyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaAttributeGroup(struct soap *soap, __ns3__union_XmlSchemaAttributeGroup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaAttributeGroup(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaAttributeGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAttributeGroup ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaAttributeGroup(struct soap *soap, const char *tag, __ns3__union_XmlSchemaAttributeGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaAttributeGroup **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaAttributeGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaAttributeGroup *)soap_instantiate___ns3__union_XmlSchemaAttributeGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaAttributeGroup ** p = (__ns3__union_XmlSchemaAttributeGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup, sizeof(__ns3__union_XmlSchemaAttributeGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaAttributeGroup(struct soap *soap, __ns3__union_XmlSchemaAttributeGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaAttributeGroup);
	if (soap_out_PointerTo__ns3__union_XmlSchemaAttributeGroup(soap, tag?tag:"-ns3:union-XmlSchemaAttributeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAttributeGroup ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaAttributeGroup(struct soap *soap, __ns3__union_XmlSchemaAttributeGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaAttributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAttributeGroupRef(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef))
		soap_serialize_xsd__XmlSchemaAttributeGroupRef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAttributeGroupRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAttributeGroupRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAttributeGroupRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroupRef);
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroupRef(soap, tag?tag:"xsd:XmlSchemaAttributeGroupRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAttributeGroupRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAttributeGroupRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xml__lang);
	if (soap_out_PointerTo_xml__lang(soap, tag?tag:"xml:lang", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchemaAnnotation(struct soap *soap, __ns3__union_XmlSchemaAnnotation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchemaAnnotation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchemaAnnotation(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchemaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchemaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAnnotation ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchemaAnnotation(struct soap *soap, const char *tag, __ns3__union_XmlSchemaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchemaAnnotation **)soap_malloc(soap, sizeof(__ns3__union_XmlSchemaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchemaAnnotation *)soap_instantiate___ns3__union_XmlSchemaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchemaAnnotation ** p = (__ns3__union_XmlSchemaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchemaAnnotation, sizeof(__ns3__union_XmlSchemaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchemaAnnotation(struct soap *soap, __ns3__union_XmlSchemaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchemaAnnotation);
	if (soap_out_PointerTo__ns3__union_XmlSchemaAnnotation(soap, tag?tag:"-ns3:union-XmlSchemaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchemaAnnotation ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchemaAnnotation(struct soap *soap, __ns3__union_XmlSchemaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchemaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAppInfo(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAppInfo))
		soap_serialize_xsd__XmlSchemaAppInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAppInfo(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAppInfo);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAppInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAppInfo(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAppInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAppInfo, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAppInfo(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAppInfo);
	if (soap_out_PointerToxsd__XmlSchemaAppInfo(soap, tag?tag:"xsd:XmlSchemaAppInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAppInfo(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAppInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaDocumentation(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaDocumentation))
		soap_serialize_xsd__XmlSchemaDocumentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaDocumentation(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaDocumentation);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaDocumentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaDocumentation(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaDocumentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaDocumentation, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaDocumentation(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaDocumentation);
	if (soap_out_PointerToxsd__XmlSchemaDocumentation(soap, tag?tag:"xsd:XmlSchemaDocumentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaDocumentation(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaDocumentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__token);
	if (soap_out_PointerToxsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaDerivationMethod(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaDerivationMethod))
		soap_serialize_xsd__XmlSchemaDerivationMethod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaDerivationMethod);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaDerivationMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaDerivationMethod(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaDerivationMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaDerivationMethod, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaDerivationMethod(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaDerivationMethod);
	if (soap_out_PointerToxsd__XmlSchemaDerivationMethod(soap, tag?tag:"xsd:XmlSchemaDerivationMethod", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaDerivationMethod(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaDerivationMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaForm(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaForm))
		soap_serialize_xsd__XmlSchemaForm(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaForm(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaForm);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaForm(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaForm(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaForm(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaForm, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaForm(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaForm);
	if (soap_out_PointerToxsd__XmlSchemaForm(soap, tag?tag:"xsd:XmlSchemaForm", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaForm(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaForm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchema_(struct soap *soap, __ns3__union_XmlSchema_ *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchema_))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchema_(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchema_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchema_);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema_ ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchema_(struct soap *soap, const char *tag, __ns3__union_XmlSchema_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchema_ **)soap_malloc(soap, sizeof(__ns3__union_XmlSchema_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchema_ *)soap_instantiate___ns3__union_XmlSchema_(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchema_ ** p = (__ns3__union_XmlSchema_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchema_, sizeof(__ns3__union_XmlSchema_), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchema_(struct soap *soap, __ns3__union_XmlSchema_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchema_);
	if (soap_out_PointerTo__ns3__union_XmlSchema_(soap, tag?tag:"-ns3:union-XmlSchema", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchema_ ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchema_(struct soap *soap, __ns3__union_XmlSchema_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchema_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaElement(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaElement))
		soap_serialize_xsd__XmlSchemaElement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaElement(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaElement);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaElement(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaElement, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaElement(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaElement);
	if (soap_out_PointerToxsd__XmlSchemaElement(soap, tag?tag:"xsd:XmlSchemaElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaElement(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaSimpleType(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaSimpleType))
		soap_serialize_xsd__XmlSchemaSimpleType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaSimpleType);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaSimpleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaSimpleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaSimpleType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaSimpleType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaSimpleType);
	if (soap_out_PointerToxsd__XmlSchemaSimpleType(soap, tag?tag:"xsd:XmlSchemaSimpleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaSimpleType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaSimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaComplexType(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaComplexType))
		soap_serialize_xsd__XmlSchemaComplexType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaComplexType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaComplexType);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaComplexType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaComplexType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaComplexType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaComplexType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaComplexType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaComplexType);
	if (soap_out_PointerToxsd__XmlSchemaComplexType(soap, tag?tag:"xsd:XmlSchemaComplexType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaComplexType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaComplexType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAttributeGroup(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAttributeGroup))
		soap_serialize_xsd__XmlSchemaAttributeGroup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAttributeGroup);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAttributeGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAttributeGroup(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAttributeGroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAttributeGroup, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAttributeGroup(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAttributeGroup);
	if (soap_out_PointerToxsd__XmlSchemaAttributeGroup(soap, tag?tag:"xsd:XmlSchemaAttributeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAttributeGroup(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAttributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAttribute(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAttribute))
		soap_serialize_xsd__XmlSchemaAttribute(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAttribute(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAttribute);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAttribute(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAttribute(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAttribute(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAttribute, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAttribute(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAttribute);
	if (soap_out_PointerToxsd__XmlSchemaAttribute(soap, tag?tag:"xsd:XmlSchemaAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAttribute(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaAnnotation(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaAnnotation))
		soap_serialize_xsd__XmlSchemaAnnotation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaAnnotation(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaAnnotation);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaAnnotation(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaAnnotation(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaAnnotation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaAnnotation, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaAnnotation(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaAnnotation);
	if (soap_out_PointerToxsd__XmlSchemaAnnotation(soap, tag?tag:"xsd:XmlSchemaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaAnnotation(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaGroup(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaGroup))
		soap_serialize_xsd__XmlSchemaGroup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaGroup(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaGroup);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaGroup(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaGroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaGroup, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaGroup(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaGroup);
	if (soap_out_PointerToxsd__XmlSchemaGroup(soap, tag?tag:"xsd:XmlSchemaGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaGroup(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaNotation(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaNotation))
		soap_serialize_xsd__XmlSchemaNotation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaNotation(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaNotation);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaNotation(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaNotation(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaNotation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaNotation, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaNotation(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaNotation);
	if (soap_out_PointerToxsd__XmlSchemaNotation(soap, tag?tag:"xsd:XmlSchemaNotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaNotation(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaNotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns3__union_XmlSchema(struct soap *soap, __ns3__union_XmlSchema *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns3__union_XmlSchema))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns3__union_XmlSchema(struct soap *soap, const char *tag, int id, __ns3__union_XmlSchema *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns3__union_XmlSchema);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns3__union_XmlSchema ** SOAP_FMAC4 soap_in_PointerTo__ns3__union_XmlSchema(struct soap *soap, const char *tag, __ns3__union_XmlSchema **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns3__union_XmlSchema **)soap_malloc(soap, sizeof(__ns3__union_XmlSchema *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns3__union_XmlSchema *)soap_instantiate___ns3__union_XmlSchema(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns3__union_XmlSchema ** p = (__ns3__union_XmlSchema **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns3__union_XmlSchema, sizeof(__ns3__union_XmlSchema), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns3__union_XmlSchema(struct soap *soap, __ns3__union_XmlSchema *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns3__union_XmlSchema);
	if (soap_out_PointerTo__ns3__union_XmlSchema(soap, tag?tag:"-ns3:union-XmlSchema", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns3__union_XmlSchema ** SOAP_FMAC4 soap_get_PointerTo__ns3__union_XmlSchema(struct soap *soap, __ns3__union_XmlSchema **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns3__union_XmlSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaImport(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaImport))
		soap_serialize_xsd__XmlSchemaImport(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaImport(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaImport);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaImport(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaImport(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaImport(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaImport, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaImport(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaImport);
	if (soap_out_PointerToxsd__XmlSchemaImport(soap, tag?tag:"xsd:XmlSchemaImport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaImport(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaImport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaRedefine(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaRedefine))
		soap_serialize_xsd__XmlSchemaRedefine(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaRedefine(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaRedefine);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaRedefine(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaRedefine(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaRedefine(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaRedefine, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaRedefine(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaRedefine);
	if (soap_out_PointerToxsd__XmlSchemaRedefine(soap, tag?tag:"xsd:XmlSchemaRedefine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaRedefine(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaRedefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__XmlSchemaInclude(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__XmlSchemaInclude))
		soap_serialize_xsd__XmlSchemaInclude(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__XmlSchemaInclude(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__XmlSchemaInclude);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__XmlSchemaInclude(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__XmlSchemaInclude(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__XmlSchemaInclude(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__XmlSchemaInclude, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__XmlSchemaInclude(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__XmlSchemaInclude);
	if (soap_out_PointerToxsd__XmlSchemaInclude(soap, tag?tag:"xsd:XmlSchemaInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__XmlSchemaInclude(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__XmlSchemaInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UsernameTokenElement(struct soap *soap, ns6__UsernameTokenElement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UsernameTokenElement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UsernameTokenElement(struct soap *soap, const char *tag, int id, ns6__UsernameTokenElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UsernameTokenElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__UsernameTokenElement ** SOAP_FMAC4 soap_in_PointerTons6__UsernameTokenElement(struct soap *soap, const char *tag, ns6__UsernameTokenElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UsernameTokenElement **)soap_malloc(soap, sizeof(ns6__UsernameTokenElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UsernameTokenElement *)soap_instantiate_ns6__UsernameTokenElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__UsernameTokenElement ** p = (ns6__UsernameTokenElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UsernameTokenElement, sizeof(ns6__UsernameTokenElement), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UsernameTokenElement(struct soap *soap, ns6__UsernameTokenElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__UsernameTokenElement);
	if (soap_out_PointerTons6__UsernameTokenElement(soap, tag?tag:"ns6:UsernameTokenElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UsernameTokenElement ** SOAP_FMAC4 soap_get_PointerTons6__UsernameTokenElement(struct soap *soap, ns6__UsernameTokenElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UsernameTokenElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__HierarchyInfo(struct soap *soap, ns5__HierarchyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__HierarchyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__HierarchyInfo(struct soap *soap, const char *tag, int id, ns5__HierarchyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__HierarchyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__HierarchyInfo ** SOAP_FMAC4 soap_in_PointerTons5__HierarchyInfo(struct soap *soap, const char *tag, ns5__HierarchyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__HierarchyInfo **)soap_malloc(soap, sizeof(ns5__HierarchyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__HierarchyInfo *)soap_instantiate_ns5__HierarchyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__HierarchyInfo ** p = (ns5__HierarchyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__HierarchyInfo, sizeof(ns5__HierarchyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__HierarchyInfo(struct soap *soap, ns5__HierarchyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__HierarchyInfo);
	if (soap_out_PointerTons5__HierarchyInfo(soap, tag?tag:"ns5:HierarchyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__HierarchyInfo ** SOAP_FMAC4 soap_get_PointerTons5__HierarchyInfo(struct soap *soap, ns5__HierarchyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__AxisInfo(struct soap *soap, ns5__AxisInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__AxisInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__AxisInfo(struct soap *soap, const char *tag, int id, ns5__AxisInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__AxisInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__AxisInfo ** SOAP_FMAC4 soap_in_PointerTons5__AxisInfo(struct soap *soap, const char *tag, ns5__AxisInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__AxisInfo **)soap_malloc(soap, sizeof(ns5__AxisInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__AxisInfo *)soap_instantiate_ns5__AxisInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__AxisInfo ** p = (ns5__AxisInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AxisInfo, sizeof(ns5__AxisInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__AxisInfo(struct soap *soap, ns5__AxisInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__AxisInfo);
	if (soap_out_PointerTons5__AxisInfo(soap, tag?tag:"ns5:AxisInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__AxisInfo ** SOAP_FMAC4 soap_get_PointerTons5__AxisInfo(struct soap *soap, ns5__AxisInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Cube(struct soap *soap, ns5__Cube *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Cube))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Cube(struct soap *soap, const char *tag, int id, ns5__Cube *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Cube);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Cube ** SOAP_FMAC4 soap_in_PointerTons5__Cube(struct soap *soap, const char *tag, ns5__Cube **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Cube **)soap_malloc(soap, sizeof(ns5__Cube *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Cube *)soap_instantiate_ns5__Cube(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Cube ** p = (ns5__Cube **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Cube, sizeof(ns5__Cube), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Cube(struct soap *soap, ns5__Cube *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Cube);
	if (soap_out_PointerTons5__Cube(soap, tag?tag:"ns5:Cube", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Cube ** SOAP_FMAC4 soap_get_PointerTons5__Cube(struct soap *soap, ns5__Cube **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CellInfo(struct soap *soap, ns5__CellInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CellInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CellInfo(struct soap *soap, const char *tag, int id, ns5__CellInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CellInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CellInfo ** SOAP_FMAC4 soap_in_PointerTons5__CellInfo(struct soap *soap, const char *tag, ns5__CellInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__CellInfo **)soap_malloc(soap, sizeof(ns5__CellInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__CellInfo *)soap_instantiate_ns5__CellInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__CellInfo ** p = (ns5__CellInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CellInfo, sizeof(ns5__CellInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CellInfo(struct soap *soap, ns5__CellInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CellInfo);
	if (soap_out_PointerTons5__CellInfo(soap, tag?tag:"ns5:CellInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CellInfo ** SOAP_FMAC4 soap_get_PointerTons5__CellInfo(struct soap *soap, ns5__CellInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__AxesInfo(struct soap *soap, ns5__AxesInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__AxesInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__AxesInfo(struct soap *soap, const char *tag, int id, ns5__AxesInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__AxesInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__AxesInfo ** SOAP_FMAC4 soap_in_PointerTons5__AxesInfo(struct soap *soap, const char *tag, ns5__AxesInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__AxesInfo **)soap_malloc(soap, sizeof(ns5__AxesInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__AxesInfo *)soap_instantiate_ns5__AxesInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__AxesInfo ** p = (ns5__AxesInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AxesInfo, sizeof(ns5__AxesInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__AxesInfo(struct soap *soap, ns5__AxesInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__AxesInfo);
	if (soap_out_PointerTons5__AxesInfo(soap, tag?tag:"ns5:AxesInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__AxesInfo ** SOAP_FMAC4 soap_get_PointerTons5__AxesInfo(struct soap *soap, ns5__AxesInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CubeInfo(struct soap *soap, ns5__CubeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CubeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CubeInfo(struct soap *soap, const char *tag, int id, ns5__CubeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CubeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CubeInfo ** SOAP_FMAC4 soap_in_PointerTons5__CubeInfo(struct soap *soap, const char *tag, ns5__CubeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__CubeInfo **)soap_malloc(soap, sizeof(ns5__CubeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__CubeInfo *)soap_instantiate_ns5__CubeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__CubeInfo ** p = (ns5__CubeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CubeInfo, sizeof(ns5__CubeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CubeInfo(struct soap *soap, ns5__CubeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CubeInfo);
	if (soap_out_PointerTons5__CubeInfo(soap, tag?tag:"ns5:CubeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CubeInfo ** SOAP_FMAC4 soap_get_PointerTons5__CubeInfo(struct soap *soap, ns5__CubeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Members(struct soap *soap, ns5__Members *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Members))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Members(struct soap *soap, const char *tag, int id, ns5__Members *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Members);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Members ** SOAP_FMAC4 soap_in_PointerTons5__Members(struct soap *soap, const char *tag, ns5__Members **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Members **)soap_malloc(soap, sizeof(ns5__Members *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Members *)soap_instantiate_ns5__Members(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Members ** p = (ns5__Members **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Members, sizeof(ns5__Members), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Members(struct soap *soap, ns5__Members *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Members);
	if (soap_out_PointerTons5__Members(soap, tag?tag:"ns5:Members", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Members ** SOAP_FMAC4 soap_get_PointerTons5__Members(struct soap *soap, ns5__Members **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Member(struct soap *soap, ns5__Member *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Member))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Member(struct soap *soap, const char *tag, int id, ns5__Member *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Member);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Member ** SOAP_FMAC4 soap_in_PointerTons5__Member(struct soap *soap, const char *tag, ns5__Member **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Member **)soap_malloc(soap, sizeof(ns5__Member *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Member *)soap_instantiate_ns5__Member(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Member ** p = (ns5__Member **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Member, sizeof(ns5__Member), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Member(struct soap *soap, ns5__Member *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Member);
	if (soap_out_PointerTons5__Member(soap, tag?tag:"ns5:Member", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Member ** SOAP_FMAC4 soap_get_PointerTons5__Member(struct soap *soap, ns5__Member **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Tuple(struct soap *soap, ns5__Tuple *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Tuple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Tuple(struct soap *soap, const char *tag, int id, ns5__Tuple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Tuple);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Tuple ** SOAP_FMAC4 soap_in_PointerTons5__Tuple(struct soap *soap, const char *tag, ns5__Tuple **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Tuple **)soap_malloc(soap, sizeof(ns5__Tuple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Tuple *)soap_instantiate_ns5__Tuple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Tuple ** p = (ns5__Tuple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Tuple, sizeof(ns5__Tuple), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Tuple(struct soap *soap, ns5__Tuple *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Tuple);
	if (soap_out_PointerTons5__Tuple(soap, tag?tag:"ns5:Tuple", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Tuple ** SOAP_FMAC4 soap_get_PointerTons5__Tuple(struct soap *soap, ns5__Tuple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns5__union_Axis(struct soap *soap, __ns5__union_Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns5__union_Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns5__union_Axis(struct soap *soap, const char *tag, int id, __ns5__union_Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns5__union_Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns5__union_Axis ** SOAP_FMAC4 soap_in_PointerTo__ns5__union_Axis(struct soap *soap, const char *tag, __ns5__union_Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns5__union_Axis **)soap_malloc(soap, sizeof(__ns5__union_Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns5__union_Axis *)soap_instantiate___ns5__union_Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns5__union_Axis ** p = (__ns5__union_Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns5__union_Axis, sizeof(__ns5__union_Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns5__union_Axis(struct soap *soap, __ns5__union_Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns5__union_Axis);
	if (soap_out_PointerTo__ns5__union_Axis(soap, tag?tag:"-ns5:union-Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns5__union_Axis ** SOAP_FMAC4 soap_get_PointerTo__ns5__union_Axis(struct soap *soap, __ns5__union_Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns5__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CrossProduct(struct soap *soap, ns5__CrossProduct *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CrossProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CrossProduct(struct soap *soap, const char *tag, int id, ns5__CrossProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CrossProduct);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CrossProduct ** SOAP_FMAC4 soap_in_PointerTons5__CrossProduct(struct soap *soap, const char *tag, ns5__CrossProduct **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__CrossProduct **)soap_malloc(soap, sizeof(ns5__CrossProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__CrossProduct *)soap_instantiate_ns5__CrossProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__CrossProduct ** p = (ns5__CrossProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CrossProduct, sizeof(ns5__CrossProduct), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CrossProduct(struct soap *soap, ns5__CrossProduct *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CrossProduct);
	if (soap_out_PointerTons5__CrossProduct(soap, tag?tag:"ns5:CrossProduct", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CrossProduct ** SOAP_FMAC4 soap_get_PointerTons5__CrossProduct(struct soap *soap, ns5__CrossProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Tuples(struct soap *soap, ns5__Tuples *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Tuples))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Tuples(struct soap *soap, const char *tag, int id, ns5__Tuples *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Tuples);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Tuples ** SOAP_FMAC4 soap_in_PointerTons5__Tuples(struct soap *soap, const char *tag, ns5__Tuples **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Tuples **)soap_malloc(soap, sizeof(ns5__Tuples *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Tuples *)soap_instantiate_ns5__Tuples(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Tuples ** p = (ns5__Tuples **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Tuples, sizeof(ns5__Tuples), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Tuples(struct soap *soap, ns5__Tuples *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Tuples);
	if (soap_out_PointerTons5__Tuples(soap, tag?tag:"ns5:Tuples", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Tuples ** SOAP_FMAC4 soap_get_PointerTons5__Tuples(struct soap *soap, ns5__Tuples **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Axis(struct soap *soap, ns5__Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Axis(struct soap *soap, const char *tag, int id, ns5__Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Axis ** SOAP_FMAC4 soap_in_PointerTons5__Axis(struct soap *soap, const char *tag, ns5__Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Axis **)soap_malloc(soap, sizeof(ns5__Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Axis *)soap_instantiate_ns5__Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Axis ** p = (ns5__Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Axis, sizeof(ns5__Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Axis(struct soap *soap, ns5__Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Axis);
	if (soap_out_PointerTons5__Axis(soap, tag?tag:"ns5:Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Axis ** SOAP_FMAC4 soap_get_PointerTons5__Axis(struct soap *soap, ns5__Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Cell(struct soap *soap, ns5__Cell *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Cell))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Cell(struct soap *soap, const char *tag, int id, ns5__Cell *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Cell);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Cell ** SOAP_FMAC4 soap_in_PointerTons5__Cell(struct soap *soap, const char *tag, ns5__Cell **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Cell **)soap_malloc(soap, sizeof(ns5__Cell *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Cell *)soap_instantiate_ns5__Cell(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Cell ** p = (ns5__Cell **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Cell, sizeof(ns5__Cell), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Cell(struct soap *soap, ns5__Cell *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Cell);
	if (soap_out_PointerTons5__Cell(soap, tag?tag:"ns5:Cell", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Cell ** SOAP_FMAC4 soap_get_PointerTons5__Cell(struct soap *soap, ns5__Cell **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns5__union_ResultXmlRoot(struct soap *soap, __ns5__union_ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns5__union_ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns5__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, __ns5__union_ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns5__union_ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns5__union_ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTo__ns5__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns5__union_ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns5__union_ResultXmlRoot **)soap_malloc(soap, sizeof(__ns5__union_ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns5__union_ResultXmlRoot *)soap_instantiate___ns5__union_ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns5__union_ResultXmlRoot ** p = (__ns5__union_ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns5__union_ResultXmlRoot, sizeof(__ns5__union_ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns5__union_ResultXmlRoot(struct soap *soap, __ns5__union_ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns5__union_ResultXmlRoot);
	if (soap_out_PointerTo__ns5__union_ResultXmlRoot(soap, tag?tag:"-ns5:union-ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns5__union_ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTo__ns5__union_ResultXmlRoot(struct soap *soap, __ns5__union_ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns5__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__OlapInfo(struct soap *soap, ns5__OlapInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__OlapInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__OlapInfo(struct soap *soap, const char *tag, int id, ns5__OlapInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__OlapInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__OlapInfo ** SOAP_FMAC4 soap_in_PointerTons5__OlapInfo(struct soap *soap, const char *tag, ns5__OlapInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__OlapInfo **)soap_malloc(soap, sizeof(ns5__OlapInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__OlapInfo *)soap_instantiate_ns5__OlapInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__OlapInfo ** p = (ns5__OlapInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__OlapInfo, sizeof(ns5__OlapInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__OlapInfo(struct soap *soap, ns5__OlapInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__OlapInfo);
	if (soap_out_PointerTons5__OlapInfo(soap, tag?tag:"ns5:OlapInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__OlapInfo ** SOAP_FMAC4 soap_get_PointerTons5__OlapInfo(struct soap *soap, ns5__OlapInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Row(struct soap *soap, ns5__Row *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Row))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Row(struct soap *soap, const char *tag, int id, ns5__Row *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Row);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Row ** SOAP_FMAC4 soap_in_PointerTons5__Row(struct soap *soap, const char *tag, ns5__Row **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Row **)soap_malloc(soap, sizeof(ns5__Row *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Row *)soap_instantiate_ns5__Row(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Row ** p = (ns5__Row **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Row, sizeof(ns5__Row), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Row(struct soap *soap, ns5__Row *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Row);
	if (soap_out_PointerTons5__Row(soap, tag?tag:"ns5:Row", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Row ** SOAP_FMAC4 soap_get_PointerTons5__Row(struct soap *soap, ns5__Row **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Row(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Axes(struct soap *soap, ns5__Axes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Axes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Axes(struct soap *soap, const char *tag, int id, ns5__Axes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Axes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__Axes ** SOAP_FMAC4 soap_in_PointerTons5__Axes(struct soap *soap, const char *tag, ns5__Axes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Axes **)soap_malloc(soap, sizeof(ns5__Axes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Axes *)soap_instantiate_ns5__Axes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__Axes ** p = (ns5__Axes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Axes, sizeof(ns5__Axes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Axes(struct soap *soap, ns5__Axes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Axes);
	if (soap_out_PointerTons5__Axes(soap, tag?tag:"ns5:Axes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Axes ** SOAP_FMAC4 soap_get_PointerTons5__Axes(struct soap *soap, ns5__Axes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CellData(struct soap *soap, ns5__CellData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CellData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CellData(struct soap *soap, const char *tag, int id, ns5__CellData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CellData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CellData ** SOAP_FMAC4 soap_in_PointerTons5__CellData(struct soap *soap, const char *tag, ns5__CellData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__CellData **)soap_malloc(soap, sizeof(ns5__CellData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__CellData *)soap_instantiate_ns5__CellData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__CellData ** p = (ns5__CellData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CellData, sizeof(ns5__CellData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CellData(struct soap *soap, ns5__CellData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CellData);
	if (soap_out_PointerTons5__CellData(soap, tag?tag:"ns5:CellData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CellData ** SOAP_FMAC4 soap_get_PointerTons5__CellData(struct soap *soap, ns5__CellData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__HierarchyInfo(struct soap *soap, ns4__HierarchyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__HierarchyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__HierarchyInfo(struct soap *soap, const char *tag, int id, ns4__HierarchyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__HierarchyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__HierarchyInfo ** SOAP_FMAC4 soap_in_PointerTons4__HierarchyInfo(struct soap *soap, const char *tag, ns4__HierarchyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__HierarchyInfo **)soap_malloc(soap, sizeof(ns4__HierarchyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__HierarchyInfo *)soap_instantiate_ns4__HierarchyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__HierarchyInfo ** p = (ns4__HierarchyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__HierarchyInfo, sizeof(ns4__HierarchyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__HierarchyInfo(struct soap *soap, ns4__HierarchyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__HierarchyInfo);
	if (soap_out_PointerTons4__HierarchyInfo(soap, tag?tag:"ns4:HierarchyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__HierarchyInfo ** SOAP_FMAC4 soap_get_PointerTons4__HierarchyInfo(struct soap *soap, ns4__HierarchyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__AxisInfo(struct soap *soap, ns4__AxisInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__AxisInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__AxisInfo(struct soap *soap, const char *tag, int id, ns4__AxisInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__AxisInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__AxisInfo ** SOAP_FMAC4 soap_in_PointerTons4__AxisInfo(struct soap *soap, const char *tag, ns4__AxisInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__AxisInfo **)soap_malloc(soap, sizeof(ns4__AxisInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__AxisInfo *)soap_instantiate_ns4__AxisInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__AxisInfo ** p = (ns4__AxisInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AxisInfo, sizeof(ns4__AxisInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__AxisInfo(struct soap *soap, ns4__AxisInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__AxisInfo);
	if (soap_out_PointerTons4__AxisInfo(soap, tag?tag:"ns4:AxisInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__AxisInfo ** SOAP_FMAC4 soap_get_PointerTons4__AxisInfo(struct soap *soap, ns4__AxisInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Cube(struct soap *soap, ns4__Cube *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Cube))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Cube(struct soap *soap, const char *tag, int id, ns4__Cube *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Cube);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Cube ** SOAP_FMAC4 soap_in_PointerTons4__Cube(struct soap *soap, const char *tag, ns4__Cube **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Cube **)soap_malloc(soap, sizeof(ns4__Cube *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Cube *)soap_instantiate_ns4__Cube(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Cube ** p = (ns4__Cube **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Cube, sizeof(ns4__Cube), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Cube(struct soap *soap, ns4__Cube *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Cube);
	if (soap_out_PointerTons4__Cube(soap, tag?tag:"ns4:Cube", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Cube ** SOAP_FMAC4 soap_get_PointerTons4__Cube(struct soap *soap, ns4__Cube **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CellInfo(struct soap *soap, ns4__CellInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CellInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CellInfo(struct soap *soap, const char *tag, int id, ns4__CellInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CellInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__CellInfo ** SOAP_FMAC4 soap_in_PointerTons4__CellInfo(struct soap *soap, const char *tag, ns4__CellInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__CellInfo **)soap_malloc(soap, sizeof(ns4__CellInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__CellInfo *)soap_instantiate_ns4__CellInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__CellInfo ** p = (ns4__CellInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CellInfo, sizeof(ns4__CellInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CellInfo(struct soap *soap, ns4__CellInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CellInfo);
	if (soap_out_PointerTons4__CellInfo(soap, tag?tag:"ns4:CellInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__CellInfo ** SOAP_FMAC4 soap_get_PointerTons4__CellInfo(struct soap *soap, ns4__CellInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__AxesInfo(struct soap *soap, ns4__AxesInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__AxesInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__AxesInfo(struct soap *soap, const char *tag, int id, ns4__AxesInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__AxesInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__AxesInfo ** SOAP_FMAC4 soap_in_PointerTons4__AxesInfo(struct soap *soap, const char *tag, ns4__AxesInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__AxesInfo **)soap_malloc(soap, sizeof(ns4__AxesInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__AxesInfo *)soap_instantiate_ns4__AxesInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__AxesInfo ** p = (ns4__AxesInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AxesInfo, sizeof(ns4__AxesInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__AxesInfo(struct soap *soap, ns4__AxesInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__AxesInfo);
	if (soap_out_PointerTons4__AxesInfo(soap, tag?tag:"ns4:AxesInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__AxesInfo ** SOAP_FMAC4 soap_get_PointerTons4__AxesInfo(struct soap *soap, ns4__AxesInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CubeInfo(struct soap *soap, ns4__CubeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CubeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CubeInfo(struct soap *soap, const char *tag, int id, ns4__CubeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CubeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__CubeInfo ** SOAP_FMAC4 soap_in_PointerTons4__CubeInfo(struct soap *soap, const char *tag, ns4__CubeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__CubeInfo **)soap_malloc(soap, sizeof(ns4__CubeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__CubeInfo *)soap_instantiate_ns4__CubeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__CubeInfo ** p = (ns4__CubeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CubeInfo, sizeof(ns4__CubeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CubeInfo(struct soap *soap, ns4__CubeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CubeInfo);
	if (soap_out_PointerTons4__CubeInfo(soap, tag?tag:"ns4:CubeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__CubeInfo ** SOAP_FMAC4 soap_get_PointerTons4__CubeInfo(struct soap *soap, ns4__CubeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Members(struct soap *soap, ns4__Members *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Members))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Members(struct soap *soap, const char *tag, int id, ns4__Members *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Members);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Members ** SOAP_FMAC4 soap_in_PointerTons4__Members(struct soap *soap, const char *tag, ns4__Members **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Members **)soap_malloc(soap, sizeof(ns4__Members *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Members *)soap_instantiate_ns4__Members(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Members ** p = (ns4__Members **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Members, sizeof(ns4__Members), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Members(struct soap *soap, ns4__Members *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Members);
	if (soap_out_PointerTons4__Members(soap, tag?tag:"ns4:Members", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Members ** SOAP_FMAC4 soap_get_PointerTons4__Members(struct soap *soap, ns4__Members **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Member(struct soap *soap, ns4__Member *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Member))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Member(struct soap *soap, const char *tag, int id, ns4__Member *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Member);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Member ** SOAP_FMAC4 soap_in_PointerTons4__Member(struct soap *soap, const char *tag, ns4__Member **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Member **)soap_malloc(soap, sizeof(ns4__Member *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Member *)soap_instantiate_ns4__Member(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Member ** p = (ns4__Member **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Member, sizeof(ns4__Member), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Member(struct soap *soap, ns4__Member *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Member);
	if (soap_out_PointerTons4__Member(soap, tag?tag:"ns4:Member", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Member ** SOAP_FMAC4 soap_get_PointerTons4__Member(struct soap *soap, ns4__Member **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Tuple(struct soap *soap, ns4__Tuple *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Tuple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Tuple(struct soap *soap, const char *tag, int id, ns4__Tuple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Tuple);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Tuple ** SOAP_FMAC4 soap_in_PointerTons4__Tuple(struct soap *soap, const char *tag, ns4__Tuple **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Tuple **)soap_malloc(soap, sizeof(ns4__Tuple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Tuple *)soap_instantiate_ns4__Tuple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Tuple ** p = (ns4__Tuple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Tuple, sizeof(ns4__Tuple), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Tuple(struct soap *soap, ns4__Tuple *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Tuple);
	if (soap_out_PointerTons4__Tuple(soap, tag?tag:"ns4:Tuple", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Tuple ** SOAP_FMAC4 soap_get_PointerTons4__Tuple(struct soap *soap, ns4__Tuple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns4__union_Axis(struct soap *soap, __ns4__union_Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns4__union_Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns4__union_Axis(struct soap *soap, const char *tag, int id, __ns4__union_Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns4__union_Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns4__union_Axis ** SOAP_FMAC4 soap_in_PointerTo__ns4__union_Axis(struct soap *soap, const char *tag, __ns4__union_Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns4__union_Axis **)soap_malloc(soap, sizeof(__ns4__union_Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns4__union_Axis *)soap_instantiate___ns4__union_Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns4__union_Axis ** p = (__ns4__union_Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns4__union_Axis, sizeof(__ns4__union_Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns4__union_Axis(struct soap *soap, __ns4__union_Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns4__union_Axis);
	if (soap_out_PointerTo__ns4__union_Axis(soap, tag?tag:"-ns4:union-Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns4__union_Axis ** SOAP_FMAC4 soap_get_PointerTo__ns4__union_Axis(struct soap *soap, __ns4__union_Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns4__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CrossProduct(struct soap *soap, ns4__CrossProduct *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CrossProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CrossProduct(struct soap *soap, const char *tag, int id, ns4__CrossProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CrossProduct);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__CrossProduct ** SOAP_FMAC4 soap_in_PointerTons4__CrossProduct(struct soap *soap, const char *tag, ns4__CrossProduct **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__CrossProduct **)soap_malloc(soap, sizeof(ns4__CrossProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__CrossProduct *)soap_instantiate_ns4__CrossProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__CrossProduct ** p = (ns4__CrossProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CrossProduct, sizeof(ns4__CrossProduct), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CrossProduct(struct soap *soap, ns4__CrossProduct *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CrossProduct);
	if (soap_out_PointerTons4__CrossProduct(soap, tag?tag:"ns4:CrossProduct", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__CrossProduct ** SOAP_FMAC4 soap_get_PointerTons4__CrossProduct(struct soap *soap, ns4__CrossProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Tuples(struct soap *soap, ns4__Tuples *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Tuples))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Tuples(struct soap *soap, const char *tag, int id, ns4__Tuples *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Tuples);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Tuples ** SOAP_FMAC4 soap_in_PointerTons4__Tuples(struct soap *soap, const char *tag, ns4__Tuples **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Tuples **)soap_malloc(soap, sizeof(ns4__Tuples *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Tuples *)soap_instantiate_ns4__Tuples(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Tuples ** p = (ns4__Tuples **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Tuples, sizeof(ns4__Tuples), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Tuples(struct soap *soap, ns4__Tuples *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Tuples);
	if (soap_out_PointerTons4__Tuples(soap, tag?tag:"ns4:Tuples", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Tuples ** SOAP_FMAC4 soap_get_PointerTons4__Tuples(struct soap *soap, ns4__Tuples **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Axis(struct soap *soap, ns4__Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Axis(struct soap *soap, const char *tag, int id, ns4__Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Axis ** SOAP_FMAC4 soap_in_PointerTons4__Axis(struct soap *soap, const char *tag, ns4__Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Axis **)soap_malloc(soap, sizeof(ns4__Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Axis *)soap_instantiate_ns4__Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Axis ** p = (ns4__Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Axis, sizeof(ns4__Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Axis(struct soap *soap, ns4__Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Axis);
	if (soap_out_PointerTons4__Axis(soap, tag?tag:"ns4:Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Axis ** SOAP_FMAC4 soap_get_PointerTons4__Axis(struct soap *soap, ns4__Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Cell(struct soap *soap, ns4__Cell *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Cell))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Cell(struct soap *soap, const char *tag, int id, ns4__Cell *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Cell);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Cell ** SOAP_FMAC4 soap_in_PointerTons4__Cell(struct soap *soap, const char *tag, ns4__Cell **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Cell **)soap_malloc(soap, sizeof(ns4__Cell *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Cell *)soap_instantiate_ns4__Cell(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Cell ** p = (ns4__Cell **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Cell, sizeof(ns4__Cell), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Cell(struct soap *soap, ns4__Cell *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Cell);
	if (soap_out_PointerTons4__Cell(soap, tag?tag:"ns4:Cell", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Cell ** SOAP_FMAC4 soap_get_PointerTons4__Cell(struct soap *soap, ns4__Cell **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns4__union_ResultXmlRoot(struct soap *soap, __ns4__union_ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns4__union_ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns4__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, __ns4__union_ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns4__union_ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns4__union_ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTo__ns4__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns4__union_ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns4__union_ResultXmlRoot **)soap_malloc(soap, sizeof(__ns4__union_ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns4__union_ResultXmlRoot *)soap_instantiate___ns4__union_ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns4__union_ResultXmlRoot ** p = (__ns4__union_ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns4__union_ResultXmlRoot, sizeof(__ns4__union_ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns4__union_ResultXmlRoot(struct soap *soap, __ns4__union_ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns4__union_ResultXmlRoot);
	if (soap_out_PointerTo__ns4__union_ResultXmlRoot(soap, tag?tag:"-ns4:union-ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns4__union_ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTo__ns4__union_ResultXmlRoot(struct soap *soap, __ns4__union_ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns4__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OlapInfo(struct soap *soap, ns4__OlapInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OlapInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OlapInfo(struct soap *soap, const char *tag, int id, ns4__OlapInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OlapInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__OlapInfo ** SOAP_FMAC4 soap_in_PointerTons4__OlapInfo(struct soap *soap, const char *tag, ns4__OlapInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__OlapInfo **)soap_malloc(soap, sizeof(ns4__OlapInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__OlapInfo *)soap_instantiate_ns4__OlapInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__OlapInfo ** p = (ns4__OlapInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OlapInfo, sizeof(ns4__OlapInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OlapInfo(struct soap *soap, ns4__OlapInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__OlapInfo);
	if (soap_out_PointerTons4__OlapInfo(soap, tag?tag:"ns4:OlapInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__OlapInfo ** SOAP_FMAC4 soap_get_PointerTons4__OlapInfo(struct soap *soap, ns4__OlapInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Row(struct soap *soap, ns4__Row *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Row))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Row(struct soap *soap, const char *tag, int id, ns4__Row *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Row);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Row ** SOAP_FMAC4 soap_in_PointerTons4__Row(struct soap *soap, const char *tag, ns4__Row **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Row **)soap_malloc(soap, sizeof(ns4__Row *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Row *)soap_instantiate_ns4__Row(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Row ** p = (ns4__Row **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Row, sizeof(ns4__Row), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Row(struct soap *soap, ns4__Row *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Row);
	if (soap_out_PointerTons4__Row(soap, tag?tag:"ns4:Row", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Row ** SOAP_FMAC4 soap_get_PointerTons4__Row(struct soap *soap, ns4__Row **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Row(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Axes(struct soap *soap, ns4__Axes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Axes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Axes(struct soap *soap, const char *tag, int id, ns4__Axes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Axes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Axes ** SOAP_FMAC4 soap_in_PointerTons4__Axes(struct soap *soap, const char *tag, ns4__Axes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Axes **)soap_malloc(soap, sizeof(ns4__Axes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Axes *)soap_instantiate_ns4__Axes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Axes ** p = (ns4__Axes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Axes, sizeof(ns4__Axes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Axes(struct soap *soap, ns4__Axes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Axes);
	if (soap_out_PointerTons4__Axes(soap, tag?tag:"ns4:Axes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Axes ** SOAP_FMAC4 soap_get_PointerTons4__Axes(struct soap *soap, ns4__Axes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CellData(struct soap *soap, ns4__CellData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CellData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CellData(struct soap *soap, const char *tag, int id, ns4__CellData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CellData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__CellData ** SOAP_FMAC4 soap_in_PointerTons4__CellData(struct soap *soap, const char *tag, ns4__CellData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__CellData **)soap_malloc(soap, sizeof(ns4__CellData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__CellData *)soap_instantiate_ns4__CellData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__CellData ** p = (ns4__CellData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CellData, sizeof(ns4__CellData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CellData(struct soap *soap, ns4__CellData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CellData);
	if (soap_out_PointerTons4__CellData(soap, tag?tag:"ns4:CellData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__CellData ** SOAP_FMAC4 soap_get_PointerTons4__CellData(struct soap *soap, ns4__CellData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HierarchyInfo(struct soap *soap, ns2__HierarchyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HierarchyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HierarchyInfo(struct soap *soap, const char *tag, int id, ns2__HierarchyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HierarchyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HierarchyInfo ** SOAP_FMAC4 soap_in_PointerTons2__HierarchyInfo(struct soap *soap, const char *tag, ns2__HierarchyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HierarchyInfo **)soap_malloc(soap, sizeof(ns2__HierarchyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HierarchyInfo *)soap_instantiate_ns2__HierarchyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HierarchyInfo ** p = (ns2__HierarchyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HierarchyInfo, sizeof(ns2__HierarchyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HierarchyInfo(struct soap *soap, ns2__HierarchyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HierarchyInfo);
	if (soap_out_PointerTons2__HierarchyInfo(soap, tag?tag:"ns2:HierarchyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HierarchyInfo ** SOAP_FMAC4 soap_get_PointerTons2__HierarchyInfo(struct soap *soap, ns2__HierarchyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HierarchyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AxisInfo(struct soap *soap, ns2__AxisInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AxisInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AxisInfo(struct soap *soap, const char *tag, int id, ns2__AxisInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AxisInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AxisInfo ** SOAP_FMAC4 soap_in_PointerTons2__AxisInfo(struct soap *soap, const char *tag, ns2__AxisInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AxisInfo **)soap_malloc(soap, sizeof(ns2__AxisInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AxisInfo *)soap_instantiate_ns2__AxisInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AxisInfo ** p = (ns2__AxisInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AxisInfo, sizeof(ns2__AxisInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AxisInfo(struct soap *soap, ns2__AxisInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AxisInfo);
	if (soap_out_PointerTons2__AxisInfo(soap, tag?tag:"ns2:AxisInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AxisInfo ** SOAP_FMAC4 soap_get_PointerTons2__AxisInfo(struct soap *soap, ns2__AxisInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AxisInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Cube(struct soap *soap, ns2__Cube *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Cube))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Cube(struct soap *soap, const char *tag, int id, ns2__Cube *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Cube);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Cube ** SOAP_FMAC4 soap_in_PointerTons2__Cube(struct soap *soap, const char *tag, ns2__Cube **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Cube **)soap_malloc(soap, sizeof(ns2__Cube *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Cube *)soap_instantiate_ns2__Cube(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Cube ** p = (ns2__Cube **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Cube, sizeof(ns2__Cube), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Cube(struct soap *soap, ns2__Cube *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Cube);
	if (soap_out_PointerTons2__Cube(soap, tag?tag:"ns2:Cube", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Cube ** SOAP_FMAC4 soap_get_PointerTons2__Cube(struct soap *soap, ns2__Cube **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Cube(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CellInfo(struct soap *soap, ns2__CellInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CellInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CellInfo(struct soap *soap, const char *tag, int id, ns2__CellInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CellInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CellInfo ** SOAP_FMAC4 soap_in_PointerTons2__CellInfo(struct soap *soap, const char *tag, ns2__CellInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CellInfo **)soap_malloc(soap, sizeof(ns2__CellInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CellInfo *)soap_instantiate_ns2__CellInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CellInfo ** p = (ns2__CellInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CellInfo, sizeof(ns2__CellInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CellInfo(struct soap *soap, ns2__CellInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CellInfo);
	if (soap_out_PointerTons2__CellInfo(soap, tag?tag:"ns2:CellInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CellInfo ** SOAP_FMAC4 soap_get_PointerTons2__CellInfo(struct soap *soap, ns2__CellInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CellInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AxesInfo(struct soap *soap, ns2__AxesInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AxesInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AxesInfo(struct soap *soap, const char *tag, int id, ns2__AxesInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AxesInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AxesInfo ** SOAP_FMAC4 soap_in_PointerTons2__AxesInfo(struct soap *soap, const char *tag, ns2__AxesInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AxesInfo **)soap_malloc(soap, sizeof(ns2__AxesInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AxesInfo *)soap_instantiate_ns2__AxesInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AxesInfo ** p = (ns2__AxesInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AxesInfo, sizeof(ns2__AxesInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AxesInfo(struct soap *soap, ns2__AxesInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AxesInfo);
	if (soap_out_PointerTons2__AxesInfo(soap, tag?tag:"ns2:AxesInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AxesInfo ** SOAP_FMAC4 soap_get_PointerTons2__AxesInfo(struct soap *soap, ns2__AxesInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AxesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CubeInfo(struct soap *soap, ns2__CubeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CubeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CubeInfo(struct soap *soap, const char *tag, int id, ns2__CubeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CubeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CubeInfo ** SOAP_FMAC4 soap_in_PointerTons2__CubeInfo(struct soap *soap, const char *tag, ns2__CubeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CubeInfo **)soap_malloc(soap, sizeof(ns2__CubeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CubeInfo *)soap_instantiate_ns2__CubeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CubeInfo ** p = (ns2__CubeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CubeInfo, sizeof(ns2__CubeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CubeInfo(struct soap *soap, ns2__CubeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CubeInfo);
	if (soap_out_PointerTons2__CubeInfo(soap, tag?tag:"ns2:CubeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CubeInfo ** SOAP_FMAC4 soap_get_PointerTons2__CubeInfo(struct soap *soap, ns2__CubeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CubeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Members(struct soap *soap, ns2__Members *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Members))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Members(struct soap *soap, const char *tag, int id, ns2__Members *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Members);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Members ** SOAP_FMAC4 soap_in_PointerTons2__Members(struct soap *soap, const char *tag, ns2__Members **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Members **)soap_malloc(soap, sizeof(ns2__Members *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Members *)soap_instantiate_ns2__Members(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Members ** p = (ns2__Members **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Members, sizeof(ns2__Members), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Members(struct soap *soap, ns2__Members *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Members);
	if (soap_out_PointerTons2__Members(soap, tag?tag:"ns2:Members", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Members ** SOAP_FMAC4 soap_get_PointerTons2__Members(struct soap *soap, ns2__Members **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Members(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Member(struct soap *soap, ns2__Member *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Member))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Member(struct soap *soap, const char *tag, int id, ns2__Member *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Member);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Member ** SOAP_FMAC4 soap_in_PointerTons2__Member(struct soap *soap, const char *tag, ns2__Member **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Member **)soap_malloc(soap, sizeof(ns2__Member *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Member *)soap_instantiate_ns2__Member(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Member ** p = (ns2__Member **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Member, sizeof(ns2__Member), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Member(struct soap *soap, ns2__Member *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Member);
	if (soap_out_PointerTons2__Member(soap, tag?tag:"ns2:Member", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Member ** SOAP_FMAC4 soap_get_PointerTons2__Member(struct soap *soap, ns2__Member **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Member(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Tuple(struct soap *soap, ns2__Tuple *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Tuple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Tuple(struct soap *soap, const char *tag, int id, ns2__Tuple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Tuple);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Tuple ** SOAP_FMAC4 soap_in_PointerTons2__Tuple(struct soap *soap, const char *tag, ns2__Tuple **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Tuple **)soap_malloc(soap, sizeof(ns2__Tuple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Tuple *)soap_instantiate_ns2__Tuple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Tuple ** p = (ns2__Tuple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Tuple, sizeof(ns2__Tuple), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Tuple(struct soap *soap, ns2__Tuple *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Tuple);
	if (soap_out_PointerTons2__Tuple(soap, tag?tag:"ns2:Tuple", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Tuple ** SOAP_FMAC4 soap_get_PointerTons2__Tuple(struct soap *soap, ns2__Tuple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Tuple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_Axis(struct soap *soap, __ns2__union_Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_Axis(struct soap *soap, const char *tag, int id, __ns2__union_Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_Axis ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_Axis(struct soap *soap, const char *tag, __ns2__union_Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_Axis **)soap_malloc(soap, sizeof(__ns2__union_Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_Axis *)soap_instantiate___ns2__union_Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_Axis ** p = (__ns2__union_Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_Axis, sizeof(__ns2__union_Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_Axis(struct soap *soap, __ns2__union_Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_Axis);
	if (soap_out_PointerTo__ns2__union_Axis(soap, tag?tag:"-ns2:union-Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_Axis ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_Axis(struct soap *soap, __ns2__union_Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CrossProduct(struct soap *soap, ns2__CrossProduct *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CrossProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CrossProduct(struct soap *soap, const char *tag, int id, ns2__CrossProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CrossProduct);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CrossProduct ** SOAP_FMAC4 soap_in_PointerTons2__CrossProduct(struct soap *soap, const char *tag, ns2__CrossProduct **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CrossProduct **)soap_malloc(soap, sizeof(ns2__CrossProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CrossProduct *)soap_instantiate_ns2__CrossProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CrossProduct ** p = (ns2__CrossProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CrossProduct, sizeof(ns2__CrossProduct), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CrossProduct(struct soap *soap, ns2__CrossProduct *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CrossProduct);
	if (soap_out_PointerTons2__CrossProduct(soap, tag?tag:"ns2:CrossProduct", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CrossProduct ** SOAP_FMAC4 soap_get_PointerTons2__CrossProduct(struct soap *soap, ns2__CrossProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CrossProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Tuples(struct soap *soap, ns2__Tuples *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Tuples))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Tuples(struct soap *soap, const char *tag, int id, ns2__Tuples *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Tuples);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Tuples ** SOAP_FMAC4 soap_in_PointerTons2__Tuples(struct soap *soap, const char *tag, ns2__Tuples **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Tuples **)soap_malloc(soap, sizeof(ns2__Tuples *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Tuples *)soap_instantiate_ns2__Tuples(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Tuples ** p = (ns2__Tuples **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Tuples, sizeof(ns2__Tuples), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Tuples(struct soap *soap, ns2__Tuples *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Tuples);
	if (soap_out_PointerTons2__Tuples(soap, tag?tag:"ns2:Tuples", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Tuples ** SOAP_FMAC4 soap_get_PointerTons2__Tuples(struct soap *soap, ns2__Tuples **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Tuples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Axis(struct soap *soap, ns2__Axis *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Axis))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Axis(struct soap *soap, const char *tag, int id, ns2__Axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Axis ** SOAP_FMAC4 soap_in_PointerTons2__Axis(struct soap *soap, const char *tag, ns2__Axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Axis **)soap_malloc(soap, sizeof(ns2__Axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Axis *)soap_instantiate_ns2__Axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Axis ** p = (ns2__Axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Axis, sizeof(ns2__Axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Axis(struct soap *soap, ns2__Axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Axis);
	if (soap_out_PointerTons2__Axis(soap, tag?tag:"ns2:Axis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Axis ** SOAP_FMAC4 soap_get_PointerTons2__Axis(struct soap *soap, ns2__Axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Cell(struct soap *soap, ns2__Cell *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Cell))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Cell(struct soap *soap, const char *tag, int id, ns2__Cell *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Cell);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Cell ** SOAP_FMAC4 soap_in_PointerTons2__Cell(struct soap *soap, const char *tag, ns2__Cell **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Cell **)soap_malloc(soap, sizeof(ns2__Cell *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Cell *)soap_instantiate_ns2__Cell(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Cell ** p = (ns2__Cell **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Cell, sizeof(ns2__Cell), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Cell(struct soap *soap, ns2__Cell *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Cell);
	if (soap_out_PointerTons2__Cell(soap, tag?tag:"ns2:Cell", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Cell ** SOAP_FMAC4 soap_get_PointerTons2__Cell(struct soap *soap, ns2__Cell **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Cell(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_ResultXmlRoot(struct soap *soap, __ns2__union_ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_ResultXmlRoot(struct soap *soap, const char *tag, int id, __ns2__union_ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_ResultXmlRoot(struct soap *soap, const char *tag, __ns2__union_ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_ResultXmlRoot **)soap_malloc(soap, sizeof(__ns2__union_ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_ResultXmlRoot *)soap_instantiate___ns2__union_ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_ResultXmlRoot ** p = (__ns2__union_ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_ResultXmlRoot, sizeof(__ns2__union_ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_ResultXmlRoot(struct soap *soap, __ns2__union_ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_ResultXmlRoot);
	if (soap_out_PointerTo__ns2__union_ResultXmlRoot(soap, tag?tag:"-ns2:union-ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_ResultXmlRoot(struct soap *soap, __ns2__union_ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OlapInfo(struct soap *soap, ns2__OlapInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OlapInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OlapInfo(struct soap *soap, const char *tag, int id, ns2__OlapInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OlapInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OlapInfo ** SOAP_FMAC4 soap_in_PointerTons2__OlapInfo(struct soap *soap, const char *tag, ns2__OlapInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OlapInfo **)soap_malloc(soap, sizeof(ns2__OlapInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OlapInfo *)soap_instantiate_ns2__OlapInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OlapInfo ** p = (ns2__OlapInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OlapInfo, sizeof(ns2__OlapInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OlapInfo(struct soap *soap, ns2__OlapInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OlapInfo);
	if (soap_out_PointerTons2__OlapInfo(soap, tag?tag:"ns2:OlapInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OlapInfo ** SOAP_FMAC4 soap_get_PointerTons2__OlapInfo(struct soap *soap, ns2__OlapInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OlapInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Axes(struct soap *soap, ns2__Axes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Axes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Axes(struct soap *soap, const char *tag, int id, ns2__Axes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Axes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Axes ** SOAP_FMAC4 soap_in_PointerTons2__Axes(struct soap *soap, const char *tag, ns2__Axes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Axes **)soap_malloc(soap, sizeof(ns2__Axes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Axes *)soap_instantiate_ns2__Axes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Axes ** p = (ns2__Axes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Axes, sizeof(ns2__Axes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Axes(struct soap *soap, ns2__Axes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Axes);
	if (soap_out_PointerTons2__Axes(soap, tag?tag:"ns2:Axes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Axes ** SOAP_FMAC4 soap_get_PointerTons2__Axes(struct soap *soap, ns2__Axes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Axes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CellData(struct soap *soap, ns2__CellData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CellData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CellData(struct soap *soap, const char *tag, int id, ns2__CellData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CellData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CellData ** SOAP_FMAC4 soap_in_PointerTons2__CellData(struct soap *soap, const char *tag, ns2__CellData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CellData **)soap_malloc(soap, sizeof(ns2__CellData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CellData *)soap_instantiate_ns2__CellData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CellData ** p = (ns2__CellData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CellData, sizeof(ns2__CellData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CellData(struct soap *soap, ns2__CellData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CellData);
	if (soap_out_PointerTons2__CellData(soap, tag?tag:"ns2:CellData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CellData ** SOAP_FMAC4 soap_get_PointerTons2__CellData(struct soap *soap, ns2__CellData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CellData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Restrictions(struct soap *soap, ns1__Restrictions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Restrictions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Restrictions(struct soap *soap, const char *tag, int id, ns1__Restrictions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Restrictions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Restrictions ** SOAP_FMAC4 soap_in_PointerTons1__Restrictions(struct soap *soap, const char *tag, ns1__Restrictions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Restrictions **)soap_malloc(soap, sizeof(ns1__Restrictions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Restrictions *)soap_instantiate_ns1__Restrictions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Restrictions ** p = (ns1__Restrictions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Restrictions, sizeof(ns1__Restrictions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Restrictions(struct soap *soap, ns1__Restrictions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Restrictions);
	if (soap_out_PointerTons1__Restrictions(soap, tag?tag:"ns1:Restrictions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Restrictions ** SOAP_FMAC4 soap_get_PointerTons1__Restrictions(struct soap *soap, ns1__Restrictions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Restrictions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ResultSet(struct soap *soap, ns1__ResultSet *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ResultSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ResultSet(struct soap *soap, const char *tag, int id, ns1__ResultSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ResultSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ResultSet ** SOAP_FMAC4 soap_in_PointerTons1__ResultSet(struct soap *soap, const char *tag, ns1__ResultSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ResultSet **)soap_malloc(soap, sizeof(ns1__ResultSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ResultSet *)soap_instantiate_ns1__ResultSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ResultSet ** p = (ns1__ResultSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ResultSet, sizeof(ns1__ResultSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ResultSet(struct soap *soap, ns1__ResultSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ResultSet);
	if (soap_out_PointerTons1__ResultSet(soap, tag?tag:"ns1:ResultSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ResultSet ** SOAP_FMAC4 soap_get_PointerTons1__ResultSet(struct soap *soap, ns1__ResultSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameters(struct soap *soap, const char *tag, int id, ns1__Parameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_in_PointerTons1__Parameters(struct soap *soap, const char *tag, ns1__Parameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameters **)soap_malloc(soap, sizeof(ns1__Parameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameters *)soap_instantiate_ns1__Parameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Parameters ** p = (ns1__Parameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Parameters);
	if (soap_out_PointerTons1__Parameters(soap, tag?tag:"ns1:Parameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_get_PointerTons1__Parameters(struct soap *soap, ns1__Parameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Properties(struct soap *soap, ns1__Properties *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Properties))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Properties(struct soap *soap, const char *tag, int id, ns1__Properties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Properties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Properties ** SOAP_FMAC4 soap_in_PointerTons1__Properties(struct soap *soap, const char *tag, ns1__Properties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Properties **)soap_malloc(soap, sizeof(ns1__Properties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Properties *)soap_instantiate_ns1__Properties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Properties ** p = (ns1__Properties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Properties, sizeof(ns1__Properties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Properties(struct soap *soap, ns1__Properties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Properties);
	if (soap_out_PointerTons1__Properties(soap, tag?tag:"ns1:Properties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Properties ** SOAP_FMAC4 soap_get_PointerTons1__Properties(struct soap *soap, ns1__Properties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Properties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CommandStatement(struct soap *soap, ns1__CommandStatement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CommandStatement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CommandStatement(struct soap *soap, const char *tag, int id, ns1__CommandStatement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CommandStatement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CommandStatement ** SOAP_FMAC4 soap_in_PointerTons1__CommandStatement(struct soap *soap, const char *tag, ns1__CommandStatement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CommandStatement **)soap_malloc(soap, sizeof(ns1__CommandStatement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CommandStatement *)soap_instantiate_ns1__CommandStatement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CommandStatement ** p = (ns1__CommandStatement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CommandStatement, sizeof(ns1__CommandStatement), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CommandStatement(struct soap *soap, ns1__CommandStatement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CommandStatement);
	if (soap_out_PointerTons1__CommandStatement(soap, tag?tag:"ns1:CommandStatement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CommandStatement ** SOAP_FMAC4 soap_get_PointerTons1__CommandStatement(struct soap *soap, ns1__CommandStatement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CommandStatement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RestrictionList(struct soap *soap, ns1__RestrictionList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RestrictionList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RestrictionList(struct soap *soap, const char *tag, int id, ns1__RestrictionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RestrictionList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RestrictionList ** SOAP_FMAC4 soap_in_PointerTons1__RestrictionList(struct soap *soap, const char *tag, ns1__RestrictionList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RestrictionList **)soap_malloc(soap, sizeof(ns1__RestrictionList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RestrictionList *)soap_instantiate_ns1__RestrictionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__RestrictionList ** p = (ns1__RestrictionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RestrictionList, sizeof(ns1__RestrictionList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RestrictionList(struct soap *soap, ns1__RestrictionList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RestrictionList);
	if (soap_out_PointerTons1__RestrictionList(soap, tag?tag:"ns1:RestrictionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RestrictionList ** SOAP_FMAC4 soap_get_PointerTons1__RestrictionList(struct soap *soap, ns1__RestrictionList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RestrictionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ResultXmlRoot(struct soap *soap, ns5__ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ResultXmlRoot(struct soap *soap, const char *tag, int id, ns5__ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTons5__ResultXmlRoot(struct soap *soap, const char *tag, ns5__ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ResultXmlRoot **)soap_malloc(soap, sizeof(ns5__ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ResultXmlRoot *)soap_instantiate_ns5__ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ResultXmlRoot ** p = (ns5__ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ResultXmlRoot, sizeof(ns5__ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ResultXmlRoot(struct soap *soap, ns5__ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ResultXmlRoot);
	if (soap_out_PointerTons5__ResultXmlRoot(soap, tag?tag:"ns5:ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTons5__ResultXmlRoot(struct soap *soap, ns5__ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ResultXmlRoot(struct soap *soap, ns4__ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ResultXmlRoot(struct soap *soap, const char *tag, int id, ns4__ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTons4__ResultXmlRoot(struct soap *soap, const char *tag, ns4__ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ResultXmlRoot **)soap_malloc(soap, sizeof(ns4__ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ResultXmlRoot *)soap_instantiate_ns4__ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ResultXmlRoot ** p = (ns4__ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResultXmlRoot, sizeof(ns4__ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ResultXmlRoot(struct soap *soap, ns4__ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ResultXmlRoot);
	if (soap_out_PointerTons4__ResultXmlRoot(soap, tag?tag:"ns4:ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTons4__ResultXmlRoot(struct soap *soap, ns4__ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResultXmlRoot(struct soap *soap, ns2__ResultXmlRoot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResultXmlRoot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResultXmlRoot(struct soap *soap, const char *tag, int id, ns2__ResultXmlRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResultXmlRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ResultXmlRoot ** SOAP_FMAC4 soap_in_PointerTons2__ResultXmlRoot(struct soap *soap, const char *tag, ns2__ResultXmlRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResultXmlRoot **)soap_malloc(soap, sizeof(ns2__ResultXmlRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResultXmlRoot *)soap_instantiate_ns2__ResultXmlRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ResultXmlRoot ** p = (ns2__ResultXmlRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResultXmlRoot, sizeof(ns2__ResultXmlRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResultXmlRoot(struct soap *soap, ns2__ResultXmlRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResultXmlRoot);
	if (soap_out_PointerTons2__ResultXmlRoot(soap, tag?tag:"ns2:ResultXmlRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResultXmlRoot ** SOAP_FMAC4 soap_get_PointerTons2__ResultXmlRoot(struct soap *soap, ns2__ResultXmlRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResultXmlRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PropertyList(struct soap *soap, ns1__PropertyList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PropertyList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PropertyList(struct soap *soap, const char *tag, int id, ns1__PropertyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PropertyList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PropertyList ** SOAP_FMAC4 soap_in_PointerTons1__PropertyList(struct soap *soap, const char *tag, ns1__PropertyList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PropertyList **)soap_malloc(soap, sizeof(ns1__PropertyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PropertyList *)soap_instantiate_ns1__PropertyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PropertyList ** p = (ns1__PropertyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PropertyList, sizeof(ns1__PropertyList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PropertyList(struct soap *soap, ns1__PropertyList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PropertyList);
	if (soap_out_PointerTons1__PropertyList(soap, tag?tag:"ns1:PropertyList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PropertyList ** SOAP_FMAC4 soap_get_PointerTons1__PropertyList(struct soap *soap, ns1__PropertyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PropertyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__XmlSchemaSimpleType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__XmlSchemaSimpleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__XmlSchemaSimpleType(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__XmlSchemaSimpleType, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaSimpleType, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__XmlSchemaSimpleType(soap, tag, NULL, "xsd:XmlSchemaSimpleType"))
				break;
		}
		else if (!soap_in_xsd__XmlSchemaSimpleType(soap, tag, &n, "xsd:XmlSchemaSimpleType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__XmlSchemaSimpleType(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaSimpleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaSimpleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__XmlSchemaSimpleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__XmlSchemaElement(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__XmlSchemaElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__XmlSchemaElement(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__XmlSchemaElement, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaElement, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__XmlSchemaElement(soap, tag, NULL, "xsd:XmlSchemaElement"))
				break;
		}
		else if (!soap_in_xsd__XmlSchemaElement(soap, tag, &n, "xsd:XmlSchemaElement"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__XmlSchemaElement(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__XmlSchemaElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__XmlSchemaXPath(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__XmlSchemaXPath(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__XmlSchemaXPath(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__XmlSchemaXPath, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaXPath, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__XmlSchemaXPath(soap, tag, NULL, "xsd:XmlSchemaXPath"))
				break;
		}
		else if (!soap_in_xsd__XmlSchemaXPath(soap, tag, &n, "xsd:XmlSchemaXPath"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__XmlSchemaXPath(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__XmlSchemaXPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__XmlSchemaXPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__XmlSchemaXPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, std::vector<ns5__HierarchyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, const std::vector<ns5__HierarchyInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__HierarchyInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__HierarchyInfo * >*a, const char *type)
{
	for (std::vector<ns5__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__HierarchyInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__HierarchyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, const char *tag, std::vector<ns5__HierarchyInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__HierarchyInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__HierarchyInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons5__HierarchyInfo, sizeof(ns5__HierarchyInfo), 1))
				break;
			if (!soap_in_PointerTons5__HierarchyInfo(soap, tag, NULL, "ns5:HierarchyInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__HierarchyInfo(soap, tag, &n, "ns5:HierarchyInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__HierarchyInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__HierarchyInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__HierarchyInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__HierarchyInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__HierarchyInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__HierarchyInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__HierarchyInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__HierarchyInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__HierarchyInfo * >*)p = *(std::vector<ns5__HierarchyInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, std::vector<ns5__AxisInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, const std::vector<ns5__AxisInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__AxisInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__AxisInfo * >*a, const char *type)
{
	for (std::vector<ns5__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__AxisInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__AxisInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, const char *tag, std::vector<ns5__AxisInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__AxisInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__AxisInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons5__AxisInfo, sizeof(ns5__AxisInfo), 1))
				break;
			if (!soap_in_PointerTons5__AxisInfo(soap, tag, NULL, "ns5:AxisInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__AxisInfo(soap, tag, &n, "ns5:AxisInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__AxisInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__AxisInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__AxisInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__AxisInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__AxisInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__AxisInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__AxisInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__AxisInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__AxisInfo * >*)p = *(std::vector<ns5__AxisInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, std::vector<ns5__Cube * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, const std::vector<ns5__Cube * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Cube(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, const char *tag, int id, const std::vector<ns5__Cube * >*a, const char *type)
{
	for (std::vector<ns5__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Cube(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Cube * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, const char *tag, std::vector<ns5__Cube * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Cube *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Cube, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cube, sizeof(ns5__Cube), 1))
				break;
			if (!soap_in_PointerTons5__Cube(soap, tag, NULL, "ns5:Cube"))
				break;
		}
		else if (!soap_in_PointerTons5__Cube(soap, tag, &n, "ns5:Cube"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Cube(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Cube * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Cube * >);
		if (size)
			*size = sizeof(std::vector<ns5__Cube * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Cube * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Cube * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Cube * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Cube * > %p -> %p\n", q, p));
	*(std::vector<ns5__Cube * >*)p = *(std::vector<ns5__Cube * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, std::vector<ns5__Members * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, const std::vector<ns5__Members * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Members(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, const char *tag, int id, const std::vector<ns5__Members * >*a, const char *type)
{
	for (std::vector<ns5__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Members(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Members * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, const char *tag, std::vector<ns5__Members * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Members *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Members, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Members, sizeof(ns5__Members), 1))
				break;
			if (!soap_in_PointerTons5__Members(soap, tag, NULL, "ns5:Members"))
				break;
		}
		else if (!soap_in_PointerTons5__Members(soap, tag, &n, "ns5:Members"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Members(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Members * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Members * >);
		if (size)
			*size = sizeof(std::vector<ns5__Members * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Members * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Members * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Members * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Members * > %p -> %p\n", q, p));
	*(std::vector<ns5__Members * >*)p = *(std::vector<ns5__Members * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, std::vector<ns5__Member * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, const std::vector<ns5__Member * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Member(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, const char *tag, int id, const std::vector<ns5__Member * >*a, const char *type)
{
	for (std::vector<ns5__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Member(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Member * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, const char *tag, std::vector<ns5__Member * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Member *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Member, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Member, sizeof(ns5__Member), 1))
				break;
			if (!soap_in_PointerTons5__Member(soap, tag, NULL, "ns5:Member"))
				break;
		}
		else if (!soap_in_PointerTons5__Member(soap, tag, &n, "ns5:Member"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Member(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Member * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Member * >);
		if (size)
			*size = sizeof(std::vector<ns5__Member * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Member * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Member * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Member * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Member * > %p -> %p\n", q, p));
	*(std::vector<ns5__Member * >*)p = *(std::vector<ns5__Member * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, std::vector<ns5__Tuple * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, const std::vector<ns5__Tuple * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Tuple(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, const char *tag, int id, const std::vector<ns5__Tuple * >*a, const char *type)
{
	for (std::vector<ns5__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Tuple(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Tuple * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, const char *tag, std::vector<ns5__Tuple * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Tuple *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Tuple, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Tuple, sizeof(ns5__Tuple), 1))
				break;
			if (!soap_in_PointerTons5__Tuple(soap, tag, NULL, "ns5:Tuple"))
				break;
		}
		else if (!soap_in_PointerTons5__Tuple(soap, tag, &n, "ns5:Tuple"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Tuple(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Tuple * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Tuple * >);
		if (size)
			*size = sizeof(std::vector<ns5__Tuple * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Tuple * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Tuple * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Tuple * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Tuple * > %p -> %p\n", q, p));
	*(std::vector<ns5__Tuple * >*)p = *(std::vector<ns5__Tuple * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, std::vector<ns5__Axis * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, const std::vector<ns5__Axis * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Axis(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, const char *tag, int id, const std::vector<ns5__Axis * >*a, const char *type)
{
	for (std::vector<ns5__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Axis(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Axis * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, const char *tag, std::vector<ns5__Axis * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Axis *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Axis, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Axis, sizeof(ns5__Axis), 1))
				break;
			if (!soap_in_PointerTons5__Axis(soap, tag, NULL, "ns5:Axis"))
				break;
		}
		else if (!soap_in_PointerTons5__Axis(soap, tag, &n, "ns5:Axis"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Axis(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Axis * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Axis * >);
		if (size)
			*size = sizeof(std::vector<ns5__Axis * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Axis * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Axis * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Axis * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Axis * > %p -> %p\n", q, p));
	*(std::vector<ns5__Axis * >*)p = *(std::vector<ns5__Axis * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, std::vector<ns5__Cell * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, const std::vector<ns5__Cell * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__Cell(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, const char *tag, int id, const std::vector<ns5__Cell * >*a, const char *type)
{
	for (std::vector<ns5__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__Cell(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__Cell * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, const char *tag, std::vector<ns5__Cell * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__Cell *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__Cell, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cell, sizeof(ns5__Cell), 1))
				break;
			if (!soap_in_PointerTons5__Cell(soap, tag, NULL, "ns5:Cell"))
				break;
		}
		else if (!soap_in_PointerTons5__Cell(soap, tag, &n, "ns5:Cell"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__Cell(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__Cell * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__Cell * >);
		if (size)
			*size = sizeof(std::vector<ns5__Cell * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__Cell * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__Cell * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__Cell * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__Cell * > %p -> %p\n", q, p));
	*(std::vector<ns5__Cell * >*)p = *(std::vector<ns5__Cell * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, std::vector<ns4__HierarchyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, const std::vector<ns4__HierarchyInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__HierarchyInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__HierarchyInfo * >*a, const char *type)
{
	for (std::vector<ns4__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__HierarchyInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__HierarchyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, const char *tag, std::vector<ns4__HierarchyInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__HierarchyInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__HierarchyInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons4__HierarchyInfo, sizeof(ns4__HierarchyInfo), 1))
				break;
			if (!soap_in_PointerTons4__HierarchyInfo(soap, tag, NULL, "ns4:HierarchyInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__HierarchyInfo(soap, tag, &n, "ns4:HierarchyInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__HierarchyInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__HierarchyInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__HierarchyInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__HierarchyInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__HierarchyInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__HierarchyInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__HierarchyInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__HierarchyInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__HierarchyInfo * >*)p = *(std::vector<ns4__HierarchyInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, std::vector<ns4__AxisInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, const std::vector<ns4__AxisInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__AxisInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__AxisInfo * >*a, const char *type)
{
	for (std::vector<ns4__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__AxisInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__AxisInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, const char *tag, std::vector<ns4__AxisInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__AxisInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__AxisInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons4__AxisInfo, sizeof(ns4__AxisInfo), 1))
				break;
			if (!soap_in_PointerTons4__AxisInfo(soap, tag, NULL, "ns4:AxisInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__AxisInfo(soap, tag, &n, "ns4:AxisInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__AxisInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__AxisInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__AxisInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__AxisInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__AxisInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__AxisInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__AxisInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__AxisInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__AxisInfo * >*)p = *(std::vector<ns4__AxisInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, std::vector<ns4__Cube * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, const std::vector<ns4__Cube * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Cube(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, const char *tag, int id, const std::vector<ns4__Cube * >*a, const char *type)
{
	for (std::vector<ns4__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Cube(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Cube * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, const char *tag, std::vector<ns4__Cube * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Cube *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Cube, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cube, sizeof(ns4__Cube), 1))
				break;
			if (!soap_in_PointerTons4__Cube(soap, tag, NULL, "ns4:Cube"))
				break;
		}
		else if (!soap_in_PointerTons4__Cube(soap, tag, &n, "ns4:Cube"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Cube(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Cube * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Cube * >);
		if (size)
			*size = sizeof(std::vector<ns4__Cube * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Cube * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Cube * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Cube * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Cube * > %p -> %p\n", q, p));
	*(std::vector<ns4__Cube * >*)p = *(std::vector<ns4__Cube * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, std::vector<ns4__Members * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, const std::vector<ns4__Members * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Members(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, const char *tag, int id, const std::vector<ns4__Members * >*a, const char *type)
{
	for (std::vector<ns4__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Members(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Members * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, const char *tag, std::vector<ns4__Members * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Members *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Members, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Members, sizeof(ns4__Members), 1))
				break;
			if (!soap_in_PointerTons4__Members(soap, tag, NULL, "ns4:Members"))
				break;
		}
		else if (!soap_in_PointerTons4__Members(soap, tag, &n, "ns4:Members"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Members(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Members * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Members * >);
		if (size)
			*size = sizeof(std::vector<ns4__Members * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Members * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Members * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Members * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Members * > %p -> %p\n", q, p));
	*(std::vector<ns4__Members * >*)p = *(std::vector<ns4__Members * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, std::vector<ns4__Member * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, const std::vector<ns4__Member * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Member(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, const char *tag, int id, const std::vector<ns4__Member * >*a, const char *type)
{
	for (std::vector<ns4__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Member(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Member * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, const char *tag, std::vector<ns4__Member * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Member *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Member, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Member, sizeof(ns4__Member), 1))
				break;
			if (!soap_in_PointerTons4__Member(soap, tag, NULL, "ns4:Member"))
				break;
		}
		else if (!soap_in_PointerTons4__Member(soap, tag, &n, "ns4:Member"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Member(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Member * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Member * >);
		if (size)
			*size = sizeof(std::vector<ns4__Member * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Member * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Member * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Member * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Member * > %p -> %p\n", q, p));
	*(std::vector<ns4__Member * >*)p = *(std::vector<ns4__Member * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, std::vector<ns4__Tuple * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, const std::vector<ns4__Tuple * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Tuple(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, const char *tag, int id, const std::vector<ns4__Tuple * >*a, const char *type)
{
	for (std::vector<ns4__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Tuple(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Tuple * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, const char *tag, std::vector<ns4__Tuple * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Tuple *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Tuple, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Tuple, sizeof(ns4__Tuple), 1))
				break;
			if (!soap_in_PointerTons4__Tuple(soap, tag, NULL, "ns4:Tuple"))
				break;
		}
		else if (!soap_in_PointerTons4__Tuple(soap, tag, &n, "ns4:Tuple"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Tuple(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Tuple * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Tuple * >);
		if (size)
			*size = sizeof(std::vector<ns4__Tuple * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Tuple * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Tuple * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Tuple * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Tuple * > %p -> %p\n", q, p));
	*(std::vector<ns4__Tuple * >*)p = *(std::vector<ns4__Tuple * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, std::vector<ns4__Axis * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, const std::vector<ns4__Axis * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Axis(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, const char *tag, int id, const std::vector<ns4__Axis * >*a, const char *type)
{
	for (std::vector<ns4__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Axis(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Axis * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, const char *tag, std::vector<ns4__Axis * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Axis *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Axis, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Axis, sizeof(ns4__Axis), 1))
				break;
			if (!soap_in_PointerTons4__Axis(soap, tag, NULL, "ns4:Axis"))
				break;
		}
		else if (!soap_in_PointerTons4__Axis(soap, tag, &n, "ns4:Axis"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Axis(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Axis * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Axis * >);
		if (size)
			*size = sizeof(std::vector<ns4__Axis * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Axis * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Axis * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Axis * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Axis * > %p -> %p\n", q, p));
	*(std::vector<ns4__Axis * >*)p = *(std::vector<ns4__Axis * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, std::vector<ns4__Cell * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, const std::vector<ns4__Cell * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Cell(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, const char *tag, int id, const std::vector<ns4__Cell * >*a, const char *type)
{
	for (std::vector<ns4__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Cell(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Cell * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, const char *tag, std::vector<ns4__Cell * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__Cell *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__Cell, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cell, sizeof(ns4__Cell), 1))
				break;
			if (!soap_in_PointerTons4__Cell(soap, tag, NULL, "ns4:Cell"))
				break;
		}
		else if (!soap_in_PointerTons4__Cell(soap, tag, &n, "ns4:Cell"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Cell(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Cell * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__Cell * >);
		if (size)
			*size = sizeof(std::vector<ns4__Cell * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__Cell * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__Cell * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__Cell * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__Cell * > %p -> %p\n", q, p));
	*(std::vector<ns4__Cell * >*)p = *(std::vector<ns4__Cell * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, std::vector<ns2__HierarchyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, const std::vector<ns2__HierarchyInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__HierarchyInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, const char *tag, int id, const std::vector<ns2__HierarchyInfo * >*a, const char *type)
{
	for (std::vector<ns2__HierarchyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__HierarchyInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__HierarchyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, const char *tag, std::vector<ns2__HierarchyInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__HierarchyInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__HierarchyInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons2__HierarchyInfo, sizeof(ns2__HierarchyInfo), 1))
				break;
			if (!soap_in_PointerTons2__HierarchyInfo(soap, tag, NULL, "ns2:HierarchyInfo"))
				break;
		}
		else if (!soap_in_PointerTons2__HierarchyInfo(soap, tag, &n, "ns2:HierarchyInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__HierarchyInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__HierarchyInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__HierarchyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__HierarchyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__HierarchyInfo * >);
		if (size)
			*size = sizeof(std::vector<ns2__HierarchyInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__HierarchyInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__HierarchyInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__HierarchyInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__HierarchyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__HierarchyInfo * > %p -> %p\n", q, p));
	*(std::vector<ns2__HierarchyInfo * >*)p = *(std::vector<ns2__HierarchyInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, std::vector<ns2__AxisInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, const std::vector<ns2__AxisInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AxisInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, const char *tag, int id, const std::vector<ns2__AxisInfo * >*a, const char *type)
{
	for (std::vector<ns2__AxisInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AxisInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AxisInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, const char *tag, std::vector<ns2__AxisInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__AxisInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AxisInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AxisInfo, sizeof(ns2__AxisInfo), 1))
				break;
			if (!soap_in_PointerTons2__AxisInfo(soap, tag, NULL, "ns2:AxisInfo"))
				break;
		}
		else if (!soap_in_PointerTons2__AxisInfo(soap, tag, &n, "ns2:AxisInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AxisInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AxisInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__AxisInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AxisInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AxisInfo * >);
		if (size)
			*size = sizeof(std::vector<ns2__AxisInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__AxisInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__AxisInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__AxisInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__AxisInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__AxisInfo * > %p -> %p\n", q, p));
	*(std::vector<ns2__AxisInfo * >*)p = *(std::vector<ns2__AxisInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, std::vector<ns2__Cube * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, const std::vector<ns2__Cube * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Cube(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, const char *tag, int id, const std::vector<ns2__Cube * >*a, const char *type)
{
	for (std::vector<ns2__Cube * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Cube(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Cube * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, const char *tag, std::vector<ns2__Cube * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Cube *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Cube, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cube, sizeof(ns2__Cube), 1))
				break;
			if (!soap_in_PointerTons2__Cube(soap, tag, NULL, "ns2:Cube"))
				break;
		}
		else if (!soap_in_PointerTons2__Cube(soap, tag, &n, "ns2:Cube"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Cube(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Cube * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Cube(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cube, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Cube * >);
		if (size)
			*size = sizeof(std::vector<ns2__Cube * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Cube * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Cube * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Cube * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Cube(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Cube * > %p -> %p\n", q, p));
	*(std::vector<ns2__Cube * >*)p = *(std::vector<ns2__Cube * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, std::vector<ns2__Members * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, const std::vector<ns2__Members * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Members(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, const char *tag, int id, const std::vector<ns2__Members * >*a, const char *type)
{
	for (std::vector<ns2__Members * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Members(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Members * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, const char *tag, std::vector<ns2__Members * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Members *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Members, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Members, sizeof(ns2__Members), 1))
				break;
			if (!soap_in_PointerTons2__Members(soap, tag, NULL, "ns2:Members"))
				break;
		}
		else if (!soap_in_PointerTons2__Members(soap, tag, &n, "ns2:Members"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Members(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Members * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Members(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Members, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Members * >);
		if (size)
			*size = sizeof(std::vector<ns2__Members * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Members * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Members * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Members * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Members(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Members * > %p -> %p\n", q, p));
	*(std::vector<ns2__Members * >*)p = *(std::vector<ns2__Members * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, std::vector<ns2__Member * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, const std::vector<ns2__Member * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Member(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, const char *tag, int id, const std::vector<ns2__Member * >*a, const char *type)
{
	for (std::vector<ns2__Member * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Member(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Member * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, const char *tag, std::vector<ns2__Member * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Member *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Member, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Member, sizeof(ns2__Member), 1))
				break;
			if (!soap_in_PointerTons2__Member(soap, tag, NULL, "ns2:Member"))
				break;
		}
		else if (!soap_in_PointerTons2__Member(soap, tag, &n, "ns2:Member"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Member(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Member * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Member(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Member, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Member * >);
		if (size)
			*size = sizeof(std::vector<ns2__Member * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Member * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Member * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Member * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Member(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Member * > %p -> %p\n", q, p));
	*(std::vector<ns2__Member * >*)p = *(std::vector<ns2__Member * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, std::vector<ns2__Tuple * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, const std::vector<ns2__Tuple * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Tuple(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, const char *tag, int id, const std::vector<ns2__Tuple * >*a, const char *type)
{
	for (std::vector<ns2__Tuple * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Tuple(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Tuple * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, const char *tag, std::vector<ns2__Tuple * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Tuple *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Tuple, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Tuple, sizeof(ns2__Tuple), 1))
				break;
			if (!soap_in_PointerTons2__Tuple(soap, tag, NULL, "ns2:Tuple"))
				break;
		}
		else if (!soap_in_PointerTons2__Tuple(soap, tag, &n, "ns2:Tuple"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Tuple(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Tuple * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Tuple(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Tuple, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Tuple * >);
		if (size)
			*size = sizeof(std::vector<ns2__Tuple * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Tuple * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Tuple * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Tuple * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Tuple(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Tuple * > %p -> %p\n", q, p));
	*(std::vector<ns2__Tuple * >*)p = *(std::vector<ns2__Tuple * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, std::vector<ns2__Axis * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, const std::vector<ns2__Axis * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Axis(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, const char *tag, int id, const std::vector<ns2__Axis * >*a, const char *type)
{
	for (std::vector<ns2__Axis * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Axis(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Axis * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, const char *tag, std::vector<ns2__Axis * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Axis *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Axis, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Axis, sizeof(ns2__Axis), 1))
				break;
			if (!soap_in_PointerTons2__Axis(soap, tag, NULL, "ns2:Axis"))
				break;
		}
		else if (!soap_in_PointerTons2__Axis(soap, tag, &n, "ns2:Axis"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Axis(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Axis * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Axis * >);
		if (size)
			*size = sizeof(std::vector<ns2__Axis * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Axis * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Axis * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Axis * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Axis * > %p -> %p\n", q, p));
	*(std::vector<ns2__Axis * >*)p = *(std::vector<ns2__Axis * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, std::vector<ns2__Cell * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, const std::vector<ns2__Cell * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Cell(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, const char *tag, int id, const std::vector<ns2__Cell * >*a, const char *type)
{
	for (std::vector<ns2__Cell * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Cell(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Cell * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, const char *tag, std::vector<ns2__Cell * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Cell *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Cell, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cell, sizeof(ns2__Cell), 1))
				break;
			if (!soap_in_PointerTons2__Cell(soap, tag, NULL, "ns2:Cell"))
				break;
		}
		else if (!soap_in_PointerTons2__Cell(soap, tag, &n, "ns2:Cell"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Cell(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Cell * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Cell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Cell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Cell * >);
		if (size)
			*size = sizeof(std::vector<ns2__Cell * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Cell * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Cell * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Cell * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Cell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Cell * > %p -> %p\n", q, p));
	*(std::vector<ns2__Cell * >*)p = *(std::vector<ns2__Cell * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	char *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else if (!soap_inliteral(soap, tag, &n))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<char * >, n);
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
