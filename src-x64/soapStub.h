/* soapStub.h
   Generated by gSOAP 2.8.15 from xmlaWSDL.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"urn:schemas-microsoft-com:xml-analysis"
#define SOAP_NAMESPACE_OF_ns2	"urn:schemas-microsoft-com:xml-analysis:rowset"
#define SOAP_NAMESPACE_OF_ns3	"http://www.w3.org/2001/XMLSchema"
#define SOAP_NAMESPACE_OF_ns4	"urn:schemas-microsoft-com:xml-analysis:mddataset"
#define SOAP_NAMESPACE_OF_ns5	"urn:schemas-microsoft-com:xml-analysis:empty"
#define SOAP_NAMESPACE_OF_ns6	"http://schemas.xmlsoap.org/ws/2002/04/secext"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns3__XmlSchemaDerivationMethod
#define SOAP_TYPE_ns3__XmlSchemaDerivationMethod (205)
/* Bitmask ns3:XmlSchemaDerivationMethod */
enum ns3__XmlSchemaDerivationMethod { ns3__XmlSchemaDerivationMethod___x0000 = 1, ns3__XmlSchemaDerivationMethod__substitution = 2, ns3__XmlSchemaDerivationMethod__extension = 4, ns3__XmlSchemaDerivationMethod__restriction = 8, ns3__XmlSchemaDerivationMethod__list = 16, ns3__XmlSchemaDerivationMethod__union_ = 32, ns3__XmlSchemaDerivationMethod___x0023all = 64 };
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaForm
#define SOAP_TYPE_ns3__XmlSchemaForm (206)
/* ns3:XmlSchemaForm */
enum ns3__XmlSchemaForm { ns3__XmlSchemaForm__qualified = 0, ns3__XmlSchemaForm__unqualified = 1 };
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaContentProcessing
#define SOAP_TYPE_ns3__XmlSchemaContentProcessing (207)
/* ns3:XmlSchemaContentProcessing */
enum ns3__XmlSchemaContentProcessing { ns3__XmlSchemaContentProcessing__skip = 0, ns3__XmlSchemaContentProcessing__lax = 1, ns3__XmlSchemaContentProcessing__strict = 2 };
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaUse
#define SOAP_TYPE_ns3__XmlSchemaUse (208)
/* ns3:XmlSchemaUse */
enum ns3__XmlSchemaUse { ns3__XmlSchemaUse__optional = 0, ns3__XmlSchemaUse__prohibited = 1, ns3__XmlSchemaUse__required = 2 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (9)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__CommandStatement
#define SOAP_TYPE_ns1__CommandStatement (77)
/* ns1:CommandStatement */
class SOAP_CMAC ns1__CommandStatement
{
public:
	std::string *Statement;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns1__CommandStatement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CommandStatement() { ns1__CommandStatement::soap_default(NULL); }
	virtual ~ns1__CommandStatement() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Properties
#define SOAP_TYPE_ns1__Properties (78)
/* ns1:Properties */
class SOAP_CMAC ns1__Properties
{
public:
	class ns1__PropertyList *PropertyList;	/* optional element of type ns1:PropertyList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__Properties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Properties() { ns1__Properties::soap_default(NULL); }
	virtual ~ns1__Properties() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PropertyList
#define SOAP_TYPE_ns1__PropertyList (79)
/* ns1:PropertyList */
class SOAP_CMAC ns1__PropertyList
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__PropertyList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PropertyList() { ns1__PropertyList::soap_default(NULL); }
	virtual ~ns1__PropertyList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Parameters
#define SOAP_TYPE_ns1__Parameters (80)
/* ns1:Parameters */
class SOAP_CMAC ns1__Parameters
{
public:
	char *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns1__Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Parameters() { ns1__Parameters::soap_default(NULL); }
	virtual ~ns1__Parameters() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ResultSet
#define SOAP_TYPE_ns1__ResultSet (81)
/* ns1:ResultSet */
class SOAP_CMAC ns1__ResultSet
{
public:
	class ns2__ResultXmlRoot *ns2__root;	/* optional element of type ns2:ResultXmlRoot */
	class ns4__ResultXmlRoot *ns4__root;	/* optional element of type ns4:ResultXmlRoot */
	class ns5__ResultXmlRoot *ns5__root;	/* optional element of type ns5:ResultXmlRoot */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__ResultSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ResultSet() { ns1__ResultSet::soap_default(NULL); }
	virtual ~ns1__ResultSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BeginSession
#define SOAP_TYPE_ns1__BeginSession (82)
/* ns1:BeginSession */
class SOAP_CMAC ns1__BeginSession
{
public:
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns1__BeginSession */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BeginSession() { ns1__BeginSession::soap_default(NULL); }
	virtual ~ns1__BeginSession() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Session
#define SOAP_TYPE_ns1__Session (83)
/* ns1:Session */
class SOAP_CMAC ns1__Session
{
public:
	std::string *SessionId;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__Session */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Session() { ns1__Session::soap_default(NULL); }
	virtual ~ns1__Session() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EndSession
#define SOAP_TYPE_ns1__EndSession (84)
/* ns1:EndSession */
class SOAP_CMAC ns1__EndSession
{
public:
	std::string *SessionId;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns1__EndSession */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EndSession() { ns1__EndSession::soap_default(NULL); }
	virtual ~ns1__EndSession() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Restrictions
#define SOAP_TYPE_ns1__Restrictions (85)
/* ns1:Restrictions */
class SOAP_CMAC ns1__Restrictions
{
public:
	class ns1__RestrictionList *RestrictionList;	/* optional element of type ns1:RestrictionList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__Restrictions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Restrictions() { ns1__Restrictions::soap_default(NULL); }
	virtual ~ns1__Restrictions() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RestrictionList
#define SOAP_TYPE_ns1__RestrictionList (86)
/* ns1:RestrictionList */
class SOAP_CMAC ns1__RestrictionList
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns1__RestrictionList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RestrictionList() { ns1__RestrictionList::soap_default(NULL); }
	virtual ~ns1__RestrictionList() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Execute
#define SOAP_TYPE__ns1__Execute (87)
/* ns1:Execute */
class SOAP_CMAC _ns1__Execute
{
public:
	ns1__CommandStatement *Command;	/* required element of type ns1:CommandStatement */
	ns1__Properties *Properties;	/* required element of type ns1:Properties */
	ns1__Parameters *Parameters;	/* optional element of type ns1:Parameters */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE__ns1__Execute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Execute() { _ns1__Execute::soap_default(NULL); }
	virtual ~_ns1__Execute() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ExecuteResponse
#define SOAP_TYPE__ns1__ExecuteResponse (88)
/* ns1:ExecuteResponse */
class SOAP_CMAC _ns1__ExecuteResponse
{
public:
	ns1__ResultSet *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ResultSet */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns1__ExecuteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ExecuteResponse() { _ns1__ExecuteResponse::soap_default(NULL); }
	virtual ~_ns1__ExecuteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Discover
#define SOAP_TYPE__ns1__Discover (89)
/* ns1:Discover */
class SOAP_CMAC _ns1__Discover
{
public:
	std::string *RequestType;	/* optional element of type xsd:string */
	ns1__Restrictions *Restrictions;	/* required element of type ns1:Restrictions */
	ns1__Properties *Properties;	/* required element of type ns1:Properties */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE__ns1__Discover */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Discover() { _ns1__Discover::soap_default(NULL); }
	virtual ~_ns1__Discover() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DiscoverResponse
#define SOAP_TYPE__ns1__DiscoverResponse (90)
/* ns1:DiscoverResponse */
class SOAP_CMAC _ns1__DiscoverResponse
{
public:
	ns1__ResultSet *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ResultSet */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE__ns1__DiscoverResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DiscoverResponse() { _ns1__DiscoverResponse::soap_default(NULL); }
	virtual ~_ns1__DiscoverResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns2__union_ResultXmlRoot
#define SOAP_TYPE___ns2__union_ResultXmlRoot (222)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_ResultXmlRoot
{
public:
	class ns2__CellData *CellData;	/* optional element of type ns2:CellData */
	class ns2__Axes *Axes;	/* optional element of type ns2:Axes */
	std::vector<char * >row;	/* optional element of type xsd:anyType */
	class ns2__OlapInfo *OlapInfo;	/* optional element of type ns2:OlapInfo */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE___ns2__union_ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_ResultXmlRoot() { __ns2__union_ResultXmlRoot::soap_default(NULL); }
	virtual ~__ns2__union_ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ResultXmlRoot
#define SOAP_TYPE_ns2__ResultXmlRoot (91)
/* ns2:ResultXmlRoot */
class SOAP_CMAC ns2__ResultXmlRoot
{
public:
	char *xsd__schema;	/* optional element of type xsd:schema */
	int __size_ResultXmlRoot;	/* sequence of elements <-union-ResultXmlRoot> */
	__ns2__union_ResultXmlRoot *__union_ResultXmlRoot;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns2__ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ResultXmlRoot() { ns2__ResultXmlRoot::soap_default(NULL); }
	virtual ~ns2__ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CellData
#define SOAP_TYPE_ns2__CellData (92)
/* ns2:CellData */
class SOAP_CMAC ns2__CellData
{
public:
	std::vector<class ns2__Cell * >Cell;	/* optional element of type ns2:Cell */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns2__CellData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CellData() { ns2__CellData::soap_default(NULL); }
	virtual ~ns2__CellData() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Cell
#define SOAP_TYPE_ns2__Cell (93)
/* ns2:Cell */
class SOAP_CMAC ns2__Cell
{
public:
	double *Value;	/* optional element of type xsd:double */
	std::vector<char * >__any;
	int CellOrdinal;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns2__Cell */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Cell() { ns2__Cell::soap_default(NULL); }
	virtual ~ns2__Cell() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Axes
#define SOAP_TYPE_ns2__Axes (94)
/* ns2:Axes */
class SOAP_CMAC ns2__Axes
{
public:
	std::vector<class ns2__Axis * >Axis;	/* optional element of type ns2:Axis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns2__Axes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Axes() { ns2__Axes::soap_default(NULL); }
	virtual ~ns2__Axes() { }
};
#endif

#ifndef SOAP_TYPE___ns2__union_Axis
#define SOAP_TYPE___ns2__union_Axis (233)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_Axis
{
public:
	class ns2__Tuples *Tuples;	/* optional element of type ns2:Tuples */
	class ns2__CrossProduct *CrossProduct;	/* optional element of type ns2:CrossProduct */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE___ns2__union_Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_Axis() { __ns2__union_Axis::soap_default(NULL); }
	virtual ~__ns2__union_Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Axis
#define SOAP_TYPE_ns2__Axis (95)
/* ns2:Axis */
class SOAP_CMAC ns2__Axis
{
public:
	int __size_Axis;	/* sequence of elements <-union-Axis> */
	__ns2__union_Axis *__union_Axis;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns2__Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Axis() { ns2__Axis::soap_default(NULL); }
	virtual ~ns2__Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Tuples
#define SOAP_TYPE_ns2__Tuples (96)
/* ns2:Tuples */
class SOAP_CMAC ns2__Tuples
{
public:
	std::vector<class ns2__Tuple * >Tuple;	/* optional element of type ns2:Tuple */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns2__Tuples */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Tuples() { ns2__Tuples::soap_default(NULL); }
	virtual ~ns2__Tuples() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Tuple
#define SOAP_TYPE_ns2__Tuple (97)
/* ns2:Tuple */
class SOAP_CMAC ns2__Tuple
{
public:
	std::vector<class ns2__Member * >Member;	/* optional element of type ns2:Member */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns2__Tuple */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Tuple() { ns2__Tuple::soap_default(NULL); }
	virtual ~ns2__Tuple() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Member
#define SOAP_TYPE_ns2__Member (98)
/* ns2:Member */
class SOAP_CMAC ns2__Member
{
public:
	std::string *UName;	/* optional element of type xsd:string */
	std::string *Caption;	/* optional element of type xsd:string */
	std::string *LName;	/* optional element of type xsd:string */
	std::string *LNum;	/* optional element of type xsd:string */
	std::string *DisplayInfo;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns2__Member */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Member() { ns2__Member::soap_default(NULL); }
	virtual ~ns2__Member() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CrossProduct
#define SOAP_TYPE_ns2__CrossProduct (99)
/* ns2:CrossProduct */
class SOAP_CMAC ns2__CrossProduct
{
public:
	std::vector<class ns2__Members * >Members;	/* optional element of type ns2:Members */
	int Size;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns2__CrossProduct */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CrossProduct() { ns2__CrossProduct::soap_default(NULL); }
	virtual ~ns2__CrossProduct() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Members
#define SOAP_TYPE_ns2__Members (100)
/* ns2:Members */
class SOAP_CMAC ns2__Members
{
public:
	std::vector<ns2__Member * >Member;	/* optional element of type ns2:Member */
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns2__Members */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Members() { ns2__Members::soap_default(NULL); }
	virtual ~ns2__Members() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Row
#define SOAP_TYPE_ns2__Row (101)
/* ns2:Row */
class SOAP_CMAC ns2__Row
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns2__Row */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Row() { ns2__Row::soap_default(NULL); }
	virtual ~ns2__Row() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OlapInfo
#define SOAP_TYPE_ns2__OlapInfo (102)
/* ns2:OlapInfo */
class SOAP_CMAC ns2__OlapInfo
{
public:
	class ns2__CubeInfo *CubeInfo;	/* optional element of type ns2:CubeInfo */
	class ns2__AxesInfo *AxesInfo;	/* optional element of type ns2:AxesInfo */
	class ns2__CellInfo *CellInfo;	/* optional element of type ns2:CellInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns2__OlapInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OlapInfo() { ns2__OlapInfo::soap_default(NULL); }
	virtual ~ns2__OlapInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CubeInfo
#define SOAP_TYPE_ns2__CubeInfo (103)
/* ns2:CubeInfo */
class SOAP_CMAC ns2__CubeInfo
{
public:
	std::vector<class ns2__Cube * >Cube;	/* optional element of type ns2:Cube */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns2__CubeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CubeInfo() { ns2__CubeInfo::soap_default(NULL); }
	virtual ~ns2__CubeInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Cube
#define SOAP_TYPE_ns2__Cube (104)
/* ns2:Cube */
class SOAP_CMAC ns2__Cube
{
public:
	std::string *CubeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns2__Cube */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Cube() { ns2__Cube::soap_default(NULL); }
	virtual ~ns2__Cube() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AxesInfo
#define SOAP_TYPE_ns2__AxesInfo (105)
/* ns2:AxesInfo */
class SOAP_CMAC ns2__AxesInfo
{
public:
	std::vector<class ns2__AxisInfo * >AxisInfo;	/* optional element of type ns2:AxisInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns2__AxesInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AxesInfo() { ns2__AxesInfo::soap_default(NULL); }
	virtual ~ns2__AxesInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AxisInfo
#define SOAP_TYPE_ns2__AxisInfo (106)
/* ns2:AxisInfo */
class SOAP_CMAC ns2__AxisInfo
{
public:
	std::vector<class ns2__HierarchyInfo * >HierarchyInfo;	/* optional element of type ns2:HierarchyInfo */
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns2__AxisInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AxisInfo() { ns2__AxisInfo::soap_default(NULL); }
	virtual ~ns2__AxisInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HierarchyInfo
#define SOAP_TYPE_ns2__HierarchyInfo (107)
/* ns2:HierarchyInfo */
class SOAP_CMAC ns2__HierarchyInfo
{
public:
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns2__HierarchyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HierarchyInfo() { ns2__HierarchyInfo::soap_default(NULL); }
	virtual ~ns2__HierarchyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CellInfo
#define SOAP_TYPE_ns2__CellInfo (108)
/* ns2:CellInfo */
class SOAP_CMAC ns2__CellInfo
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns2__CellInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CellInfo() { ns2__CellInfo::soap_default(NULL); }
	virtual ~ns2__CellInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaObject
#define SOAP_TYPE_ns3__XmlSchemaObject (110)
/* ns3:XmlSchemaObject */
class SOAP_CMAC ns3__XmlSchemaObject
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns3__XmlSchemaObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaObject() { ns3__XmlSchemaObject::soap_default(NULL); }
	virtual ~ns3__XmlSchemaObject() { }
};
#endif

#ifndef SOAP_TYPE___ns4__union_ResultXmlRoot
#define SOAP_TYPE___ns4__union_ResultXmlRoot (252)
/* Operation wrapper: */
class SOAP_CMAC __ns4__union_ResultXmlRoot
{
public:
	class ns4__CellData *CellData;	/* optional element of type ns4:CellData */
	class ns4__Axes *Axes;	/* optional element of type ns4:Axes */
	class ns4__Row *row;	/* optional element of type ns4:Row */
	class ns4__OlapInfo *OlapInfo;	/* optional element of type ns4:OlapInfo */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE___ns4__union_ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns4__union_ResultXmlRoot() { __ns4__union_ResultXmlRoot::soap_default(NULL); }
	virtual ~__ns4__union_ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ResultXmlRoot
#define SOAP_TYPE_ns4__ResultXmlRoot (167)
/* ns4:ResultXmlRoot */
class SOAP_CMAC ns4__ResultXmlRoot
{
public:
	char *xsd__schema;	/* optional element of type xsd:schema */
	int __size_ResultXmlRoot;	/* sequence of elements <-union-ResultXmlRoot> */
	__ns4__union_ResultXmlRoot *__union_ResultXmlRoot;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE_ns4__ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ResultXmlRoot() { ns4__ResultXmlRoot::soap_default(NULL); }
	virtual ~ns4__ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns4__CellData
#define SOAP_TYPE_ns4__CellData (168)
/* ns4:CellData */
class SOAP_CMAC ns4__CellData
{
public:
	std::vector<class ns4__Cell * >Cell;	/* optional element of type ns4:Cell */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE_ns4__CellData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__CellData() { ns4__CellData::soap_default(NULL); }
	virtual ~ns4__CellData() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Cell
#define SOAP_TYPE_ns4__Cell (169)
/* ns4:Cell */
class SOAP_CMAC ns4__Cell
{
public:
	double *Value;	/* optional element of type xsd:double */
	std::vector<char * >__any;
	int CellOrdinal;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE_ns4__Cell */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Cell() { ns4__Cell::soap_default(NULL); }
	virtual ~ns4__Cell() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Axes
#define SOAP_TYPE_ns4__Axes (170)
/* ns4:Axes */
class SOAP_CMAC ns4__Axes
{
public:
	std::vector<class ns4__Axis * >Axis;	/* optional element of type ns4:Axis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_ns4__Axes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Axes() { ns4__Axes::soap_default(NULL); }
	virtual ~ns4__Axes() { }
};
#endif

#ifndef SOAP_TYPE___ns4__union_Axis
#define SOAP_TYPE___ns4__union_Axis (262)
/* Operation wrapper: */
class SOAP_CMAC __ns4__union_Axis
{
public:
	class ns4__Tuples *Tuples;	/* optional element of type ns4:Tuples */
	class ns4__CrossProduct *CrossProduct;	/* optional element of type ns4:CrossProduct */
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE___ns4__union_Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns4__union_Axis() { __ns4__union_Axis::soap_default(NULL); }
	virtual ~__ns4__union_Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Axis
#define SOAP_TYPE_ns4__Axis (171)
/* ns4:Axis */
class SOAP_CMAC ns4__Axis
{
public:
	int __size_Axis;	/* sequence of elements <-union-Axis> */
	__ns4__union_Axis *__union_Axis;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE_ns4__Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Axis() { ns4__Axis::soap_default(NULL); }
	virtual ~ns4__Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Tuples
#define SOAP_TYPE_ns4__Tuples (172)
/* ns4:Tuples */
class SOAP_CMAC ns4__Tuples
{
public:
	std::vector<class ns4__Tuple * >Tuple;	/* optional element of type ns4:Tuple */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_ns4__Tuples */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Tuples() { ns4__Tuples::soap_default(NULL); }
	virtual ~ns4__Tuples() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Tuple
#define SOAP_TYPE_ns4__Tuple (173)
/* ns4:Tuple */
class SOAP_CMAC ns4__Tuple
{
public:
	std::vector<class ns4__Member * >Member;	/* optional element of type ns4:Member */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE_ns4__Tuple */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Tuple() { ns4__Tuple::soap_default(NULL); }
	virtual ~ns4__Tuple() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Member
#define SOAP_TYPE_ns4__Member (174)
/* ns4:Member */
class SOAP_CMAC ns4__Member
{
public:
	std::string *UName;	/* optional element of type xsd:string */
	std::string *Caption;	/* optional element of type xsd:string */
	std::string *LName;	/* optional element of type xsd:string */
	std::string *LNum;	/* optional element of type xsd:string */
	std::string *DisplayInfo;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE_ns4__Member */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Member() { ns4__Member::soap_default(NULL); }
	virtual ~ns4__Member() { }
};
#endif

#ifndef SOAP_TYPE_ns4__CrossProduct
#define SOAP_TYPE_ns4__CrossProduct (175)
/* ns4:CrossProduct */
class SOAP_CMAC ns4__CrossProduct
{
public:
	std::vector<class ns4__Members * >Members;	/* optional element of type ns4:Members */
	int Size;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_ns4__CrossProduct */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__CrossProduct() { ns4__CrossProduct::soap_default(NULL); }
	virtual ~ns4__CrossProduct() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Members
#define SOAP_TYPE_ns4__Members (176)
/* ns4:Members */
class SOAP_CMAC ns4__Members
{
public:
	std::vector<ns4__Member * >Member;	/* optional element of type ns4:Member */
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE_ns4__Members */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Members() { ns4__Members::soap_default(NULL); }
	virtual ~ns4__Members() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Row
#define SOAP_TYPE_ns4__Row (177)
/* ns4:Row */
class SOAP_CMAC ns4__Row
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE_ns4__Row */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Row() { ns4__Row::soap_default(NULL); }
	virtual ~ns4__Row() { }
};
#endif

#ifndef SOAP_TYPE_ns4__OlapInfo
#define SOAP_TYPE_ns4__OlapInfo (178)
/* ns4:OlapInfo */
class SOAP_CMAC ns4__OlapInfo
{
public:
	class ns4__CubeInfo *CubeInfo;	/* optional element of type ns4:CubeInfo */
	class ns4__AxesInfo *AxesInfo;	/* optional element of type ns4:AxesInfo */
	class ns4__CellInfo *CellInfo;	/* optional element of type ns4:CellInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE_ns4__OlapInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__OlapInfo() { ns4__OlapInfo::soap_default(NULL); }
	virtual ~ns4__OlapInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__CubeInfo
#define SOAP_TYPE_ns4__CubeInfo (179)
/* ns4:CubeInfo */
class SOAP_CMAC ns4__CubeInfo
{
public:
	std::vector<class ns4__Cube * >Cube;	/* optional element of type ns4:Cube */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE_ns4__CubeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__CubeInfo() { ns4__CubeInfo::soap_default(NULL); }
	virtual ~ns4__CubeInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Cube
#define SOAP_TYPE_ns4__Cube (180)
/* ns4:Cube */
class SOAP_CMAC ns4__Cube
{
public:
	std::string *CubeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE_ns4__Cube */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Cube() { ns4__Cube::soap_default(NULL); }
	virtual ~ns4__Cube() { }
};
#endif

#ifndef SOAP_TYPE_ns4__AxesInfo
#define SOAP_TYPE_ns4__AxesInfo (181)
/* ns4:AxesInfo */
class SOAP_CMAC ns4__AxesInfo
{
public:
	std::vector<class ns4__AxisInfo * >AxisInfo;	/* optional element of type ns4:AxisInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE_ns4__AxesInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__AxesInfo() { ns4__AxesInfo::soap_default(NULL); }
	virtual ~ns4__AxesInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__AxisInfo
#define SOAP_TYPE_ns4__AxisInfo (182)
/* ns4:AxisInfo */
class SOAP_CMAC ns4__AxisInfo
{
public:
	std::vector<class ns4__HierarchyInfo * >HierarchyInfo;	/* optional element of type ns4:HierarchyInfo */
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_ns4__AxisInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__AxisInfo() { ns4__AxisInfo::soap_default(NULL); }
	virtual ~ns4__AxisInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HierarchyInfo
#define SOAP_TYPE_ns4__HierarchyInfo (183)
/* ns4:HierarchyInfo */
class SOAP_CMAC ns4__HierarchyInfo
{
public:
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE_ns4__HierarchyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HierarchyInfo() { ns4__HierarchyInfo::soap_default(NULL); }
	virtual ~ns4__HierarchyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__CellInfo
#define SOAP_TYPE_ns4__CellInfo (184)
/* ns4:CellInfo */
class SOAP_CMAC ns4__CellInfo
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_ns4__CellInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__CellInfo() { ns4__CellInfo::soap_default(NULL); }
	virtual ~ns4__CellInfo() { }
};
#endif

#ifndef SOAP_TYPE___ns5__union_ResultXmlRoot
#define SOAP_TYPE___ns5__union_ResultXmlRoot (281)
/* Operation wrapper: */
class SOAP_CMAC __ns5__union_ResultXmlRoot
{
public:
	class ns5__CellData *CellData;	/* optional element of type ns5:CellData */
	class ns5__Axes *Axes;	/* optional element of type ns5:Axes */
	class ns5__Row *row;	/* optional element of type ns5:Row */
	class ns5__OlapInfo *OlapInfo;	/* optional element of type ns5:OlapInfo */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE___ns5__union_ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns5__union_ResultXmlRoot() { __ns5__union_ResultXmlRoot::soap_default(NULL); }
	virtual ~__ns5__union_ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ResultXmlRoot
#define SOAP_TYPE_ns5__ResultXmlRoot (185)
/* ns5:ResultXmlRoot */
class SOAP_CMAC ns5__ResultXmlRoot
{
public:
	char *xsd__schema;	/* optional element of type xsd:schema */
	int __size_ResultXmlRoot;	/* sequence of elements <-union-ResultXmlRoot> */
	__ns5__union_ResultXmlRoot *__union_ResultXmlRoot;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_ns5__ResultXmlRoot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ResultXmlRoot() { ns5__ResultXmlRoot::soap_default(NULL); }
	virtual ~ns5__ResultXmlRoot() { }
};
#endif

#ifndef SOAP_TYPE_ns5__CellData
#define SOAP_TYPE_ns5__CellData (186)
/* ns5:CellData */
class SOAP_CMAC ns5__CellData
{
public:
	std::vector<class ns5__Cell * >Cell;	/* optional element of type ns5:Cell */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_ns5__CellData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__CellData() { ns5__CellData::soap_default(NULL); }
	virtual ~ns5__CellData() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Cell
#define SOAP_TYPE_ns5__Cell (187)
/* ns5:Cell */
class SOAP_CMAC ns5__Cell
{
public:
	double *Value;	/* optional element of type xsd:double */
	std::vector<char * >__any;
	int CellOrdinal;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_ns5__Cell */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Cell() { ns5__Cell::soap_default(NULL); }
	virtual ~ns5__Cell() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Axes
#define SOAP_TYPE_ns5__Axes (188)
/* ns5:Axes */
class SOAP_CMAC ns5__Axes
{
public:
	std::vector<class ns5__Axis * >Axis;	/* optional element of type ns5:Axis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_ns5__Axes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Axes() { ns5__Axes::soap_default(NULL); }
	virtual ~ns5__Axes() { }
};
#endif

#ifndef SOAP_TYPE___ns5__union_Axis
#define SOAP_TYPE___ns5__union_Axis (291)
/* Operation wrapper: */
class SOAP_CMAC __ns5__union_Axis
{
public:
	class ns5__Tuples *Tuples;	/* optional element of type ns5:Tuples */
	class ns5__CrossProduct *CrossProduct;	/* optional element of type ns5:CrossProduct */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE___ns5__union_Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns5__union_Axis() { __ns5__union_Axis::soap_default(NULL); }
	virtual ~__ns5__union_Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Axis
#define SOAP_TYPE_ns5__Axis (189)
/* ns5:Axis */
class SOAP_CMAC ns5__Axis
{
public:
	int __size_Axis;	/* sequence of elements <-union-Axis> */
	__ns5__union_Axis *__union_Axis;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_ns5__Axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Axis() { ns5__Axis::soap_default(NULL); }
	virtual ~ns5__Axis() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Tuples
#define SOAP_TYPE_ns5__Tuples (190)
/* ns5:Tuples */
class SOAP_CMAC ns5__Tuples
{
public:
	std::vector<class ns5__Tuple * >Tuple;	/* optional element of type ns5:Tuple */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_ns5__Tuples */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Tuples() { ns5__Tuples::soap_default(NULL); }
	virtual ~ns5__Tuples() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Tuple
#define SOAP_TYPE_ns5__Tuple (191)
/* ns5:Tuple */
class SOAP_CMAC ns5__Tuple
{
public:
	std::vector<class ns5__Member * >Member;	/* optional element of type ns5:Member */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_ns5__Tuple */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Tuple() { ns5__Tuple::soap_default(NULL); }
	virtual ~ns5__Tuple() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Member
#define SOAP_TYPE_ns5__Member (192)
/* ns5:Member */
class SOAP_CMAC ns5__Member
{
public:
	std::string *UName;	/* optional element of type xsd:string */
	std::string *Caption;	/* optional element of type xsd:string */
	std::string *LName;	/* optional element of type xsd:string */
	std::string *LNum;	/* optional element of type xsd:string */
	std::string *DisplayInfo;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_ns5__Member */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Member() { ns5__Member::soap_default(NULL); }
	virtual ~ns5__Member() { }
};
#endif

#ifndef SOAP_TYPE_ns5__CrossProduct
#define SOAP_TYPE_ns5__CrossProduct (193)
/* ns5:CrossProduct */
class SOAP_CMAC ns5__CrossProduct
{
public:
	std::vector<class ns5__Members * >Members;	/* optional element of type ns5:Members */
	int Size;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_ns5__CrossProduct */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__CrossProduct() { ns5__CrossProduct::soap_default(NULL); }
	virtual ~ns5__CrossProduct() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Members
#define SOAP_TYPE_ns5__Members (194)
/* ns5:Members */
class SOAP_CMAC ns5__Members
{
public:
	std::vector<ns5__Member * >Member;	/* optional element of type ns5:Member */
	std::string *Hierarchy;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_ns5__Members */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Members() { ns5__Members::soap_default(NULL); }
	virtual ~ns5__Members() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Row
#define SOAP_TYPE_ns5__Row (195)
/* ns5:Row */
class SOAP_CMAC ns5__Row
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_ns5__Row */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Row() { ns5__Row::soap_default(NULL); }
	virtual ~ns5__Row() { }
};
#endif

#ifndef SOAP_TYPE_ns5__OlapInfo
#define SOAP_TYPE_ns5__OlapInfo (196)
/* ns5:OlapInfo */
class SOAP_CMAC ns5__OlapInfo
{
public:
	class ns5__CubeInfo *CubeInfo;	/* optional element of type ns5:CubeInfo */
	class ns5__AxesInfo *AxesInfo;	/* optional element of type ns5:AxesInfo */
	class ns5__CellInfo *CellInfo;	/* optional element of type ns5:CellInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_ns5__OlapInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__OlapInfo() { ns5__OlapInfo::soap_default(NULL); }
	virtual ~ns5__OlapInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns5__CubeInfo
#define SOAP_TYPE_ns5__CubeInfo (197)
/* ns5:CubeInfo */
class SOAP_CMAC ns5__CubeInfo
{
public:
	std::vector<class ns5__Cube * >Cube;	/* optional element of type ns5:Cube */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_ns5__CubeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__CubeInfo() { ns5__CubeInfo::soap_default(NULL); }
	virtual ~ns5__CubeInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Cube
#define SOAP_TYPE_ns5__Cube (198)
/* ns5:Cube */
class SOAP_CMAC ns5__Cube
{
public:
	std::string *CubeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_ns5__Cube */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Cube() { ns5__Cube::soap_default(NULL); }
	virtual ~ns5__Cube() { }
};
#endif

#ifndef SOAP_TYPE_ns5__AxesInfo
#define SOAP_TYPE_ns5__AxesInfo (199)
/* ns5:AxesInfo */
class SOAP_CMAC ns5__AxesInfo
{
public:
	std::vector<class ns5__AxisInfo * >AxisInfo;	/* optional element of type ns5:AxisInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_ns5__AxesInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__AxesInfo() { ns5__AxesInfo::soap_default(NULL); }
	virtual ~ns5__AxesInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns5__AxisInfo
#define SOAP_TYPE_ns5__AxisInfo (200)
/* ns5:AxisInfo */
class SOAP_CMAC ns5__AxisInfo
{
public:
	std::vector<class ns5__HierarchyInfo * >HierarchyInfo;	/* optional element of type ns5:HierarchyInfo */
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_ns5__AxisInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__AxisInfo() { ns5__AxisInfo::soap_default(NULL); }
	virtual ~ns5__AxisInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns5__HierarchyInfo
#define SOAP_TYPE_ns5__HierarchyInfo (201)
/* ns5:HierarchyInfo */
class SOAP_CMAC ns5__HierarchyInfo
{
public:
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_ns5__HierarchyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__HierarchyInfo() { ns5__HierarchyInfo::soap_default(NULL); }
	virtual ~ns5__HierarchyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns5__CellInfo
#define SOAP_TYPE_ns5__CellInfo (202)
/* ns5:CellInfo */
class SOAP_CMAC ns5__CellInfo
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_ns5__CellInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__CellInfo() { ns5__CellInfo::soap_default(NULL); }
	virtual ~ns5__CellInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Security
#define SOAP_TYPE_ns6__Security (203)
/* ns6:Security */
class SOAP_CMAC ns6__Security
{
public:
	class ns6__UsernameTokenElement *UsernameToken;	/* optional element of type ns6:UsernameTokenElement */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_ns6__Security */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Security() { ns6__Security::soap_default(NULL); }
	virtual ~ns6__Security() { }
};
#endif

#ifndef SOAP_TYPE_ns6__UsernameTokenElement
#define SOAP_TYPE_ns6__UsernameTokenElement (204)
/* ns6:UsernameTokenElement */
class SOAP_CMAC ns6__UsernameTokenElement
{
public:
	std::string *Username;	/* optional element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_ns6__UsernameTokenElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__UsernameTokenElement() { ns6__UsernameTokenElement::soap_default(NULL); }
	virtual ~ns6__UsernameTokenElement() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchema
#define SOAP_TYPE___ns3__union_XmlSchema (311)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchema
{
public:
	std::string *include;	/* optional element of type xsd:XmlSchemaInclude */
	std::string *redefine;	/* optional element of type xsd:XmlSchemaRedefine */
	std::string *import;	/* optional element of type xsd:XmlSchemaImport */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE___ns3__union_XmlSchema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchema() { __ns3__union_XmlSchema::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchema() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchema_
#define SOAP_TYPE___ns3__union_XmlSchema_ (316)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchema_
{
public:
	std::string *notation;	/* optional element of type xsd:XmlSchemaNotation */
	std::string *group;	/* optional element of type xsd:XmlSchemaGroup */
	std::string *annotation;	/* optional element of type xsd:XmlSchemaAnnotation */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroup */
	std::string *complexType;	/* optional element of type xsd:XmlSchemaComplexType */
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *element;	/* optional element of type xsd:XmlSchemaElement */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE___ns3__union_XmlSchema_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchema_() { __ns3__union_XmlSchema_::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchema_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchema
#define SOAP_TYPE_ns3__XmlSchema (109)
/* ns3:XmlSchema */
class SOAP_CMAC ns3__XmlSchema : public std::string
{
public:
	int __size_XmlSchema;	/* sequence of elements <-union-XmlSchema> */
	__ns3__union_XmlSchema *__union_XmlSchema;
	int __size_XmlSchema_;	/* sequence of elements <-union-XmlSchema> */
	__ns3__union_XmlSchema_ *__union_XmlSchema_;
	std::string *attributeFormDefault;	/* optional attribute */
	std::string *blockDefault;	/* optional attribute */
	std::string *finalDefault;	/* optional attribute */
	std::string *elementFormDefault;	/* optional attribute */
	std::string *targetNamespace;	/* optional attribute */
	std::string *version;	/* optional attribute */
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns3__XmlSchema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchema() { ns3__XmlSchema::soap_default(NULL); }
	virtual ~ns3__XmlSchema() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAnnotated
#define SOAP_TYPE_ns3__XmlSchemaAnnotated (111)
/* ns3:XmlSchemaAnnotated */
class SOAP_CMAC ns3__XmlSchemaAnnotated : public std::string
{
public:
	std::string *annotation;	/* optional element of type xsd:XmlSchemaAnnotation */
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAnnotated */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAnnotated() { ns3__XmlSchemaAnnotated::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAnnotated() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaAnnotation
#define SOAP_TYPE___ns3__union_XmlSchemaAnnotation (331)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaAnnotation
{
public:
	std::string *documentation;	/* optional element of type xsd:XmlSchemaDocumentation */
	std::string *appinfo;	/* optional element of type xsd:XmlSchemaAppInfo */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaAnnotation() { __ns3__union_XmlSchemaAnnotation::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAnnotation
#define SOAP_TYPE_ns3__XmlSchemaAnnotation (112)
/* ns3:XmlSchemaAnnotation */
class SOAP_CMAC ns3__XmlSchemaAnnotation : public std::string
{
public:
	int __size_XmlSchemaAnnotation;	/* sequence of elements <-union-XmlSchemaAnnotation> */
	__ns3__union_XmlSchemaAnnotation *__union_XmlSchemaAnnotation;
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAnnotation() { ns3__XmlSchemaAnnotation::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaDocumentation
#define SOAP_TYPE_ns3__XmlSchemaDocumentation (113)
/* ns3:XmlSchemaDocumentation */
class SOAP_CMAC ns3__XmlSchemaDocumentation : public std::string
{
public:
	std::vector<char * >__any;
	std::string *source;	/* optional attribute */
	std::string *xml__lang;	/* optional attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_ns3__XmlSchemaDocumentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaDocumentation() { ns3__XmlSchemaDocumentation::soap_default(NULL); }
	virtual ~ns3__XmlSchemaDocumentation() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAppInfo
#define SOAP_TYPE_ns3__XmlSchemaAppInfo (114)
/* ns3:XmlSchemaAppInfo */
class SOAP_CMAC ns3__XmlSchemaAppInfo : public std::string
{
public:
	std::vector<char * >__any;
	std::string *source;	/* optional attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAppInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAppInfo() { ns3__XmlSchemaAppInfo::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAppInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaNotation
#define SOAP_TYPE_ns3__XmlSchemaNotation (115)
/* ns3:XmlSchemaNotation */
class SOAP_CMAC ns3__XmlSchemaNotation : public std::string
{
public:
	std::string *name;	/* optional attribute */
	std::string *public_;	/* optional attribute */
	std::string *system;	/* optional attribute */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_ns3__XmlSchemaNotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaNotation() { ns3__XmlSchemaNotation::soap_default(NULL); }
	virtual ~ns3__XmlSchemaNotation() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup
#define SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup (336)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaAttributeGroup
{
public:
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaAttributeGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaAttributeGroup() { __ns3__union_XmlSchemaAttributeGroup::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaAttributeGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAttributeGroup
#define SOAP_TYPE_ns3__XmlSchemaAttributeGroup (116)
/* ns3:XmlSchemaAttributeGroup */
class SOAP_CMAC ns3__XmlSchemaAttributeGroup : public std::string
{
public:
	int __size_XmlSchemaAttributeGroup;	/* sequence of elements <-union-XmlSchemaAttributeGroup> */
	__ns3__union_XmlSchemaAttributeGroup *__union_XmlSchemaAttributeGroup;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	std::string *name;	/* optional attribute */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAttributeGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAttributeGroup() { ns3__XmlSchemaAttributeGroup::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAttributeGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef
#define SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef (117)
/* ns3:XmlSchemaAttributeGroupRef */
class SOAP_CMAC ns3__XmlSchemaAttributeGroupRef : public std::string
{
public:
	std::string *ref;	/* optional attribute */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAttributeGroupRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAttributeGroupRef() { ns3__XmlSchemaAttributeGroupRef::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAttributeGroupRef() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAttribute
#define SOAP_TYPE_ns3__XmlSchemaAttribute (118)
/* ns3:XmlSchemaAttribute */
class SOAP_CMAC ns3__XmlSchemaAttribute : public std::string
{
public:
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *default_;	/* optional attribute */
	std::string *fixed;	/* optional attribute */
	std::string *form;	/* optional attribute */
	std::string *name;	/* optional attribute */
	std::string *ref;	/* optional attribute */
	std::string *type;	/* optional attribute */
	std::string *use;	/* optional attribute */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAttribute() { ns3__XmlSchemaAttribute::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleType
#define SOAP_TYPE_ns3__XmlSchemaSimpleType (119)
/* ns3:XmlSchemaSimpleType */
class SOAP_CMAC ns3__XmlSchemaSimpleType : public std::string
{
public:
	std::string *union_;	/* optional element of type xsd:XmlSchemaSimpleTypeUnion */
	std::string *list;	/* optional element of type xsd:XmlSchemaSimpleTypeList */
	std::string *restriction;	/* optional element of type xsd:XmlSchemaSimpleTypeRestriction */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleType() { ns3__XmlSchemaSimpleType::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaType
#define SOAP_TYPE_ns3__XmlSchemaType (120)
/* ns3:XmlSchemaType */
class SOAP_CMAC ns3__XmlSchemaType : public std::string
{
public:
	std::string *name;	/* optional attribute */
	std::string *final;	/* optional attribute */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_ns3__XmlSchemaType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaType() { ns3__XmlSchemaType::soap_default(NULL); }
	virtual ~ns3__XmlSchemaType() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaComplexType__
#define SOAP_TYPE___ns3__union_XmlSchemaComplexType__ (351)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaComplexType__
{
public:
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaComplexType__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaComplexType__() { __ns3__union_XmlSchemaComplexType__::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaComplexType__() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaComplexType
#define SOAP_TYPE_ns3__XmlSchemaComplexType (121)
/* ns3:XmlSchemaComplexType */
class SOAP_CMAC ns3__XmlSchemaComplexType : public std::string
{
public:
	std::string *simpleContent;	/* optional element of type xsd:XmlSchemaSimpleContent */
	std::string *complexContent;	/* optional element of type xsd:XmlSchemaComplexContent */
	std::string *group;	/* optional element of type xsd:XmlSchemaGroupRef */
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
	std::string *all;	/* optional element of type xsd:XmlSchemaAll */
	int __size_XmlSchemaComplexType__;	/* sequence of elements <-union-XmlSchemaComplexType> */
	__ns3__union_XmlSchemaComplexType__ *__union_XmlSchemaComplexType__;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	bool abstract;	/* optional attribute */
	std::string *block;	/* optional attribute */
	bool mixed;	/* optional attribute */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_ns3__XmlSchemaComplexType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaComplexType() { ns3__XmlSchemaComplexType::soap_default(NULL); }
	virtual ~ns3__XmlSchemaComplexType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleContent
#define SOAP_TYPE_ns3__XmlSchemaSimpleContent (122)
/* ns3:XmlSchemaSimpleContent */
class SOAP_CMAC ns3__XmlSchemaSimpleContent : public std::string
{
public:
	std::string *restriction;	/* optional element of type xsd:XmlSchemaSimpleContentRestriction */
	std::string *extension;	/* optional element of type xsd:XmlSchemaSimpleContentExtension */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleContent() { ns3__XmlSchemaSimpleContent::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleContent() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaContentModel
#define SOAP_TYPE_ns3__XmlSchemaContentModel (123)
/* ns3:XmlSchemaContentModel */
class SOAP_CMAC ns3__XmlSchemaContentModel : public std::string
{
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns3__XmlSchemaContentModel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaContentModel() { ns3__XmlSchemaContentModel::soap_default(NULL); }
	virtual ~ns3__XmlSchemaContentModel() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaComplexContent
#define SOAP_TYPE_ns3__XmlSchemaComplexContent (124)
/* ns3:XmlSchemaComplexContent */
class SOAP_CMAC ns3__XmlSchemaComplexContent : public std::string
{
public:
	std::string *restriction;	/* optional element of type xsd:XmlSchemaComplexContentRestriction */
	std::string *extension;	/* optional element of type xsd:XmlSchemaComplexContentExtension */
	bool mixed;	/* required attribute */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_ns3__XmlSchemaComplexContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaComplexContent() { ns3__XmlSchemaComplexContent::soap_default(NULL); }
	virtual ~ns3__XmlSchemaComplexContent() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_
#define SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_ (358)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaComplexContentRestriction_
{
public:
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaComplexContentRestriction_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaComplexContentRestriction_() { __ns3__union_XmlSchemaComplexContentRestriction_::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaComplexContentRestriction_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction
#define SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction (125)
/* ns3:XmlSchemaComplexContentRestriction */
class SOAP_CMAC ns3__XmlSchemaComplexContentRestriction : public std::string
{
public:
	std::string *all;	/* optional element of type xsd:XmlSchemaAll */
	std::string *group;	/* optional element of type xsd:XmlSchemaGroupRef */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	int __size_XmlSchemaComplexContentRestriction_;	/* sequence of elements <-union-XmlSchemaComplexContentRestriction> */
	__ns3__union_XmlSchemaComplexContentRestriction_ *__union_XmlSchemaComplexContentRestriction_;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	std::string *base;	/* optional attribute */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE_ns3__XmlSchemaComplexContentRestriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaComplexContentRestriction() { ns3__XmlSchemaComplexContentRestriction::soap_default(NULL); }
	virtual ~ns3__XmlSchemaComplexContentRestriction() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaContent
#define SOAP_TYPE_ns3__XmlSchemaContent (126)
/* ns3:XmlSchemaContent */
class SOAP_CMAC ns3__XmlSchemaContent : public std::string
{
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE_ns3__XmlSchemaContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaContent() { ns3__XmlSchemaContent::soap_default(NULL); }
	virtual ~ns3__XmlSchemaContent() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_
#define SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_ (360)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaComplexContentExtension_
{
public:
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaComplexContentExtension_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaComplexContentExtension_() { __ns3__union_XmlSchemaComplexContentExtension_::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaComplexContentExtension_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaComplexContentExtension
#define SOAP_TYPE_ns3__XmlSchemaComplexContentExtension (127)
/* ns3:XmlSchemaComplexContentExtension */
class SOAP_CMAC ns3__XmlSchemaComplexContentExtension : public std::string
{
public:
	std::string *group;	/* optional element of type xsd:XmlSchemaGroupRef */
	std::string *all;	/* optional element of type xsd:XmlSchemaAll */
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
	int __size_XmlSchemaComplexContentExtension_;	/* sequence of elements <-union-XmlSchemaComplexContentExtension> */
	__ns3__union_XmlSchemaComplexContentExtension_ *__union_XmlSchemaComplexContentExtension_;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	std::string *base;	/* optional attribute */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE_ns3__XmlSchemaComplexContentExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaComplexContentExtension() { ns3__XmlSchemaComplexContentExtension::soap_default(NULL); }
	virtual ~ns3__XmlSchemaComplexContentExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaGroupRef
#define SOAP_TYPE_ns3__XmlSchemaGroupRef (128)
/* ns3:XmlSchemaGroupRef */
class SOAP_CMAC ns3__XmlSchemaGroupRef : public std::string
{
public:
	std::string *ref;	/* optional attribute */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE_ns3__XmlSchemaGroupRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaGroupRef() { ns3__XmlSchemaGroupRef::soap_default(NULL); }
	virtual ~ns3__XmlSchemaGroupRef() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaParticle
#define SOAP_TYPE_ns3__XmlSchemaParticle (129)
/* ns3:XmlSchemaParticle */
class SOAP_CMAC ns3__XmlSchemaParticle : public std::string
{
public:
	std::string *minOccurs;	/* optional attribute */
	std::string *maxOccurs;	/* optional attribute */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE_ns3__XmlSchemaParticle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaParticle() { ns3__XmlSchemaParticle::soap_default(NULL); }
	virtual ~ns3__XmlSchemaParticle() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaElement_
#define SOAP_TYPE___ns3__union_XmlSchemaElement_ (362)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaElement_
{
public:
	std::string *unique;	/* optional element of type xsd:XmlSchemaUnique */
	std::string *key;	/* optional element of type xsd:XmlSchemaKey */
	std::string *keyref;	/* optional element of type xsd:XmlSchemaKeyref */
public:
	virtual int soap_type() const { return 362; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaElement_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaElement_() { __ns3__union_XmlSchemaElement_::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaElement_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaElement
#define SOAP_TYPE_ns3__XmlSchemaElement (130)
/* ns3:XmlSchemaElement */
class SOAP_CMAC ns3__XmlSchemaElement : public std::string
{
public:
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *complexType;	/* optional element of type xsd:XmlSchemaComplexType */
	int __size_XmlSchemaElement_;	/* sequence of elements <-union-XmlSchemaElement> */
	__ns3__union_XmlSchemaElement_ *__union_XmlSchemaElement_;
	bool abstract;	/* optional attribute */
	std::string *block;	/* optional attribute */
	std::string *default_;	/* optional attribute */
	std::string *final;	/* optional attribute */
	std::string *fixed;	/* optional attribute */
	std::string *form;	/* optional attribute */
	std::string name;	/* optional attribute */
	bool nillable;	/* optional attribute */
	std::string *ref;	/* optional attribute */
	std::string *substitutionGroup;	/* optional attribute */
	std::string *type;	/* optional attribute */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE_ns3__XmlSchemaElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaElement() { ns3__XmlSchemaElement::soap_default(NULL); }
	virtual ~ns3__XmlSchemaElement() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaUnique
#define SOAP_TYPE_ns3__XmlSchemaUnique (131)
/* ns3:XmlSchemaUnique */
class SOAP_CMAC ns3__XmlSchemaUnique : public std::string
{
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_ns3__XmlSchemaUnique */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaUnique() { ns3__XmlSchemaUnique::soap_default(NULL); }
	virtual ~ns3__XmlSchemaUnique() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaIdentityConstraint
#define SOAP_TYPE_ns3__XmlSchemaIdentityConstraint (132)
/* ns3:XmlSchemaIdentityConstraint */
class SOAP_CMAC ns3__XmlSchemaIdentityConstraint : public std::string
{
public:
	std::string *selector;	/* optional element of type xsd:XmlSchemaXPath */
	std::vector<std::string >field;	/* optional element of type xsd:XmlSchemaXPath */
	std::string *name;	/* optional attribute */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE_ns3__XmlSchemaIdentityConstraint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaIdentityConstraint() { ns3__XmlSchemaIdentityConstraint::soap_default(NULL); }
	virtual ~ns3__XmlSchemaIdentityConstraint() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaXPath
#define SOAP_TYPE_ns3__XmlSchemaXPath (133)
/* ns3:XmlSchemaXPath */
class SOAP_CMAC ns3__XmlSchemaXPath : public std::string
{
public:
	std::string xpath;	/* optional attribute */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE_ns3__XmlSchemaXPath */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaXPath() { ns3__XmlSchemaXPath::soap_default(NULL); }
	virtual ~ns3__XmlSchemaXPath() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaKeyref
#define SOAP_TYPE_ns3__XmlSchemaKeyref (134)
/* ns3:XmlSchemaKeyref */
class SOAP_CMAC ns3__XmlSchemaKeyref : public std::string
{
public:
	std::string *refer;	/* optional attribute */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE_ns3__XmlSchemaKeyref */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaKeyref() { ns3__XmlSchemaKeyref::soap_default(NULL); }
	virtual ~ns3__XmlSchemaKeyref() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaKey
#define SOAP_TYPE_ns3__XmlSchemaKey (135)
/* ns3:XmlSchemaKey */
class SOAP_CMAC ns3__XmlSchemaKey : public std::string
{
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE_ns3__XmlSchemaKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaKey() { ns3__XmlSchemaKey::soap_default(NULL); }
	virtual ~ns3__XmlSchemaKey() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAny
#define SOAP_TYPE_ns3__XmlSchemaAny (136)
/* ns3:XmlSchemaAny */
class SOAP_CMAC ns3__XmlSchemaAny : public std::string
{
public:
	std::string *namespace_;	/* optional attribute */
	std::string *processContents;	/* optional attribute */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAny */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAny() { ns3__XmlSchemaAny::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAny() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaGroupBase
#define SOAP_TYPE_ns3__XmlSchemaGroupBase (137)
/* ns3:XmlSchemaGroupBase */
class SOAP_CMAC ns3__XmlSchemaGroupBase : public std::string
{
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE_ns3__XmlSchemaGroupBase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaGroupBase() { ns3__XmlSchemaGroupBase::soap_default(NULL); }
	virtual ~ns3__XmlSchemaGroupBase() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaChoice
#define SOAP_TYPE___ns3__union_XmlSchemaChoice (370)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaChoice
{
public:
	std::string *any;	/* optional element of type xsd:XmlSchemaAny */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	std::string *element;	/* optional element of type xsd:XmlSchemaElement */
	std::string *group;	/* optional element of type xsd:XmlSchemaGroupRef */
public:
	virtual int soap_type() const { return 370; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaChoice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaChoice() { __ns3__union_XmlSchemaChoice::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaChoice() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaChoice
#define SOAP_TYPE_ns3__XmlSchemaChoice (138)
/* ns3:XmlSchemaChoice */
class SOAP_CMAC ns3__XmlSchemaChoice : public std::string
{
public:
	int __size_XmlSchemaChoice;	/* sequence of elements <-union-XmlSchemaChoice> */
	__ns3__union_XmlSchemaChoice *__union_XmlSchemaChoice;
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_ns3__XmlSchemaChoice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaChoice() { ns3__XmlSchemaChoice::soap_default(NULL); }
	virtual ~ns3__XmlSchemaChoice() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaSequence
#define SOAP_TYPE___ns3__union_XmlSchemaSequence (373)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaSequence
{
public:
	std::string *group;	/* optional element of type xsd:XmlSchemaGroupRef */
	std::string *any;	/* optional element of type xsd:XmlSchemaAny */
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	std::string *element;	/* optional element of type xsd:XmlSchemaElement */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
public:
	virtual int soap_type() const { return 373; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaSequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaSequence() { __ns3__union_XmlSchemaSequence::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaSequence() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSequence
#define SOAP_TYPE_ns3__XmlSchemaSequence (139)
/* ns3:XmlSchemaSequence */
class SOAP_CMAC ns3__XmlSchemaSequence : public std::string
{
public:
	int __size_XmlSchemaSequence;	/* sequence of elements <-union-XmlSchemaSequence> */
	__ns3__union_XmlSchemaSequence *__union_XmlSchemaSequence;
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSequence() { ns3__XmlSchemaSequence::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSequence() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAll
#define SOAP_TYPE_ns3__XmlSchemaAll (140)
/* ns3:XmlSchemaAll */
class SOAP_CMAC ns3__XmlSchemaAll : public std::string
{
public:
	std::vector<std::string >element;	/* optional element of type xsd:XmlSchemaElement */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAll */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAll() { ns3__XmlSchemaAll::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAll() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaAnyAttribute
#define SOAP_TYPE_ns3__XmlSchemaAnyAttribute (141)
/* ns3:XmlSchemaAnyAttribute */
class SOAP_CMAC ns3__XmlSchemaAnyAttribute : public std::string
{
public:
	std::string *namespace_;	/* optional attribute */
	std::string *processContents;	/* optional attribute */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE_ns3__XmlSchemaAnyAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaAnyAttribute() { ns3__XmlSchemaAnyAttribute::soap_default(NULL); }
	virtual ~ns3__XmlSchemaAnyAttribute() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension
#define SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension (376)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaSimpleContentExtension
{
public:
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
public:
	virtual int soap_type() const { return 376; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaSimpleContentExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaSimpleContentExtension() { __ns3__union_XmlSchemaSimpleContentExtension::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaSimpleContentExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension
#define SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension (142)
/* ns3:XmlSchemaSimpleContentExtension */
class SOAP_CMAC ns3__XmlSchemaSimpleContentExtension : public std::string
{
public:
	int __size_XmlSchemaSimpleContentExtension;	/* sequence of elements <-union-XmlSchemaSimpleContentExtension> */
	__ns3__union_XmlSchemaSimpleContentExtension *__union_XmlSchemaSimpleContentExtension;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	std::string *base;	/* optional attribute */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleContentExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleContentExtension() { ns3__XmlSchemaSimpleContentExtension::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleContentExtension() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction
#define SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction (378)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaSimpleContentRestriction
{
public:
	std::string *minExclusive;	/* optional element of type xsd:XmlSchemaMinExclusiveFacet */
	std::string *enumeration;	/* optional element of type xsd:XmlSchemaEnumerationFacet */
	std::string *maxInclusive;	/* optional element of type xsd:XmlSchemaMaxInclusiveFacet */
	std::string *length;	/* optional element of type xsd:XmlSchemaLengthFacet */
	std::string *minLength;	/* optional element of type xsd:XmlSchemaMinLengthFacet */
	std::string *maxLength;	/* optional element of type xsd:XmlSchemaMaxLengthFacet */
	std::string *pattern;	/* optional element of type xsd:XmlSchemaPatternFacet */
	std::string *maxExclusive;	/* optional element of type xsd:XmlSchemaMaxExclusiveFacet */
	std::string *minInclusive;	/* optional element of type xsd:XmlSchemaMinInclusiveFacet */
	std::string *whiteSpace;	/* optional element of type xsd:XmlSchemaWhiteSpaceFacet */
	std::string *totalDigits;	/* optional element of type xsd:XmlSchemaTotalDigitsFacet */
	std::string *fractionDigits;	/* optional element of type xsd:XmlSchemaFractionDigitsFacet */
public:
	virtual int soap_type() const { return 378; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaSimpleContentRestriction() { __ns3__union_XmlSchemaSimpleContentRestriction::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaSimpleContentRestriction() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_
#define SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_ (392)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaSimpleContentRestriction_
{
public:
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroupRef */
	std::string *attribute;	/* optional element of type xsd:XmlSchemaAttribute */
public:
	virtual int soap_type() const { return 392; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaSimpleContentRestriction_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaSimpleContentRestriction_() { __ns3__union_XmlSchemaSimpleContentRestriction_::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaSimpleContentRestriction_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction
#define SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction (143)
/* ns3:XmlSchemaSimpleContentRestriction */
class SOAP_CMAC ns3__XmlSchemaSimpleContentRestriction : public std::string
{
public:
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	int __size_XmlSchemaSimpleContentRestriction;	/* sequence of elements <-union-XmlSchemaSimpleContentRestriction> */
	__ns3__union_XmlSchemaSimpleContentRestriction *__union_XmlSchemaSimpleContentRestriction;
	int __size_XmlSchemaSimpleContentRestriction_;	/* sequence of elements <-union-XmlSchemaSimpleContentRestriction> */
	__ns3__union_XmlSchemaSimpleContentRestriction_ *__union_XmlSchemaSimpleContentRestriction_;
	std::string *anyAttribute;	/* optional element of type xsd:XmlSchemaAnyAttribute */
	std::string *base;	/* optional attribute */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleContentRestriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleContentRestriction() { ns3__XmlSchemaSimpleContentRestriction::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleContentRestriction() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet
#define SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet (144)
/* ns3:XmlSchemaMinExclusiveFacet */
class SOAP_CMAC ns3__XmlSchemaMinExclusiveFacet : public std::string
{
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMinExclusiveFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMinExclusiveFacet() { ns3__XmlSchemaMinExclusiveFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMinExclusiveFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaFacet
#define SOAP_TYPE_ns3__XmlSchemaFacet (145)
/* ns3:XmlSchemaFacet */
class SOAP_CMAC ns3__XmlSchemaFacet : public std::string
{
public:
	std::string *value;	/* optional attribute */
	bool fixed;	/* optional attribute */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE_ns3__XmlSchemaFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaFacet() { ns3__XmlSchemaFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet
#define SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet (146)
/* ns3:XmlSchemaWhiteSpaceFacet */
class SOAP_CMAC ns3__XmlSchemaWhiteSpaceFacet : public std::string
{
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE_ns3__XmlSchemaWhiteSpaceFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaWhiteSpaceFacet() { ns3__XmlSchemaWhiteSpaceFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaWhiteSpaceFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaEnumerationFacet
#define SOAP_TYPE_ns3__XmlSchemaEnumerationFacet (147)
/* ns3:XmlSchemaEnumerationFacet */
class SOAP_CMAC ns3__XmlSchemaEnumerationFacet : public std::string
{
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_ns3__XmlSchemaEnumerationFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaEnumerationFacet() { ns3__XmlSchemaEnumerationFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaEnumerationFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaPatternFacet
#define SOAP_TYPE_ns3__XmlSchemaPatternFacet (148)
/* ns3:XmlSchemaPatternFacet */
class SOAP_CMAC ns3__XmlSchemaPatternFacet : public std::string
{
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_ns3__XmlSchemaPatternFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaPatternFacet() { ns3__XmlSchemaPatternFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaPatternFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaNumericFacet
#define SOAP_TYPE_ns3__XmlSchemaNumericFacet (149)
/* ns3:XmlSchemaNumericFacet */
class SOAP_CMAC ns3__XmlSchemaNumericFacet : public std::string
{
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_ns3__XmlSchemaNumericFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaNumericFacet() { ns3__XmlSchemaNumericFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaNumericFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet
#define SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet (150)
/* ns3:XmlSchemaFractionDigitsFacet */
class SOAP_CMAC ns3__XmlSchemaFractionDigitsFacet : public std::string
{
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE_ns3__XmlSchemaFractionDigitsFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaFractionDigitsFacet() { ns3__XmlSchemaFractionDigitsFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaFractionDigitsFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet
#define SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet (151)
/* ns3:XmlSchemaTotalDigitsFacet */
class SOAP_CMAC ns3__XmlSchemaTotalDigitsFacet : public std::string
{
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_ns3__XmlSchemaTotalDigitsFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaTotalDigitsFacet() { ns3__XmlSchemaTotalDigitsFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaTotalDigitsFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaLengthFacet
#define SOAP_TYPE_ns3__XmlSchemaLengthFacet (152)
/* ns3:XmlSchemaLengthFacet */
class SOAP_CMAC ns3__XmlSchemaLengthFacet : public std::string
{
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_ns3__XmlSchemaLengthFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaLengthFacet() { ns3__XmlSchemaLengthFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaLengthFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet
#define SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet (153)
/* ns3:XmlSchemaMaxLengthFacet */
class SOAP_CMAC ns3__XmlSchemaMaxLengthFacet : public std::string
{
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMaxLengthFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMaxLengthFacet() { ns3__XmlSchemaMaxLengthFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMaxLengthFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMinLengthFacet
#define SOAP_TYPE_ns3__XmlSchemaMinLengthFacet (154)
/* ns3:XmlSchemaMinLengthFacet */
class SOAP_CMAC ns3__XmlSchemaMinLengthFacet : public std::string
{
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMinLengthFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMinLengthFacet() { ns3__XmlSchemaMinLengthFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMinLengthFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet
#define SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet (155)
/* ns3:XmlSchemaMaxInclusiveFacet */
class SOAP_CMAC ns3__XmlSchemaMaxInclusiveFacet : public std::string
{
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMaxInclusiveFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMaxInclusiveFacet() { ns3__XmlSchemaMaxInclusiveFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMaxInclusiveFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet
#define SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet (156)
/* ns3:XmlSchemaMinInclusiveFacet */
class SOAP_CMAC ns3__XmlSchemaMinInclusiveFacet : public std::string
{
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMinInclusiveFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMinInclusiveFacet() { ns3__XmlSchemaMinInclusiveFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMinInclusiveFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet
#define SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet (157)
/* ns3:XmlSchemaMaxExclusiveFacet */
class SOAP_CMAC ns3__XmlSchemaMaxExclusiveFacet : public std::string
{
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE_ns3__XmlSchemaMaxExclusiveFacet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaMaxExclusiveFacet() { ns3__XmlSchemaMaxExclusiveFacet::soap_default(NULL); }
	virtual ~ns3__XmlSchemaMaxExclusiveFacet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion
#define SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion (158)
/* ns3:XmlSchemaSimpleTypeUnion */
class SOAP_CMAC ns3__XmlSchemaSimpleTypeUnion : public std::string
{
public:
	std::vector<std::string >simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *memberTypes;	/* optional attribute */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleTypeUnion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleTypeUnion() { ns3__XmlSchemaSimpleTypeUnion::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleTypeUnion() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent
#define SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent (159)
/* ns3:XmlSchemaSimpleTypeContent */
class SOAP_CMAC ns3__XmlSchemaSimpleTypeContent : public std::string
{
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleTypeContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleTypeContent() { ns3__XmlSchemaSimpleTypeContent::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleTypeContent() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction
#define SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction (395)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaSimpleTypeRestriction
{
public:
	std::string *maxExclusive;	/* optional element of type xsd:XmlSchemaMaxExclusiveFacet */
	std::string *minInclusive;	/* optional element of type xsd:XmlSchemaMinInclusiveFacet */
	std::string *maxInclusive;	/* optional element of type xsd:XmlSchemaMaxInclusiveFacet */
	std::string *minExclusive;	/* optional element of type xsd:XmlSchemaMinExclusiveFacet */
	std::string *minLength;	/* optional element of type xsd:XmlSchemaMinLengthFacet */
	std::string *maxLength;	/* optional element of type xsd:XmlSchemaMaxLengthFacet */
	std::string *pattern;	/* optional element of type xsd:XmlSchemaPatternFacet */
	std::string *enumeration;	/* optional element of type xsd:XmlSchemaEnumerationFacet */
	std::string *length;	/* optional element of type xsd:XmlSchemaLengthFacet */
	std::string *whiteSpace;	/* optional element of type xsd:XmlSchemaWhiteSpaceFacet */
	std::string *totalDigits;	/* optional element of type xsd:XmlSchemaTotalDigitsFacet */
	std::string *fractionDigits;	/* optional element of type xsd:XmlSchemaFractionDigitsFacet */
public:
	virtual int soap_type() const { return 395; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaSimpleTypeRestriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaSimpleTypeRestriction() { __ns3__union_XmlSchemaSimpleTypeRestriction::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaSimpleTypeRestriction() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction
#define SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction (160)
/* ns3:XmlSchemaSimpleTypeRestriction */
class SOAP_CMAC ns3__XmlSchemaSimpleTypeRestriction : public std::string
{
public:
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	int __size_XmlSchemaSimpleTypeRestriction;	/* sequence of elements <-union-XmlSchemaSimpleTypeRestriction> */
	__ns3__union_XmlSchemaSimpleTypeRestriction *__union_XmlSchemaSimpleTypeRestriction;
	std::string *base;	/* optional attribute */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleTypeRestriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleTypeRestriction() { ns3__XmlSchemaSimpleTypeRestriction::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleTypeRestriction() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaSimpleTypeList
#define SOAP_TYPE_ns3__XmlSchemaSimpleTypeList (161)
/* ns3:XmlSchemaSimpleTypeList */
class SOAP_CMAC ns3__XmlSchemaSimpleTypeList : public std::string
{
public:
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *itemType;	/* optional attribute */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE_ns3__XmlSchemaSimpleTypeList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaSimpleTypeList() { ns3__XmlSchemaSimpleTypeList::soap_default(NULL); }
	virtual ~ns3__XmlSchemaSimpleTypeList() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaGroup
#define SOAP_TYPE_ns3__XmlSchemaGroup (162)
/* ns3:XmlSchemaGroup */
class SOAP_CMAC ns3__XmlSchemaGroup : public std::string
{
public:
	std::string *sequence;	/* optional element of type xsd:XmlSchemaSequence */
	std::string *choice;	/* optional element of type xsd:XmlSchemaChoice */
	std::string *all;	/* optional element of type xsd:XmlSchemaAll */
	std::string *name;	/* optional attribute */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE_ns3__XmlSchemaGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaGroup() { ns3__XmlSchemaGroup::soap_default(NULL); }
	virtual ~ns3__XmlSchemaGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaExternal
#define SOAP_TYPE_ns3__XmlSchemaExternal (163)
/* ns3:XmlSchemaExternal */
class SOAP_CMAC ns3__XmlSchemaExternal : public std::string
{
public:
	std::string *schemaLocation;	/* optional attribute */
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE_ns3__XmlSchemaExternal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaExternal() { ns3__XmlSchemaExternal::soap_default(NULL); }
	virtual ~ns3__XmlSchemaExternal() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaImport
#define SOAP_TYPE_ns3__XmlSchemaImport (164)
/* ns3:XmlSchemaImport */
class SOAP_CMAC ns3__XmlSchemaImport : public std::string
{
public:
	std::string *annotation;	/* optional element of type xsd:XmlSchemaAnnotation */
	std::string *namespace_;	/* optional attribute */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE_ns3__XmlSchemaImport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaImport() { ns3__XmlSchemaImport::soap_default(NULL); }
	virtual ~ns3__XmlSchemaImport() { }
};
#endif

#ifndef SOAP_TYPE___ns3__union_XmlSchemaRedefine
#define SOAP_TYPE___ns3__union_XmlSchemaRedefine (397)
/* Operation wrapper: */
class SOAP_CMAC __ns3__union_XmlSchemaRedefine
{
public:
	std::string *group;	/* optional element of type xsd:XmlSchemaGroup */
	std::string *annotation;	/* optional element of type xsd:XmlSchemaAnnotation */
	std::string *complexType;	/* optional element of type xsd:XmlSchemaComplexType */
	std::string *simpleType;	/* optional element of type xsd:XmlSchemaSimpleType */
	std::string *attributeGroup;	/* optional element of type xsd:XmlSchemaAttributeGroup */
public:
	virtual int soap_type() const { return 397; } /* = unique id SOAP_TYPE___ns3__union_XmlSchemaRedefine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns3__union_XmlSchemaRedefine() { __ns3__union_XmlSchemaRedefine::soap_default(NULL); }
	virtual ~__ns3__union_XmlSchemaRedefine() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaRedefine
#define SOAP_TYPE_ns3__XmlSchemaRedefine (165)
/* ns3:XmlSchemaRedefine */
class SOAP_CMAC ns3__XmlSchemaRedefine : public std::string
{
public:
	int __size_XmlSchemaRedefine;	/* sequence of elements <-union-XmlSchemaRedefine> */
	__ns3__union_XmlSchemaRedefine *__union_XmlSchemaRedefine;
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE_ns3__XmlSchemaRedefine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaRedefine() { ns3__XmlSchemaRedefine::soap_default(NULL); }
	virtual ~ns3__XmlSchemaRedefine() { }
};
#endif

#ifndef SOAP_TYPE_ns3__XmlSchemaInclude
#define SOAP_TYPE_ns3__XmlSchemaInclude (166)
/* ns3:XmlSchemaInclude */
class SOAP_CMAC ns3__XmlSchemaInclude : public std::string
{
public:
	std::string *annotation;	/* optional element of type xsd:XmlSchemaAnnotation */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE_ns3__XmlSchemaInclude */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__XmlSchemaInclude() { ns3__XmlSchemaInclude::soap_default(NULL); }
	virtual ~ns3__XmlSchemaInclude() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (399)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	ns1__BeginSession *ns1__BeginSession_;	/* mustUnderstand */
	ns1__EndSession *ns1__EndSession_;	/* mustUnderstand */
	ns1__Session *ns1__Session_;	/* optional element of type ns1:Session */
	ns6__Security *ns6__Security_;	/* mustUnderstand */
public:
	int soap_type() const { return 399; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef SOAP_TYPE___ns1__Execute
#define SOAP_TYPE___ns1__Execute (407)
/* Operation wrapper: */
struct __ns1__Execute
{
public:
	_ns1__Execute *ns1__Execute;	/* optional element of type ns1:Execute */
public:
	int soap_type() const { return 407; } /* = unique id SOAP_TYPE___ns1__Execute */
};
#endif

#ifndef SOAP_TYPE___ns1__Discover
#define SOAP_TYPE___ns1__Discover (411)
/* Operation wrapper: */
struct __ns1__Discover
{
public:
	_ns1__Discover *ns1__Discover;	/* optional element of type ns1:Discover */
public:
	int soap_type() const { return 411; } /* = unique id SOAP_TYPE___ns1__Discover */
};
#endif

#ifndef SOAP_TYPE___ns1__Execute_
#define SOAP_TYPE___ns1__Execute_ (413)
/* Operation wrapper: */
struct __ns1__Execute_
{
public:
	_ns1__Execute *ns1__Execute;	/* optional element of type ns1:Execute */
public:
	int soap_type() const { return 413; } /* = unique id SOAP_TYPE___ns1__Execute_ */
};
#endif

#ifndef SOAP_TYPE___ns1__Discover_
#define SOAP_TYPE___ns1__Discover_ (415)
/* Operation wrapper: */
struct __ns1__Discover_
{
public:
	_ns1__Discover *ns1__Discover;	/* optional element of type ns1:Discover */
public:
	int soap_type() const { return 415; } /* = unique id SOAP_TYPE___ns1__Discover_ */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (416)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 416; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (418)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 418; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (421)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 421; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (422)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 422; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (10)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchema
#define SOAP_TYPE_xsd__XmlSchema (11)
typedef std::string xsd__XmlSchema;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAll
#define SOAP_TYPE_xsd__XmlSchemaAll (12)
typedef std::string xsd__XmlSchemaAll;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAnnotated
#define SOAP_TYPE_xsd__XmlSchemaAnnotated (13)
typedef std::string xsd__XmlSchemaAnnotated;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAnnotation
#define SOAP_TYPE_xsd__XmlSchemaAnnotation (14)
typedef std::string xsd__XmlSchemaAnnotation;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAny
#define SOAP_TYPE_xsd__XmlSchemaAny (15)
typedef std::string xsd__XmlSchemaAny;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAnyAttribute
#define SOAP_TYPE_xsd__XmlSchemaAnyAttribute (16)
typedef std::string xsd__XmlSchemaAnyAttribute;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAppInfo
#define SOAP_TYPE_xsd__XmlSchemaAppInfo (17)
typedef std::string xsd__XmlSchemaAppInfo;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAttribute
#define SOAP_TYPE_xsd__XmlSchemaAttribute (18)
typedef std::string xsd__XmlSchemaAttribute;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAttributeGroup
#define SOAP_TYPE_xsd__XmlSchemaAttributeGroup (19)
typedef std::string xsd__XmlSchemaAttributeGroup;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef
#define SOAP_TYPE_xsd__XmlSchemaAttributeGroupRef (20)
typedef std::string xsd__XmlSchemaAttributeGroupRef;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaChoice
#define SOAP_TYPE_xsd__XmlSchemaChoice (21)
typedef std::string xsd__XmlSchemaChoice;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaComplexContent
#define SOAP_TYPE_xsd__XmlSchemaComplexContent (22)
typedef std::string xsd__XmlSchemaComplexContent;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaComplexContentExtension
#define SOAP_TYPE_xsd__XmlSchemaComplexContentExtension (23)
typedef std::string xsd__XmlSchemaComplexContentExtension;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction
#define SOAP_TYPE_xsd__XmlSchemaComplexContentRestriction (24)
typedef std::string xsd__XmlSchemaComplexContentRestriction;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaComplexType
#define SOAP_TYPE_xsd__XmlSchemaComplexType (25)
typedef std::string xsd__XmlSchemaComplexType;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaContent
#define SOAP_TYPE_xsd__XmlSchemaContent (26)
typedef std::string xsd__XmlSchemaContent;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaContentModel
#define SOAP_TYPE_xsd__XmlSchemaContentModel (27)
typedef std::string xsd__XmlSchemaContentModel;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaContentProcessing
#define SOAP_TYPE_xsd__XmlSchemaContentProcessing (28)
typedef std::string xsd__XmlSchemaContentProcessing;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaDerivationMethod
#define SOAP_TYPE_xsd__XmlSchemaDerivationMethod (29)
typedef std::string xsd__XmlSchemaDerivationMethod;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaDocumentation
#define SOAP_TYPE_xsd__XmlSchemaDocumentation (30)
typedef std::string xsd__XmlSchemaDocumentation;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaElement
#define SOAP_TYPE_xsd__XmlSchemaElement (31)
typedef std::string xsd__XmlSchemaElement;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaEnumerationFacet
#define SOAP_TYPE_xsd__XmlSchemaEnumerationFacet (32)
typedef std::string xsd__XmlSchemaEnumerationFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaExternal
#define SOAP_TYPE_xsd__XmlSchemaExternal (33)
typedef std::string xsd__XmlSchemaExternal;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaFacet
#define SOAP_TYPE_xsd__XmlSchemaFacet (34)
typedef std::string xsd__XmlSchemaFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaForm
#define SOAP_TYPE_xsd__XmlSchemaForm (35)
typedef std::string xsd__XmlSchemaForm;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet
#define SOAP_TYPE_xsd__XmlSchemaFractionDigitsFacet (36)
typedef std::string xsd__XmlSchemaFractionDigitsFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaGroup
#define SOAP_TYPE_xsd__XmlSchemaGroup (37)
typedef std::string xsd__XmlSchemaGroup;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaGroupBase
#define SOAP_TYPE_xsd__XmlSchemaGroupBase (38)
typedef std::string xsd__XmlSchemaGroupBase;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaGroupRef
#define SOAP_TYPE_xsd__XmlSchemaGroupRef (39)
typedef std::string xsd__XmlSchemaGroupRef;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaIdentityConstraint
#define SOAP_TYPE_xsd__XmlSchemaIdentityConstraint (40)
typedef std::string xsd__XmlSchemaIdentityConstraint;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaImport
#define SOAP_TYPE_xsd__XmlSchemaImport (41)
typedef std::string xsd__XmlSchemaImport;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaInclude
#define SOAP_TYPE_xsd__XmlSchemaInclude (42)
typedef std::string xsd__XmlSchemaInclude;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaKey
#define SOAP_TYPE_xsd__XmlSchemaKey (43)
typedef std::string xsd__XmlSchemaKey;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaKeyref
#define SOAP_TYPE_xsd__XmlSchemaKeyref (44)
typedef std::string xsd__XmlSchemaKeyref;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaLengthFacet
#define SOAP_TYPE_xsd__XmlSchemaLengthFacet (45)
typedef std::string xsd__XmlSchemaLengthFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet
#define SOAP_TYPE_xsd__XmlSchemaMaxExclusiveFacet (46)
typedef std::string xsd__XmlSchemaMaxExclusiveFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet
#define SOAP_TYPE_xsd__XmlSchemaMaxInclusiveFacet (47)
typedef std::string xsd__XmlSchemaMaxInclusiveFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet
#define SOAP_TYPE_xsd__XmlSchemaMaxLengthFacet (48)
typedef std::string xsd__XmlSchemaMaxLengthFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet
#define SOAP_TYPE_xsd__XmlSchemaMinExclusiveFacet (49)
typedef std::string xsd__XmlSchemaMinExclusiveFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet
#define SOAP_TYPE_xsd__XmlSchemaMinInclusiveFacet (50)
typedef std::string xsd__XmlSchemaMinInclusiveFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaMinLengthFacet
#define SOAP_TYPE_xsd__XmlSchemaMinLengthFacet (51)
typedef std::string xsd__XmlSchemaMinLengthFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaNotation
#define SOAP_TYPE_xsd__XmlSchemaNotation (52)
typedef std::string xsd__XmlSchemaNotation;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaNumericFacet
#define SOAP_TYPE_xsd__XmlSchemaNumericFacet (53)
typedef std::string xsd__XmlSchemaNumericFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaObject
#define SOAP_TYPE_xsd__XmlSchemaObject (54)
typedef std::string xsd__XmlSchemaObject;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaParticle
#define SOAP_TYPE_xsd__XmlSchemaParticle (55)
typedef std::string xsd__XmlSchemaParticle;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaPatternFacet
#define SOAP_TYPE_xsd__XmlSchemaPatternFacet (56)
typedef std::string xsd__XmlSchemaPatternFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaRedefine
#define SOAP_TYPE_xsd__XmlSchemaRedefine (57)
typedef std::string xsd__XmlSchemaRedefine;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSequence
#define SOAP_TYPE_xsd__XmlSchemaSequence (58)
typedef std::string xsd__XmlSchemaSequence;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleContent
#define SOAP_TYPE_xsd__XmlSchemaSimpleContent (59)
typedef std::string xsd__XmlSchemaSimpleContent;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension
#define SOAP_TYPE_xsd__XmlSchemaSimpleContentExtension (60)
typedef std::string xsd__XmlSchemaSimpleContentExtension;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction
#define SOAP_TYPE_xsd__XmlSchemaSimpleContentRestriction (61)
typedef std::string xsd__XmlSchemaSimpleContentRestriction;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleType
#define SOAP_TYPE_xsd__XmlSchemaSimpleType (62)
typedef std::string xsd__XmlSchemaSimpleType;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent
#define SOAP_TYPE_xsd__XmlSchemaSimpleTypeContent (63)
typedef std::string xsd__XmlSchemaSimpleTypeContent;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleTypeList
#define SOAP_TYPE_xsd__XmlSchemaSimpleTypeList (64)
typedef std::string xsd__XmlSchemaSimpleTypeList;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction
#define SOAP_TYPE_xsd__XmlSchemaSimpleTypeRestriction (65)
typedef std::string xsd__XmlSchemaSimpleTypeRestriction;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion
#define SOAP_TYPE_xsd__XmlSchemaSimpleTypeUnion (66)
typedef std::string xsd__XmlSchemaSimpleTypeUnion;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet
#define SOAP_TYPE_xsd__XmlSchemaTotalDigitsFacet (67)
typedef std::string xsd__XmlSchemaTotalDigitsFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaType
#define SOAP_TYPE_xsd__XmlSchemaType (68)
typedef std::string xsd__XmlSchemaType;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaUnique
#define SOAP_TYPE_xsd__XmlSchemaUnique (69)
typedef std::string xsd__XmlSchemaUnique;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaUse
#define SOAP_TYPE_xsd__XmlSchemaUse (70)
typedef std::string xsd__XmlSchemaUse;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet
#define SOAP_TYPE_xsd__XmlSchemaWhiteSpaceFacet (71)
typedef std::string xsd__XmlSchemaWhiteSpaceFacet;
#endif

#ifndef SOAP_TYPE_xsd__XmlSchemaXPath
#define SOAP_TYPE_xsd__XmlSchemaXPath (72)
typedef std::string xsd__XmlSchemaXPath;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (73)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (74)
typedef std::string xsd__token;
#endif

#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (75)
typedef char *_xsd__schema;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (76)
typedef std::string _xml__lang;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
